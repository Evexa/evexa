{"version":3,"file":"swiper-bundle.min.js","names":["Swiper","isObject$1","obj","constructor","Object","extend$1","target","src","keys","forEach","key","length","ssrDocument","body","addEventListener","removeEventListener","activeElement","blur","nodeName","querySelector","querySelectorAll","getElementById","createEvent","initEvent","createElement","children","childNodes","style","setAttribute","getElementsByTagName","createElementNS","importNode","location","hash","host","hostname","href","origin","pathname","protocol","search","getDocument","doc","document","ssrWindow","navigator","userAgent","history","replaceState","pushState","go","back","CustomEvent","this","getComputedStyle","getPropertyValue","Image","Date","screen","setTimeout","clearTimeout","matchMedia","requestAnimationFrame","callback","cancelAnimationFrame","id","getWindow","win","window","classesToTokens","classes","trim","split","filter","c","nextTick","delay","now","getTranslate","el","axis","matrix","curTransform","transformMatrix","curStyle","currentStyle","getComputedStyle$1","WebKitCSSMatrix","transform","webkitTransform","map","a","replace","join","MozTransform","OTransform","MsTransform","msTransform","toString","m41","parseFloat","m42","isObject","o","prototype","call","slice","extend","to","arguments","undefined","noExtend","i","nextSource","node","HTMLElement","nodeType","keysArray","indexOf","nextIndex","len","nextKey","desc","getOwnPropertyDescriptor","enumerable","__swiper__","setCSSProperty","varName","varValue","setProperty","animateCSSModeScroll","_ref","swiper","targetPosition","side","startPosition","translate","time","startTime","duration","params","speed","wrapperEl","scrollSnapType","cssModeFrameID","dir","isOutOfBound","current","animate","getTime","progress","Math","max","min","easeProgress","cos","PI","currentPosition","scrollTo","overflow","getSlideTransformEl","slideEl","shadowRoot","elementChildren","element","selector","matches","showWarning","text","console","warn","err","tag","classList","add","Array","isArray","elementOffset","box","getBoundingClientRect","clientTop","clientLeft","scrollTop","scrollY","scrollLeft","scrollX","top","left","elementStyle","prop","elementIndex","child","previousSibling","elementParents","parents","parent","parentElement","push","elementTransitionEnd","fireCallBack","e","elementOuterSize","size","includeMargins","offsetWidth","makeElementsArray","support","deviceCached","browser","getSupport","smoothScroll","documentElement","touch","DocumentTouch","calcSupport","getDevice","overrides","_temp","platform","ua","device","ios","android","screenWidth","width","screenHeight","height","match","ipad","ipod","iphone","windows","macos","os","calcDevice","getBrowser","needPerspectiveFix","isSafari","toLowerCase","String","includes","major","minor","num","Number","isWebView","test","isSafariBrowser","need3dFix","calcBrowser","eventsEmitter","on","events","handler","priority","self","eventsListeners","destroyed","method","event","once","onceHandler","off","__emitterProxy","_len","args","_key","apply","onAny","eventsAnyListeners","offAny","index","splice","eventHandler","emit","data","context","_len2","_key2","unshift","toggleSlideClasses$1","condition","className","contains","remove","toggleSlideClasses","processLazyPreloader","imageEl","closest","isElement","slideClass","lazyEl","lazyPreloaderClass","unlazy","slides","removeAttribute","preload","amount","lazyPreloadPrevNext","slidesPerView","slidesPerViewDynamic","ceil","activeIndex","grid","rows","activeColumn","preloadColumns","from","_","column","slideIndexLastInView","rewind","loop","realIndex","update","updateSize","clientWidth","clientHeight","isHorizontal","isVertical","parseInt","isNaN","assign","updateSlides","getDirectionPropertyValue","label","getDirectionLabel","slidesEl","swiperSize","rtlTranslate","rtl","wrongRTL","isVirtual","virtual","enabled","previousSlidesLength","slidesLength","snapGrid","slidesGrid","slidesSizesGrid","offsetBefore","slidesOffsetBefore","offsetAfter","slidesOffsetAfter","previousSnapGridLength","previousSlidesGridLength","spaceBetween","slidePosition","prevSlideSize","virtualSize","marginLeft","marginRight","marginBottom","marginTop","centeredSlides","cssMode","gridEnabled","slideSize","initSlides","unsetSlides","shouldResetSlideSize","breakpoints","slide","updateSlide","slideStyles","currentTransform","currentWebKitTransform","roundLengths","paddingLeft","paddingRight","boxSizing","floor","swiperSlideSize","abs","slidesPerGroup","slidesPerGroupSkip","effect","setWrapperSize","updateWrapperSize","newSlidesGrid","slidesGridItem","groups","slidesBefore","slidesAfter","groupSize","slideIndex","centeredSlidesBounds","allSlidesSize","slideSizeValue","maxSnap","snap","centerInsufficientSlides","offsetSize","allSlidesOffset","snapIndex","addToSnapGrid","addToSlidesGrid","v","watchOverflow","checkOverflow","watchSlidesProgress","updateSlidesOffset","backFaceHiddenClass","containerModifierClass","hasClassBackfaceClassAdded","maxBackfaceHiddenSlides","updateAutoHeight","activeSlides","newHeight","setTransition","getSlideByIndex","getSlideIndexByData","visibleSlides","offsetHeight","minusOffset","offsetLeft","offsetTop","swiperSlideOffset","cssOverflowAdjustment","updateSlidesProgress","offsetCenter","visibleSlidesIndexes","slideOffset","slideProgress","minTranslate","originalSlideProgress","slideBefore","slideAfter","isFullyVisible","isVisible","slideVisibleClass","slideFullyVisibleClass","originalProgress","updateProgress","multiplier","translatesDiff","maxTranslate","isBeginning","isEnd","progressLoop","wasBeginning","wasEnd","isBeginningRounded","isEndRounded","firstSlideIndex","lastSlideIndex","firstSlideTranslate","lastSlideTranslate","translateMax","translateAbs","autoHeight","updateSlidesClasses","getFilteredSlide","activeSlide","prevSlide","nextSlide","nextEls","nextElementSibling","next","elementNextAll","prevEls","previousElementSibling","prev","elementPrevAll","slideActiveClass","slideNextClass","slidePrevClass","emitSlidesClasses","updateActiveIndex","newActiveIndex","previousIndex","previousRealIndex","previousSnapIndex","getVirtualRealIndex","aIndex","normalizeSlideIndex","getActiveIndexByTranslate","skip","firstSlideInColumn","activeSlideIndex","getAttribute","initialized","runCallbacksOnInit","updateClickedSlide","path","pathEl","slideFound","clickedSlide","clickedIndex","slideToClickedSlide","virtualTranslate","currentTranslate","setTranslate","byController","newProgress","x","y","previousTranslate","translateTo","runCallbacks","translateBounds","internal","animating","preventInteractionOnTransition","newTranslate","isH","behavior","onTranslateToWrapperTransitionEnd","transitionEmit","direction","step","slideTo","initial","normalizedTranslate","normalizedGrid","normalizedGridNext","allowSlideNext","allowSlidePrev","transitionStart","transitionEnd","t","_immediateVirtual","_cssModeVirtualInitialSet","initialSlide","onSlideToWrapperTransitionEnd","slideToLoop","newIndex","targetSlideIndex","cols","needLoopFix","loopFix","slideRealIndex","slideNext","perGroup","slidesPerGroupAuto","increment","loopPreventsSliding","_clientLeft","slidePrev","normalize","val","normalizedSnapGrid","prevSnap","prevSnapIndex","prevIndex","lastIndex","slideReset","slideToClosest","threshold","currentSnap","slideToIndex","slideSelector","loopedSlides","getSlideIndex","loopCreate","shouldFillGroup","shouldFillGrid","addBlankSlides","amountOfSlides","slideBlankClass","append","loopAddBlankSlides","recalcSlides","byMousewheel","loopAdditionalSlides","fill","prependSlidesIndexes","appendSlidesIndexes","isNext","isPrev","slidesPrepended","slidesAppended","activeColIndexWithShift","colIndexToPrepend","__preventObserver__","swiperLoopMoveDOM","prepend","currentSlideTranslate","diff","touchEventsData","startTranslate","shift","controller","control","loopParams","loopDestroy","newSlidesOrder","swiperSlideIndex","preventEdgeSwipe","startX","edgeSwipeDetection","edgeSwipeThreshold","innerWidth","preventDefault","onTouchStart","originalEvent","type","pointerId","targetTouches","touchId","identifier","pageX","touches","simulateTouch","pointerType","targetEl","touchEventsTarget","which","button","isTouched","isMoved","swipingClassHasValue","noSwipingClass","eventPath","composedPath","noSwipingSelector","isTargetShadow","noSwiping","base","__closestFrom","assignedSlot","found","getRootNode","closestElement","allowClick","swipeHandler","currentX","currentY","pageY","startY","allowTouchCallbacks","isScrolling","startMoving","touchStartTime","swipeDirection","allowThresholdMove","focusableElements","shouldPreventDefault","allowTouchMove","touchStartPreventDefault","touchStartForcePreventDefault","isContentEditable","freeMode","onTouchMove","targetTouch","changedTouches","preventedByNestedSwiper","touchReleaseOnEdges","previousX","previousY","diffX","diffY","sqrt","touchAngle","atan2","preventTouchMoveFromPointerMove","cancelable","touchMoveStopPropagation","nested","stopPropagation","touchesDiff","oneWayMovement","touchRatio","prevTouchesDirection","touchesDirection","isLoop","allowLoopFix","evt","bubbles","detail","bySwiperTouchMove","dispatchEvent","allowMomentumBounce","grabCursor","setGrabCursor","loopSwapReset","disableParentSwiper","resistanceRatio","resistance","followFinger","onTouchEnd","touchEndTime","timeDiff","pathTree","lastClickTime","currentPos","swipeToLast","stopIndex","rewindFirstIndex","rewindLastIndex","ratio","longSwipesMs","longSwipes","longSwipesRatio","shortSwipes","navigation","nextEl","prevEl","onResize","setBreakpoint","isVirtualLoop","autoplay","running","paused","resizeTimeout","resume","onClick","preventClicks","preventClicksPropagation","stopImmediatePropagation","onScroll","onLoad","onDocumentTouchStart","documentTouchHandlerProceeded","touchAction","capture","domMethod","swiperMethod","passive","updateOnWindowResize","isGridEnabled","defaults","init","swiperElementNodeName","resizeObserver","createElements","eventsPrefix","url","breakpointsBase","uniqueNavElements","passiveListeners","wrapperClass","_emitClasses","moduleExtendParams","allModulesParams","moduleParamName","moduleParams","auto","prototypes","transition","transitionDuration","transitionDelay","moving","isLocked","cursor","unsetGrabCursor","attachEvents","bind","detachEvents","breakpoint","getBreakpoint","currentBreakpoint","breakpointParams","originalParams","wasMultiRow","isMultiRow","wasGrabCursor","isGrabCursor","wasEnabled","emitContainerClasses","wasModuleEnabled","isModuleEnabled","disable","enable","directionChanged","needsReLoop","wasLoop","changeDirection","isEnabled","hasLoop","containerEl","currentHeight","innerHeight","points","point","minRatio","substr","value","sort","b","wasLocked","lastSlideRightEdge","addClasses","classNames","suffixes","entries","prefix","resultClasses","item","prepareClasses","autoheight","centered","removeClasses","extendedDefaults","swipers","newParams","modules","__modules__","mod","extendParams","swiperParams","passedParams","eventName","velocity","trunc","clickTimeout","velocities","imagesToLoad","imagesLoaded","property","setProgress","cls","getSlideClasses","updates","view","exact","spv","breakLoop","translateValue","translated","complete","newDirection","needUpdate","currentDirection","changeLanguageDirection","mount","mounted","parentNode","toUpperCase","getWrapperSelector","getWrapper","slideSlots","hostEl","lazyElements","destroy","deleteInstance","cleanStyles","object","deleteProps","extendDefaults","newDefaults","installModule","use","module","m","createElementIfNotDefined","checkProps","classesToSelector","appendSlide","appendElement","tempDOM","innerHTML","observer","prependSlide","prependElement","addSlide","activeIndexBuffer","baseLength","slidesBuffer","currentSlide","removeSlide","slidesIndexes","indexToRemove","removeAllSlides","effectInit","overwriteParams","perspective","recreateShadows","getEffectParams","requireUpdateOnVirtual","overwriteParamsResult","_s","slideShadows","shadowEl","effectTarget","effectParams","transformEl","backfaceVisibility","effectVirtualTransitionEnd","transformElements","allSlides","transitionEndTarget","eventTriggered","getSlide","createShadow","suffix","shadowClass","shadowContainer","prototypeGroup","protoMethod","animationFrame","resizeHandler","orientationChangeHandler","ResizeObserver","newWidth","_ref2","contentBoxSize","contentRect","inlineSize","blockSize","observe","unobserve","observers","attach","options","MutationObserver","WebkitMutationObserver","mutations","observerUpdate","attributes","childList","characterData","observeParents","observeSlideChildren","containerParents","disconnect","cssModeTimeout","cache","renderSlide","renderExternal","renderExternalUpdate","addSlidesBefore","addSlidesAfter","offset","force","beforeInit","previousFrom","previousTo","previousSlidesGrid","previousOffset","offsetProp","onRendered","slidesToRender","prependIndexes","appendIndexes","loopFrom","loopTo","domSlidesAssigned","numberOfNewSlides","newCache","cachedIndex","cachedEl","cachedElIndex","handle","kc","keyCode","charCode","pageUpDown","keyboard","isPageUp","isPageDown","isArrowLeft","isArrowRight","isArrowUp","isArrowDown","shiftKey","altKey","ctrlKey","metaKey","onlyInViewport","inView","swiperWidth","swiperHeight","windowWidth","windowHeight","swiperOffset","swiperCoord","returnValue","timeout","mousewheel","releaseOnEdges","invert","forceToAxis","sensitivity","eventsTarget","thresholdDelta","thresholdTime","noMousewheelClass","lastEventBeforeSnap","lastScrollTime","recentWheelEvents","handleMouseEnter","mouseEntered","handleMouseLeave","animateSlider","newEvent","delta","raw","targetElContainsTarget","rtlFactor","sX","sY","pX","pY","wheelDelta","wheelDeltaY","wheelDeltaX","HORIZONTAL_AXIS","deltaY","deltaX","deltaMode","spinX","spinY","pixelX","pixelY","positions","sign","ignoreWheelEvents","position","sticky","prevEvent","firstEvent","snapToThreshold","autoplayDisableOnInteraction","stop","releaseScroll","getEl","res","toggleEl","disabled","subEl","disabledClass","tagName","lockClass","onPrevClick","onNextClick","initButton","destroyButton","hideOnClick","hiddenClass","navigationDisabledClass","targetIsButton","find","pagination","clickable","isHidden","toggle","pfx","bulletSize","bulletElement","renderBullet","renderProgressbar","renderFraction","renderCustom","progressbarOpposite","dynamicBullets","dynamicMainBullets","formatFractionCurrent","number","formatFractionTotal","bulletClass","bulletActiveClass","modifierClass","currentClass","totalClass","progressbarFillClass","progressbarOppositeClass","clickableClass","horizontalClass","verticalClass","paginationDisabledClass","bullets","dynamicBulletIndex","isPaginationDisabled","setSideBullets","bulletEl","onBulletClick","total","firstIndex","midIndex","classesToRemove","s","flat","bullet","bulletIndex","firstDisplayedBullet","lastDisplayedBullet","dynamicBulletsLength","bulletsOffset","subElIndex","fractionEl","textContent","totalEl","progressbarDirection","scale","scaleX","scaleY","progressEl","render","paginationHTML","numberOfBullets","dragStartPos","dragSize","trackSize","divider","dragTimeout","scrollbar","dragEl","newSize","newPos","hide","opacity","display","getPointerPosition","clientX","clientY","setDragPosition","positionRatio","onDragStart","onDragMove","onDragEnd","snapOnRelease","activeListener","passiveListener","eventMethod","swiperEl","dragClass","draggable","scrollbarDisabledClass","parallax","elementsSelector","setTransform","p","rotate","currentOpacity","elements","_swiper","parallaxEl","parallaxDuration","zoom","limitToOriginalSize","maxRatio","containerClass","zoomedSlideClass","fakeGestureTouched","fakeGestureMoved","currentScale","isScaling","evCache","gesture","originX","originY","slideWidth","slideHeight","imageWrapEl","image","minX","minY","maxX","maxY","touchesStart","touchesCurrent","prevPositionX","prevPositionY","prevTime","allowTouchMoveTimeout","getDistanceBetweenTouches","x1","y1","x2","y2","getMaxRatio","naturalWidth","imageMaxRatio","eventWithinSlide","onGestureStart","scaleStart","getScaleOrigin","onGestureChange","pointerIndex","findIndex","cachedEv","scaleMove","onGestureEnd","eventWithinZoomContainer","scaledWidth","scaledHeight","scaleRatio","onTransitionEnd","zoomIn","touchX","touchY","offsetX","offsetY","translateX","translateY","imageWidth","imageHeight","translateMinX","translateMinY","translateMaxX","translateMaxY","forceZoomRatio","zoomOut","zoomToggle","getListeners","activeListenerWithCapture","defineProperty","get","set","momentumDurationX","momentumDurationY","momentumDistanceX","newPositionX","momentumDistanceY","newPositionY","momentumDuration","in","out","LinearSpline","binarySearch","maxIndex","minIndex","guess","array","i1","i3","interpolate","removeSpline","spline","inverse","by","controlElement","onControllerSwiper","_t","controlled","controlledTranslate","setControlledTranslate","getInterpolateFunction","isFinite","setControlledTransition","a11y","notificationClass","prevSlideMessage","BX","message","nextSlideMessage","firstSlideMessage","lastSlideMessage","paginationBulletMessage","slideLabelMessage","containerMessage","containerRoleDescriptionMessage","itemRoleDescriptionMessage","slideRole","clicked","preventFocusHandler","focusTargetSlideEl","liveRegion","visibilityChangedTimestamp","notify","notification","makeElFocusable","makeElNotFocusable","addElRole","role","addElRoleDescription","description","addElLabel","disableEl","enableEl","onEnterOrSpaceKey","click","hasPagination","hasClickablePagination","initNavEl","wrapperId","controls","addElControls","handlePointerDown","handlePointerUp","onVisibilityChange","handleFocus","isActive","sourceCapabilities","firesTouchEvents","repeat","round","random","live","addElLive","updateNavigation","updatePagination","root","keepQuery","paths","slugify","getPathValues","urlOverride","URL","pathArray","part","setHistory","currentState","state","scrollToSlide","setHistoryPopState","hashNavigation","watchState","slideWithHash","onHashChange","newHash","activeSlideEl","setHash","activeSlideHash","raf","timeLeft","waitForTransition","disableOnInteraction","stopOnLastSlide","reverseDirection","pauseOnMouseEnter","autoplayTimeLeft","wasPaused","pausedByTouch","touchStartTimeout","slideChanged","pausedByInteraction","pausedByPointerEnter","autoplayDelayTotal","autoplayDelayCurrent","autoplayStartTime","calcTimeLeft","run","delayForce","currentSlideDelay","getSlideDelay","proceed","start","pause","reset","visibilityState","onPointerEnter","onPointerLeave","thumbs","multipleActiveThumbs","autoScrollOffset","slideThumbActiveClass","thumbsContainerClass","swiperCreated","onThumbClick","thumbsSwiper","thumbsParams","SwiperClass","thumbsSwiperParams","thumbsToActivate","thumbActiveClass","useOffset","currentThumbsIndex","newThumbsIndex","newThumbsSlide","getThumbsElementAndInit","thumbsElement","onThumbsSwiper","watchForThumbsToAppear","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","minimumVelocity","lastMoveEvent","pop","velocityEvent","distance","momentumDistance","newPosition","afterBouncePosition","doBounce","bounceAmount","needsLoopFix","j","moveDistance","currentSlideSize","slidesNumberEvenToRows","slidesPerRow","numFullColumns","getSpaceBetween","swiperSlideGridSet","newSlideOrderIndex","row","groupIndex","slideIndexInGroup","columnsInGroup","order","fadeEffect","crossFade","tx","ty","slideOpacity","cubeEffect","shadow","shadowOffset","shadowScale","createSlideShadows","shadowBefore","shadowAfter","cubeShadowEl","wrapperRotate","slideAngle","tz","transformOrigin","shadowAngle","sin","scale1","scale2","zFactor","flipEffect","limitRotation","rotateY","rotateX","zIndex","coverflowEffect","stretch","depth","modifier","center","centerOffset","offsetMultiplier","translateZ","slideTransform","shadowBeforeEl","shadowAfterEl","creativeEffect","limitProgress","shadowPerProgress","progressMultiplier","getTranslateValue","isCenteredSlides","margin","r","custom","translateString","rotateString","scaleString","opacityString","shadowOpacity","cardsEffect","perSlideRotate","perSlideOffset","tX","tY","tZ","tXAdd","isSwipeToNext","isSwipeToPrev","subProgress","prevY"],"sources":["swiper/swiper-bundle.js"],"mappings":"AAYA,IAAIA,OAAS,WACT,aAcA,SAASC,EAAWC,GAChB,OAAe,OAARA,GAA+B,iBAARA,GAAoB,gBAAiBA,GAAOA,EAAIC,cAAgBC,MAClG,CACA,SAASC,EAASC,EAAQC,QACP,IAAXD,IACAA,EAAS,CAAC,QAEF,IAARC,IACAA,EAAM,CAAC,GAEXH,OAAOI,KAAKD,GAAKE,SAAQC,SACM,IAAhBJ,EAAOI,GAAsBJ,EAAOI,GAAOH,EAAIG,GAAcT,EAAWM,EAAIG,KAAST,EAAWK,EAAOI,KAASN,OAAOI,KAAKD,EAAIG,IAAMC,OAAS,GACtJN,EAASC,EAAOI,GAAMH,EAAIG,GAC9B,GAER,CACA,MAAME,EAAc,CAChBC,KAAM,CAAC,EACP,gBAAAC,GAAoB,EACpB,mBAAAC,GAAuB,EACvBC,cAAe,CACX,IAAAC,GAAQ,EACRC,SAAU,IAEdC,cAAa,IACF,KAEXC,iBAAgB,IACL,GAEXC,eAAc,IACH,KAEXC,YAAW,KACA,CACH,SAAAC,GAAa,IAGrBC,cAAa,KACF,CACHC,SAAU,GACVC,WAAY,GACZC,MAAO,CAAC,EACR,YAAAC,GAAgB,EAChBC,qBAAoB,IACT,KAInBC,gBAAe,KACJ,CAAC,GAEZC,WAAU,IACC,KAEXC,SAAU,CACNC,KAAM,GACNC,KAAM,GACNC,SAAU,GACVC,KAAM,GACNC,OAAQ,GACRC,SAAU,GACVC,SAAU,GACVC,OAAQ,KAGhB,SAASC,IACL,MAAMC,EAA0B,oBAAbC,SAA2BA,SAAW,CAAC,EAE1D,OADAtC,EAASqC,EAAK9B,GACP8B,CACX,CACA,MAAME,EAAY,CACdD,SAAU/B,EACViC,UAAW,CACPC,UAAW,IAEfd,SAAU,CACNC,KAAM,GACNC,KAAM,GACNC,SAAU,GACVC,KAAM,GACNC,OAAQ,GACRC,SAAU,GACVC,SAAU,GACVC,OAAQ,IAEZO,QAAS,CACL,YAAAC,GAAgB,EAChB,SAAAC,GAAa,EACb,EAAAC,GAAM,EACN,IAAAC,GAAQ,GAEZC,YAAa,WACT,OAAOC,IACX,EACA,gBAAAvC,GAAoB,EACpB,mBAAAC,GAAuB,EACvBuC,iBAAgB,KACL,CACHC,iBAAgB,IACL,KAInB,KAAAC,GAAS,EACT,IAAAC,GAAQ,EACRC,OAAQ,CAAC,EACT,UAAAC,GAAc,EACd,YAAAC,GAAgB,EAChBC,WAAU,KACC,CAAC,GAEZC,sBAAsBC,GACQ,oBAAfJ,YACPI,IACO,MAEJJ,WAAWI,EAAU,GAEhC,oBAAAC,CAAqBC,GACS,oBAAfN,YAGXC,aAAaK,EACjB,GAEJ,SAASC,IACL,MAAMC,EAAwB,oBAAXC,OAAyBA,OAAS,CAAC,EAEtD,OADA/D,EAAS8D,EAAKvB,GACPuB,CACX,CAEA,SAASE,EAAgBC,GAIrB,YAHgB,IAAZA,IACAA,EAAU,IAEPA,EAAQC,OAAOC,MAAM,KAAKC,QAAOC,KAAOA,EAAEH,QACrD,CAiBA,SAASI,EAASZ,EAAUa,GAIxB,YAHc,IAAVA,IACAA,EAAQ,GAELjB,WAAWI,EAAUa,EAChC,CACA,SAASC,IACL,OAAOpB,KAAKoB,KAChB,CAeA,SAASC,EAAaC,EAAIC,QACT,IAATA,IACAA,EAAO,KAEX,MAAMZ,EAASF,IACf,IAAIe,EACAC,EACAC,EACJ,MAAMC,EAtBV,SAA4BL,GACxB,MAAMX,EAASF,IACf,IAAIvC,EAUJ,OATIyC,EAAOd,mBACP3B,EAAQyC,EAAOd,iBAAiByB,EAAI,QAEnCpD,GAASoD,EAAGM,eACb1D,EAAQoD,EAAGM,cAEV1D,IACDA,EAAQoD,EAAGpD,OAERA,CACX,CASqB2D,CAAmBP,GA6BpC,OA5BIX,EAAOmB,iBACPL,EAAeE,EAASI,WAAaJ,EAASK,gBAC1CP,EAAaV,MAAM,KAAK7D,OAAS,IACjCuE,EAAeA,EAAaV,MAAM,MAAMkB,KAAIC,GAAKA,EAAEC,QAAQ,IAAK,OAAMC,KAAK,OAI/EV,EAAkB,IAAIf,EAAOmB,gBAAiC,SAAjBL,EAA0B,GAAKA,KAE5EC,EAAkBC,EAASU,cAAgBV,EAASW,YAAcX,EAASY,aAAeZ,EAASa,aAAeb,EAASI,WAAaJ,EAAS7B,iBAAiB,aAAaqC,QAAQ,aAAc,sBACrMX,EAASE,EAAgBe,WAAW1B,MAAM,MAEjC,MAATQ,IAE4BE,EAAxBd,EAAOmB,gBAAgCJ,EAAgBgB,IAEhC,KAAlBlB,EAAOtE,OAA8ByF,WAAWnB,EAAO,KAE5CmB,WAAWnB,EAAO,KAE7B,MAATD,IAE4BE,EAAxBd,EAAOmB,gBAAgCJ,EAAgBkB,IAEhC,KAAlBpB,EAAOtE,OAA8ByF,WAAWnB,EAAO,KAE5CmB,WAAWnB,EAAO,KAEnCC,GAAgB,CAC3B,CACA,SAASoB,EAASC,GACd,MAAoB,iBAANA,GAAwB,OAANA,GAAcA,EAAEpG,aAAkE,WAAnDC,OAAOoG,UAAUN,SAASO,KAAKF,GAAGG,MAAM,GAAI,EAC/G,CAQA,SAASC,IACL,MAAMC,EAAKxG,OAAOyG,UAAUlG,QAAU,OAAImG,EAAYD,UAAU,IAC1DE,EAAW,CAAC,YAAa,cAAe,aAC9C,IAAK,IAAIC,EAAI,EAAGA,EAAIH,UAAUlG,OAAQqG,GAAK,EAAG,CAC1C,MAAMC,EAAaD,EAAI,GAAKH,UAAUlG,QAAUqG,OAAIF,EAAYD,UAAUG,GAC1E,GAAIC,UAZIC,EAYuDD,IAV7C,oBAAX7C,aAAwD,IAAvBA,OAAO+C,YACxCD,aAAgBC,YAEpBD,IAA2B,IAAlBA,EAAKE,UAAoC,KAAlBF,EAAKE,YAOoC,CACxE,MAAMC,EAAYjH,OAAOI,KAAKJ,OAAO6G,IAAaxC,QAAO/D,GAAOqG,EAASO,QAAQ5G,GAAO,IACxF,IAAK,IAAI6G,EAAY,EAAGC,EAAMH,EAAU1G,OAAQ4G,EAAYC,EAAKD,GAAa,EAAG,CAC7E,MAAME,EAAUJ,EAAUE,GACpBG,EAAOtH,OAAOuH,yBAAyBV,EAAYQ,QAC5CX,IAATY,GAAsBA,EAAKE,aACvBtB,EAASM,EAAGa,KAAanB,EAASW,EAAWQ,IACzCR,EAAWQ,GAASI,WACpBjB,EAAGa,GAAWR,EAAWQ,GAEzBd,EAAOC,EAAGa,GAAUR,EAAWQ,KAE3BnB,EAASM,EAAGa,KAAanB,EAASW,EAAWQ,KACrDb,EAAGa,GAAW,CAAC,EACXR,EAAWQ,GAASI,WACpBjB,EAAGa,GAAWR,EAAWQ,GAEzBd,EAAOC,EAAGa,GAAUR,EAAWQ,KAGnCb,EAAGa,GAAWR,EAAWQ,GAGrC,CACJ,CACJ,CArCJ,IAAgBP,EAsCZ,OAAON,CACX,CACA,SAASkB,EAAe/C,EAAIgD,EAASC,GACjCjD,EAAGpD,MAAMsG,YAAYF,EAASC,EAClC,CACA,SAASE,EAAqBC,GAC1B,IAAIC,OACAA,EAAMC,eACNA,EAAcC,KACdA,GACAH,EACJ,MAAM/D,EAASF,IACTqE,GAAiBH,EAAOI,UAC9B,IACIC,EADAC,EAAY,KAEhB,MAAMC,EAAWP,EAAOQ,OAAOC,MAC/BT,EAAOU,UAAUnH,MAAMoH,eAAiB,OACxC3E,EAAOJ,qBAAqBoE,EAAOY,gBACnC,MAAMC,EAAMZ,EAAiBE,EAAgB,OAAS,OAChDW,EAAe,CAACC,EAAS7I,IACZ,SAAR2I,GAAkBE,GAAW7I,GAAkB,SAAR2I,GAAkBE,GAAW7I,EAEzE8I,EAAU,KACZX,GAAO,IAAIhF,MAAO4F,UACA,OAAdX,IACAA,EAAYD,GAEhB,MAAMa,EAAWC,KAAKC,IAAID,KAAKE,KAAKhB,EAAOC,GAAaC,EAAU,GAAI,GAChEe,EAAe,GAAMH,KAAKI,IAAIL,EAAWC,KAAKK,IAAM,EAC1D,IAAIC,EAAkBtB,EAAgBmB,GAAgBrB,EAAiBE,GAOvE,GANIW,EAAaW,EAAiBxB,KAC9BwB,EAAkBxB,GAEtBD,EAAOU,UAAUgB,SAAS,CACtBxB,CAACA,GAAOuB,IAERX,EAAaW,EAAiBxB,GAU9B,OATAD,EAAOU,UAAUnH,MAAMoI,SAAW,SAClC3B,EAAOU,UAAUnH,MAAMoH,eAAiB,GACxCpF,YAAW,KACPyE,EAAOU,UAAUnH,MAAMoI,SAAW,GAClC3B,EAAOU,UAAUgB,SAAS,CACtBxB,CAACA,GAAOuB,GACV,SAENzF,EAAOJ,qBAAqBoE,EAAOY,gBAGvCZ,EAAOY,eAAiB5E,EAAON,sBAAsBsF,EAAQ,EAEjEA,GACJ,CACA,SAASY,EAAoBC,GACzB,OAAOA,EAAQ9I,cAAc,4BAA8B8I,EAAQC,YAAcD,EAAQC,WAAW/I,cAAc,4BAA8B8I,CACpJ,CACA,SAASE,EAAgBC,EAASC,GAI9B,YAHiB,IAAbA,IACAA,EAAW,IAER,IAAID,EAAQ3I,UAAUgD,QAAOM,GAAMA,EAAGuF,QAAQD,IACzD,CACA,SAASE,EAAYC,GACjB,IAEI,YADAC,QAAQC,KAAKF,EAEjB,CAAE,MAAOG,GAET,CACJ,CACA,SAASnJ,EAAcoJ,EAAKtG,QACR,IAAZA,IACAA,EAAU,IAEd,MAAMS,EAAKpC,SAASnB,cAAcoJ,GAElC,OADA7F,EAAG8F,UAAUC,OAAQC,MAAMC,QAAQ1G,GAAWA,EAAUD,EAAgBC,IACjES,CACX,CACA,SAASkG,EAAclG,GACnB,MAAMX,EAASF,IACTvB,EAAWF,IACXyI,EAAMnG,EAAGoG,wBACTtK,EAAO8B,EAAS9B,KAChBuK,EAAYrG,EAAGqG,WAAavK,EAAKuK,WAAa,EAC9CC,EAAatG,EAAGsG,YAAcxK,EAAKwK,YAAc,EACjDC,EAAYvG,IAAOX,EAASA,EAAOmH,QAAUxG,EAAGuG,UAChDE,EAAazG,IAAOX,EAASA,EAAOqH,QAAU1G,EAAGyG,WACvD,MAAO,CACHE,IAAKR,EAAIQ,IAAMJ,EAAYF,EAC3BO,KAAMT,EAAIS,KAAOH,EAAaH,EAEtC,CAuBA,SAASO,EAAa7G,EAAI8G,GAEtB,OADe3H,IACDZ,iBAAiByB,EAAI,MAAMxB,iBAAiBsI,EAC9D,CACA,SAASC,EAAa/G,GAClB,IACIiC,EADA+E,EAAQhH,EAEZ,GAAIgH,EAAO,CAGP,IAFA/E,EAAI,EAEuC,QAAnC+E,EAAQA,EAAMC,kBACK,IAAnBD,EAAM3E,WAAgBJ,GAAK,GAEnC,OAAOA,CACX,CAEJ,CACA,SAASiF,EAAelH,EAAIsF,GACxB,MAAM6B,EAAU,GAChB,IAAIC,EAASpH,EAAGqH,cAChB,KAAOD,GACC9B,EACI8B,EAAO7B,QAAQD,IAAW6B,EAAQG,KAAKF,GAE3CD,EAAQG,KAAKF,GAEjBA,EAASA,EAAOC,cAEpB,OAAOF,CACX,CACA,SAASI,EAAqBvH,EAAIhB,GAM1BA,GACAgB,EAAGjE,iBAAiB,iBANxB,SAASyL,EAAaC,GACdA,EAAElM,SAAWyE,IACjBhB,EAAS0C,KAAK1B,EAAIyH,GAClBzH,EAAGhE,oBAAoB,gBAAiBwL,GAC5C,GAIJ,CACA,SAASE,EAAiB1H,EAAI2H,EAAMC,GAChC,MAAMvI,EAASF,IACf,OAAIyI,EACO5H,EAAY,UAAT2H,EAAmB,cAAgB,gBAAkBtG,WAAWhC,EAAOd,iBAAiByB,EAAI,MAAMxB,iBAA0B,UAATmJ,EAAmB,eAAiB,eAAiBtG,WAAWhC,EAAOd,iBAAiByB,EAAI,MAAMxB,iBAA0B,UAATmJ,EAAmB,cAAgB,kBAEhR3H,EAAG6H,WACd,CACA,SAASC,EAAkB9H,GACvB,OAAQgG,MAAMC,QAAQjG,GAAMA,EAAK,CAACA,IAAKN,QAAO+H,KAAOA,GACzD,CAEA,IAAIM,EAgBAC,EAqDAC,EA5DJ,SAASC,IAIL,OAHKH,IACDA,EAVR,WACI,MAAM1I,EAASF,IACTvB,EAAWF,IACjB,MAAO,CACHyK,aAAcvK,EAASwK,iBAAmBxK,EAASwK,gBAAgBxL,OAAS,mBAAoBgB,EAASwK,gBAAgBxL,MACzHyL,SAAU,iBAAkBhJ,GAAUA,EAAOiJ,eAAiB1K,aAAoByB,EAAOiJ,eAEjG,CAGkBC,IAEPR,CACX,CA6CA,SAASS,EAAUC,GAOf,YANkB,IAAdA,IACAA,EAAY,CAAC,GAEZT,IACDA,EA/CR,SAAoBU,GAChB,IAAI3K,UACAA,QACU,IAAV2K,EAAmB,CAAC,EAAIA,EAC5B,MAAMX,EAAUG,IACV7I,EAASF,IACTwJ,EAAWtJ,EAAOvB,UAAU6K,SAC5BC,EAAK7K,GAAasB,EAAOvB,UAAUC,UACnC8K,EAAS,CACXC,KAAK,EACLC,SAAS,GAEPC,EAAc3J,EAAOV,OAAOsK,MAC5BC,EAAe7J,EAAOV,OAAOwK,OAC7BJ,EAAUH,EAAGQ,MAAM,+BACzB,IAAIC,EAAOT,EAAGQ,MAAM,wBACpB,MAAME,EAAOV,EAAGQ,MAAM,2BAChBG,GAAUF,GAAQT,EAAGQ,MAAM,8BAC3BI,EAAuB,UAAbb,EAChB,IAAIc,EAAqB,aAAbd,EAqBZ,OAjBKU,GAAQI,GAAS1B,EAAQM,OADV,CAAC,YAAa,YAAa,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,YACxG9F,QAAQ,GAAGyG,KAAeE,MAAmB,IAC5FG,EAAOT,EAAGQ,MAAM,uBACXC,IAAMA,EAAO,CAAC,EAAG,EAAG,WACzBI,GAAQ,GAIRV,IAAYS,IACZX,EAAOa,GAAK,UACZb,EAAOE,SAAU,IAEjBM,GAAQE,GAAUD,KAClBT,EAAOa,GAAK,MACZb,EAAOC,KAAM,GAIVD,CACX,CAMuBc,CAAWlB,IAEvBT,CACX,CA4BA,SAAS4B,IAIL,OAHK3B,IACDA,EA3BR,WACI,MAAM5I,EAASF,IACT0J,EAASL,IACf,IAAIqB,GAAqB,EACzB,SAASC,IACL,MAAMlB,EAAKvJ,EAAOvB,UAAUC,UAAUgM,cACtC,OAAOnB,EAAGrG,QAAQ,WAAa,GAAKqG,EAAGrG,QAAQ,UAAY,GAAKqG,EAAGrG,QAAQ,WAAa,CAC5F,CACA,GAAIuH,IAAY,CACZ,MAAMlB,EAAKoB,OAAO3K,EAAOvB,UAAUC,WACnC,GAAI6K,EAAGqB,SAAS,YAAa,CACzB,MAAOC,EAAOC,GAASvB,EAAGnJ,MAAM,YAAY,GAAGA,MAAM,KAAK,GAAGA,MAAM,KAAKkB,KAAIyJ,GAAOC,OAAOD,KAC1FP,EAAqBK,EAAQ,IAAgB,KAAVA,GAAgBC,EAAQ,CAC/D,CACJ,CACA,MAAMG,EAAY,+CAA+CC,KAAKlL,EAAOvB,UAAUC,WACjFyM,EAAkBV,IAExB,MAAO,CACHA,SAAUD,GAAsBW,EAChCX,qBACAY,UAJcD,GAAmBF,GAAazB,EAAOC,IAKrDwB,YAER,CAGkBI,IAEPzC,CACX,CAiJA,IAAI0C,EAAgB,CAChB,EAAAC,CAAGC,EAAQC,EAASC,GAChB,MAAMC,EAAO1M,KACb,IAAK0M,EAAKC,iBAAmBD,EAAKE,UAAW,OAAOF,EACpD,GAAuB,mBAAZF,EAAwB,OAAOE,EAC1C,MAAMG,EAASJ,EAAW,UAAY,OAKtC,OAJAF,EAAOpL,MAAM,KAAK/D,SAAQ0P,IACjBJ,EAAKC,gBAAgBG,KAAQJ,EAAKC,gBAAgBG,GAAS,IAChEJ,EAAKC,gBAAgBG,GAAOD,GAAQL,EAAQ,IAEzCE,CACX,EACA,IAAAK,CAAKR,EAAQC,EAASC,GAClB,MAAMC,EAAO1M,KACb,IAAK0M,EAAKC,iBAAmBD,EAAKE,UAAW,OAAOF,EACpD,GAAuB,mBAAZF,EAAwB,OAAOE,EAC1C,SAASM,IACLN,EAAKO,IAAIV,EAAQS,GACbA,EAAYE,uBACLF,EAAYE,eAEvB,IAAK,IAAIC,EAAO3J,UAAUlG,OAAQ8P,EAAO,IAAI1F,MAAMyF,GAAOE,EAAO,EAAGA,EAAOF,EAAME,IAC7ED,EAAKC,GAAQ7J,UAAU6J,GAE3Bb,EAAQc,MAAMZ,EAAMU,EACxB,CAEA,OADAJ,EAAYE,eAAiBV,EACtBE,EAAKJ,GAAGC,EAAQS,EAAaP,EACxC,EACA,KAAAc,CAAMf,EAASC,GACX,MAAMC,EAAO1M,KACb,IAAK0M,EAAKC,iBAAmBD,EAAKE,UAAW,OAAOF,EACpD,GAAuB,mBAAZF,EAAwB,OAAOE,EAC1C,MAAMG,EAASJ,EAAW,UAAY,OAItC,OAHIC,EAAKc,mBAAmBvJ,QAAQuI,GAAW,GAC3CE,EAAKc,mBAAmBX,GAAQL,GAE7BE,CACX,EACA,MAAAe,CAAOjB,GACH,MAAME,EAAO1M,KACb,IAAK0M,EAAKC,iBAAmBD,EAAKE,UAAW,OAAOF,EACpD,IAAKA,EAAKc,mBAAoB,OAAOd,EACrC,MAAMgB,EAAQhB,EAAKc,mBAAmBvJ,QAAQuI,GAI9C,OAHIkB,GAAS,GACThB,EAAKc,mBAAmBG,OAAOD,EAAO,GAEnChB,CACX,EACA,GAAAO,CAAIV,EAAQC,GACR,MAAME,EAAO1M,KACb,OAAK0M,EAAKC,iBAAmBD,EAAKE,UAAkBF,EAC/CA,EAAKC,iBACVJ,EAAOpL,MAAM,KAAK/D,SAAQ0P,SACC,IAAZN,EACPE,EAAKC,gBAAgBG,GAAS,GACvBJ,EAAKC,gBAAgBG,IAC5BJ,EAAKC,gBAAgBG,GAAO1P,SAAQ,CAACwQ,EAAcF,MAC3CE,IAAiBpB,GAAWoB,EAAaV,gBAAkBU,EAAaV,iBAAmBV,IAC3FE,EAAKC,gBAAgBG,GAAOa,OAAOD,EAAO,EAC9C,GAER,IAEGhB,GAZ2BA,CAatC,EACA,IAAAmB,GACI,MAAMnB,EAAO1M,KACb,IAAK0M,EAAKC,iBAAmBD,EAAKE,UAAW,OAAOF,EACpD,IAAKA,EAAKC,gBAAiB,OAAOD,EAClC,IAAIH,EACAuB,EACAC,EACJ,IAAK,IAAIC,EAAQxK,UAAUlG,OAAQ8P,EAAO,IAAI1F,MAAMsG,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IAClFb,EAAKa,GAASzK,UAAUyK,GAEL,iBAAZb,EAAK,IAAmB1F,MAAMC,QAAQyF,EAAK,KAClDb,EAASa,EAAK,GACdU,EAAOV,EAAK/J,MAAM,EAAG+J,EAAK9P,QAC1ByQ,EAAUrB,IAEVH,EAASa,EAAK,GAAGb,OACjBuB,EAAOV,EAAK,GAAGU,KACfC,EAAUX,EAAK,GAAGW,SAAWrB,GAEjCoB,EAAKI,QAAQH,GAcb,OAboBrG,MAAMC,QAAQ4E,GAAUA,EAASA,EAAOpL,MAAM,MACtD/D,SAAQ0P,IACZJ,EAAKc,oBAAsBd,EAAKc,mBAAmBlQ,QACnDoP,EAAKc,mBAAmBpQ,SAAQwQ,IAC5BA,EAAaN,MAAMS,EAAS,CAACjB,KAAUgB,GAAM,IAGjDpB,EAAKC,iBAAmBD,EAAKC,gBAAgBG,IAC7CJ,EAAKC,gBAAgBG,GAAO1P,SAAQwQ,IAChCA,EAAaN,MAAMS,EAASD,EAAK,GAEzC,IAEGpB,CACX,GA6WJ,MAAMyB,EAAuB,CAACvH,EAASwH,EAAWC,KAC1CD,IAAcxH,EAAQY,UAAU8G,SAASD,GACzCzH,EAAQY,UAAUC,IAAI4G,IACdD,GAAaxH,EAAQY,UAAU8G,SAASD,IAChDzH,EAAQY,UAAU+G,OAAOF,EAC7B,EA+GJ,MAAMG,EAAqB,CAAC5H,EAASwH,EAAWC,KACxCD,IAAcxH,EAAQY,UAAU8G,SAASD,GACzCzH,EAAQY,UAAUC,IAAI4G,IACdD,GAAaxH,EAAQY,UAAU8G,SAASD,IAChDzH,EAAQY,UAAU+G,OAAOF,EAC7B,EA2DJ,MAAMI,EAAuB,CAAC1J,EAAQ2J,KAClC,IAAK3J,GAAUA,EAAO6H,YAAc7H,EAAOQ,OAAQ,OACnD,MACMqB,EAAU8H,EAAQC,QADI5J,EAAO6J,UAAY,eAAiB,IAAI7J,EAAOQ,OAAOsJ,cAElF,GAAIjI,EAAS,CACT,IAAIkI,EAASlI,EAAQ9I,cAAc,IAAIiH,EAAOQ,OAAOwJ,uBAChDD,GAAU/J,EAAO6J,YACdhI,EAAQC,WACRiI,EAASlI,EAAQC,WAAW/I,cAAc,IAAIiH,EAAOQ,OAAOwJ,sBAG5DtO,uBAAsB,KACdmG,EAAQC,aACRiI,EAASlI,EAAQC,WAAW/I,cAAc,IAAIiH,EAAOQ,OAAOwJ,sBACxDD,GAAQA,EAAOP,SACvB,KAIRO,GAAQA,EAAOP,QACvB,GAEES,EAAS,CAACjK,EAAQ2I,KACpB,IAAK3I,EAAOkK,OAAOvB,GAAQ,OAC3B,MAAMgB,EAAU3J,EAAOkK,OAAOvB,GAAO5P,cAAc,oBAC/C4Q,GAASA,EAAQQ,gBAAgB,UAAU,EAE7CC,EAAUpK,IACZ,IAAKA,GAAUA,EAAO6H,YAAc7H,EAAOQ,OAAQ,OACnD,IAAI6J,EAASrK,EAAOQ,OAAO8J,oBAC3B,MAAMlL,EAAMY,EAAOkK,OAAO3R,OAC1B,IAAK6G,IAAQiL,GAAUA,EAAS,EAAG,OACnCA,EAASlJ,KAAKE,IAAIgJ,EAAQjL,GAC1B,MAAMmL,EAAgD,SAAhCvK,EAAOQ,OAAO+J,cAA2BvK,EAAOwK,uBAAyBrJ,KAAKsJ,KAAKzK,EAAOQ,OAAO+J,eACjHG,EAAc1K,EAAO0K,YAC3B,GAAI1K,EAAOQ,OAAOmK,MAAQ3K,EAAOQ,OAAOmK,KAAKC,KAAO,EAAG,CACnD,MAAMC,EAAeH,EACfI,EAAiB,CAACD,EAAeR,GASvC,OARAS,EAAe7G,QAAQtB,MAAMoI,KAAK,CAC9BxS,OAAQ8R,IACT/M,KAAI,CAAC0N,EAAGpM,IACAiM,EAAeN,EAAgB3L,UAE1CoB,EAAOkK,OAAO7R,SAAQ,CAACwJ,EAASjD,KACxBkM,EAAelE,SAAS/E,EAAQoJ,SAAShB,EAAOjK,EAAQpB,EAAE,GAGtE,CACA,MAAMsM,EAAuBR,EAAcH,EAAgB,EAC3D,GAAIvK,EAAOQ,OAAO2K,QAAUnL,EAAOQ,OAAO4K,KACtC,IAAK,IAAIxM,EAAI8L,EAAcL,EAAQzL,GAAKsM,EAAuBb,EAAQzL,GAAK,EAAG,CAC3E,MAAMyM,GAAazM,EAAIQ,EAAMA,GAAOA,GAChCiM,EAAYX,GAAeW,EAAYH,IAAsBjB,EAAOjK,EAAQqL,EACpF,MAEA,IAAK,IAAIzM,EAAIuC,KAAKC,IAAIsJ,EAAcL,EAAQ,GAAIzL,GAAKuC,KAAKE,IAAI6J,EAAuBb,EAAQjL,EAAM,GAAIR,GAAK,EACpGA,IAAM8L,IAAgB9L,EAAIsM,GAAwBtM,EAAI8L,IACtDT,EAAOjK,EAAQpB,EAG3B,EAyJJ,IAAI0M,EAAS,CACTC,WApvBJ,WACI,MAAMvL,EAAS/E,KACf,IAAI2K,EACAE,EACJ,MAAMnJ,EAAKqD,EAAOrD,GAEdiJ,OAD+B,IAAxB5F,EAAOQ,OAAOoF,OAAiD,OAAxB5F,EAAOQ,OAAOoF,MACpD5F,EAAOQ,OAAOoF,MAEdjJ,EAAG6O,YAGX1F,OADgC,IAAzB9F,EAAOQ,OAAOsF,QAAmD,OAAzB9F,EAAOQ,OAAOsF,OACpD9F,EAAOQ,OAAOsF,OAEdnJ,EAAG8O,aAEF,IAAV7F,GAAe5F,EAAO0L,gBAA6B,IAAX5F,GAAgB9F,EAAO2L,eAKnE/F,EAAQA,EAAQgG,SAASpI,EAAa7G,EAAI,iBAAmB,EAAG,IAAMiP,SAASpI,EAAa7G,EAAI,kBAAoB,EAAG,IACvHmJ,EAASA,EAAS8F,SAASpI,EAAa7G,EAAI,gBAAkB,EAAG,IAAMiP,SAASpI,EAAa7G,EAAI,mBAAqB,EAAG,IACrHqK,OAAO6E,MAAMjG,KAAQA,EAAQ,GAC7BoB,OAAO6E,MAAM/F,KAASA,EAAS,GACnC9N,OAAO8T,OAAO9L,EAAQ,CAClB4F,QACAE,SACAxB,KAAMtE,EAAO0L,eAAiB9F,EAAQE,IAE9C,EAwtBIiG,aAttBJ,WACI,MAAM/L,EAAS/E,KACf,SAAS+Q,EAA0BlN,EAAMmN,GACrC,OAAOjO,WAAWc,EAAK3D,iBAAiB6E,EAAOkM,kBAAkBD,KAAW,EAChF,CACA,MAAMzL,EAASR,EAAOQ,QAChBE,UACFA,EAASyL,SACTA,EACA7H,KAAM8H,EACNC,aAAcC,EAAGC,SACjBA,GACAvM,EACEwM,EAAYxM,EAAOyM,SAAWjM,EAAOiM,QAAQC,QAC7CC,EAAuBH,EAAYxM,EAAOyM,QAAQvC,OAAO3R,OAASyH,EAAOkK,OAAO3R,OAChF2R,EAASnI,EAAgBoK,EAAU,IAAInM,EAAOQ,OAAOsJ,4BACrD8C,EAAeJ,EAAYxM,EAAOyM,QAAQvC,OAAO3R,OAAS2R,EAAO3R,OACvE,IAAIsU,EAAW,GACf,MAAMC,EAAa,GACbC,EAAkB,GACxB,IAAIC,EAAexM,EAAOyM,mBACE,mBAAjBD,IACPA,EAAexM,EAAOyM,mBAAmB5O,KAAK2B,IAElD,IAAIkN,EAAc1M,EAAO2M,kBACE,mBAAhBD,IACPA,EAAc1M,EAAO2M,kBAAkB9O,KAAK2B,IAEhD,MAAMoN,EAAyBpN,EAAO6M,SAAStU,OACzC8U,EAA2BrN,EAAO8M,WAAWvU,OACnD,IAAI+U,EAAe9M,EAAO8M,aACtBC,GAAiBP,EACjBQ,EAAgB,EAChB7E,EAAQ,EACZ,QAA0B,IAAfyD,EACP,OAEwB,iBAAjBkB,GAA6BA,EAAapO,QAAQ,MAAQ,EACjEoO,EAAetP,WAAWsP,EAAa9P,QAAQ,IAAK,KAAO,IAAM4O,EAClC,iBAAjBkB,IACdA,EAAetP,WAAWsP,IAE9BtN,EAAOyN,aAAeH,EAGtBpD,EAAO7R,SAAQwJ,IACPyK,EACAzK,EAAQtI,MAAMmU,WAAa,GAE3B7L,EAAQtI,MAAMoU,YAAc,GAEhC9L,EAAQtI,MAAMqU,aAAe,GAC7B/L,EAAQtI,MAAMsU,UAAY,EAAE,IAI5BrN,EAAOsN,gBAAkBtN,EAAOuN,UAChCrO,EAAegB,EAAW,kCAAmC,IAC7DhB,EAAegB,EAAW,iCAAkC,KAEhE,MAAMsN,EAAcxN,EAAOmK,MAAQnK,EAAOmK,KAAKC,KAAO,GAAK5K,EAAO2K,KAQlE,IAAIsD,EAPAD,EACAhO,EAAO2K,KAAKuD,WAAWhE,GAChBlK,EAAO2K,MACd3K,EAAO2K,KAAKwD,cAKhB,MAAMC,EAAgD,SAAzB5N,EAAO+J,eAA4B/J,EAAO6N,aAAerW,OAAOI,KAAKoI,EAAO6N,aAAahS,QAAO/D,QACjE,IAA1CkI,EAAO6N,YAAY/V,GAAKiS,gBACvChS,OAAS,EACZ,IAAK,IAAIqG,EAAI,EAAGA,EAAIgO,EAAchO,GAAK,EAAG,CAEtC,IAAI0P,EAKJ,GANAL,EAAY,EAER/D,EAAOtL,KAAI0P,EAAQpE,EAAOtL,IAC1BoP,GACAhO,EAAO2K,KAAK4D,YAAY3P,EAAG0P,EAAOpE,IAElCA,EAAOtL,IAAyC,SAAnC4E,EAAa8K,EAAO,WAArC,CAEA,GAA6B,SAAzB9N,EAAO+J,cAA0B,CAC7B6D,IACAlE,EAAOtL,GAAGrF,MAAMyG,EAAOkM,kBAAkB,UAAY,IAEzD,MAAMsC,EAActT,iBAAiBoT,GAC/BG,EAAmBH,EAAM/U,MAAM6D,UAC/BsR,EAAyBJ,EAAM/U,MAAM8D,gBAO3C,GANIoR,IACAH,EAAM/U,MAAM6D,UAAY,QAExBsR,IACAJ,EAAM/U,MAAM8D,gBAAkB,QAE9BmD,EAAOmO,aACPV,EAAYjO,EAAO0L,eAAiBrH,EAAiBiK,EAAO,SAAS,GAAQjK,EAAiBiK,EAAO,UAAU,OAC5G,CAEH,MAAM1I,EAAQoG,EAA0BwC,EAAa,SAC/CI,EAAc5C,EAA0BwC,EAAa,gBACrDK,EAAe7C,EAA0BwC,EAAa,iBACtDd,EAAa1B,EAA0BwC,EAAa,eACpDb,EAAc3B,EAA0BwC,EAAa,gBACrDM,EAAYN,EAAYrT,iBAAiB,cAC/C,GAAI2T,GAA2B,eAAdA,EACbb,EAAYrI,EAAQ8H,EAAaC,MAC9B,CACH,MAAMnC,YACFA,EAAWhH,YACXA,GACA8J,EACJL,EAAYrI,EAAQgJ,EAAcC,EAAenB,EAAaC,GAAenJ,EAAcgH,EAC/F,CACJ,CACIiD,IACAH,EAAM/U,MAAM6D,UAAYqR,GAExBC,IACAJ,EAAM/U,MAAM8D,gBAAkBqR,GAE9BlO,EAAOmO,eAAcV,EAAY9M,KAAK4N,MAAMd,GACpD,MACIA,GAAa7B,GAAc5L,EAAO+J,cAAgB,GAAK+C,GAAgB9M,EAAO+J,cAC1E/J,EAAOmO,eAAcV,EAAY9M,KAAK4N,MAAMd,IAC5C/D,EAAOtL,KACPsL,EAAOtL,GAAGrF,MAAMyG,EAAOkM,kBAAkB,UAAY,GAAG+B,OAG5D/D,EAAOtL,KACPsL,EAAOtL,GAAGoQ,gBAAkBf,GAEhClB,EAAgB9I,KAAKgK,GACjBzN,EAAOsN,gBACPP,EAAgBA,EAAgBU,EAAY,EAAIT,EAAgB,EAAIF,EAC9C,IAAlBE,GAA6B,IAAN5O,IAAS2O,EAAgBA,EAAgBnB,EAAa,EAAIkB,GAC3E,IAAN1O,IAAS2O,EAAgBA,EAAgBnB,EAAa,EAAIkB,GAC1DnM,KAAK8N,IAAI1B,GAAiB,OAAUA,EAAgB,GACpD/M,EAAOmO,eAAcpB,EAAgBpM,KAAK4N,MAAMxB,IAChD5E,EAAQnI,EAAO0O,gBAAmB,GAAGrC,EAAS5I,KAAKsJ,GACvDT,EAAW7I,KAAKsJ,KAEZ/M,EAAOmO,eAAcpB,EAAgBpM,KAAK4N,MAAMxB,KAC/C5E,EAAQxH,KAAKE,IAAIrB,EAAOQ,OAAO2O,mBAAoBxG,IAAU3I,EAAOQ,OAAO0O,gBAAmB,GAAGrC,EAAS5I,KAAKsJ,GACpHT,EAAW7I,KAAKsJ,GAChBA,EAAgBA,EAAgBU,EAAYX,GAEhDtN,EAAOyN,aAAeQ,EAAYX,EAClCE,EAAgBS,EAChBtF,GAAS,CArE2D,CAsExE,CAaA,GAZA3I,EAAOyN,YAActM,KAAKC,IAAIpB,EAAOyN,YAAarB,GAAcc,EAC5DZ,GAAOC,IAA+B,UAAlB/L,EAAO4O,QAAwC,cAAlB5O,EAAO4O,UACxD1O,EAAUnH,MAAMqM,MAAQ,GAAG5F,EAAOyN,YAAcH,OAEhD9M,EAAO6O,iBACP3O,EAAUnH,MAAMyG,EAAOkM,kBAAkB,UAAY,GAAGlM,EAAOyN,YAAcH,OAE7EU,GACAhO,EAAO2K,KAAK2E,kBAAkBrB,EAAWpB,IAIxCrM,EAAOsN,eAAgB,CACxB,MAAMyB,EAAgB,GACtB,IAAK,IAAI3Q,EAAI,EAAGA,EAAIiO,EAAStU,OAAQqG,GAAK,EAAG,CACzC,IAAI4Q,EAAiB3C,EAASjO,GAC1B4B,EAAOmO,eAAca,EAAiBrO,KAAK4N,MAAMS,IACjD3C,EAASjO,IAAMoB,EAAOyN,YAAcrB,GACpCmD,EAActL,KAAKuL,EAE3B,CACA3C,EAAW0C,EACPpO,KAAK4N,MAAM/O,EAAOyN,YAAcrB,GAAcjL,KAAK4N,MAAMlC,EAASA,EAAStU,OAAS,IAAM,GAC1FsU,EAAS5I,KAAKjE,EAAOyN,YAAcrB,EAE3C,CACA,GAAII,GAAahM,EAAO4K,KAAM,CAC1B,MAAM9G,EAAOyI,EAAgB,GAAKO,EAClC,GAAI9M,EAAO0O,eAAiB,EAAG,CAC3B,MAAMO,EAAStO,KAAKsJ,MAAMzK,EAAOyM,QAAQiD,aAAe1P,EAAOyM,QAAQkD,aAAenP,EAAO0O,gBACvFU,EAAYtL,EAAO9D,EAAO0O,eAChC,IAAK,IAAItQ,EAAI,EAAGA,EAAI6Q,EAAQ7Q,GAAK,EAC7BiO,EAAS5I,KAAK4I,EAASA,EAAStU,OAAS,GAAKqX,EAEtD,CACA,IAAK,IAAIhR,EAAI,EAAGA,EAAIoB,EAAOyM,QAAQiD,aAAe1P,EAAOyM,QAAQkD,YAAa/Q,GAAK,EACjD,IAA1B4B,EAAO0O,gBACPrC,EAAS5I,KAAK4I,EAASA,EAAStU,OAAS,GAAK+L,GAElDwI,EAAW7I,KAAK6I,EAAWA,EAAWvU,OAAS,GAAK+L,GACpDtE,EAAOyN,aAAenJ,CAE9B,CAEA,GADwB,IAApBuI,EAAStU,SAAcsU,EAAW,CAAC,IAClB,IAAjBS,EAAoB,CACpB,MAAMhV,EAAM0H,EAAO0L,gBAAkBY,EAAM,aAAetM,EAAOkM,kBAAkB,eACnFhC,EAAO7N,QAAO,CAAC2O,EAAG6E,MACTrP,EAAOuN,UAAWvN,EAAO4K,OAC1ByE,IAAe3F,EAAO3R,OAAS,IAIpCF,SAAQwJ,IACPA,EAAQtI,MAAMjB,GAAO,GAAGgV,KAAgB,GAEhD,CACA,GAAI9M,EAAOsN,gBAAkBtN,EAAOsP,qBAAsB,CACtD,IAAIC,EAAgB,EACpBhD,EAAgB1U,SAAQ2X,IACpBD,GAAiBC,GAAkB1C,GAAgB,EAAE,IAEzDyC,GAAiBzC,EACjB,MAAM2C,EAAUF,EAAgB3D,EAChCS,EAAWA,EAASvP,KAAI4S,GAChBA,GAAQ,GAAWlD,EACnBkD,EAAOD,EAAgBA,EAAU/C,EAC9BgD,GAEf,CACA,GAAI1P,EAAO2P,yBAA0B,CACjC,IAAIJ,EAAgB,EACpBhD,EAAgB1U,SAAQ2X,IACpBD,GAAiBC,GAAkB1C,GAAgB,EAAE,IAEzDyC,GAAiBzC,EACjB,MAAM8C,GAAc5P,EAAOyM,oBAAsB,IAAMzM,EAAO2M,mBAAqB,GACnF,GAAI4C,EAAgBK,EAAahE,EAAY,CACzC,MAAMiE,GAAmBjE,EAAa2D,EAAgBK,GAAc,EACpEvD,EAASxU,SAAQ,CAAC6X,EAAMI,KACpBzD,EAASyD,GAAaJ,EAAOG,CAAe,IAEhDvD,EAAWzU,SAAQ,CAAC6X,EAAMI,KACtBxD,EAAWwD,GAAaJ,EAAOG,CAAe,GAEtD,CACJ,CAOA,GANArY,OAAO8T,OAAO9L,EAAQ,CAClBkK,SACA2C,WACAC,aACAC,oBAEAvM,EAAOsN,gBAAkBtN,EAAOuN,UAAYvN,EAAOsP,qBAAsB,CACzEpQ,EAAegB,EAAW,mCAAuCmM,EAAS,GAAb,MAC7DnN,EAAegB,EAAW,iCAAqCV,EAAOsE,KAAO,EAAIyI,EAAgBA,EAAgBxU,OAAS,GAAK,EAAnE,MAC5D,MAAMgY,GAAiBvQ,EAAO6M,SAAS,GACjC2D,GAAmBxQ,EAAO8M,WAAW,GAC3C9M,EAAO6M,SAAW7M,EAAO6M,SAASvP,KAAImT,GAAKA,EAAIF,IAC/CvQ,EAAO8M,WAAa9M,EAAO8M,WAAWxP,KAAImT,GAAKA,EAAID,GACvD,CAeA,GAdI5D,IAAiBD,GACjB3M,EAAO8I,KAAK,sBAEZ+D,EAAStU,SAAW6U,IAChBpN,EAAOQ,OAAOkQ,eAAe1Q,EAAO2Q,gBACxC3Q,EAAO8I,KAAK,yBAEZgE,EAAWvU,SAAW8U,GACtBrN,EAAO8I,KAAK,0BAEZtI,EAAOoQ,qBACP5Q,EAAO6Q,qBAEX7Q,EAAO8I,KAAK,mBACP0D,GAAchM,EAAOuN,SAA8B,UAAlBvN,EAAO4O,QAAwC,SAAlB5O,EAAO4O,QAAoB,CAC1F,MAAM0B,EAAsB,GAAGtQ,EAAOuQ,wCAChCC,EAA6BhR,EAAOrD,GAAG8F,UAAU8G,SAASuH,GAC5DlE,GAAgBpM,EAAOyQ,wBAClBD,GAA4BhR,EAAOrD,GAAG8F,UAAUC,IAAIoO,GAClDE,GACPhR,EAAOrD,GAAG8F,UAAU+G,OAAOsH,EAEnC,CACJ,EAscII,iBApcJ,SAA0BzQ,GACtB,MAAMT,EAAS/E,KACTkW,EAAe,GACf3E,EAAYxM,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAC1D,IACI9N,EADAwS,EAAY,EAEK,iBAAV3Q,EACPT,EAAOqR,cAAc5Q,IACJ,IAAVA,GACPT,EAAOqR,cAAcrR,EAAOQ,OAAOC,OAEvC,MAAM6Q,EAAkB3I,GAChB6D,EACOxM,EAAOkK,OAAOlK,EAAOuR,oBAAoB5I,IAE7C3I,EAAOkK,OAAOvB,GAGzB,GAAoC,SAAhC3I,EAAOQ,OAAO+J,eAA4BvK,EAAOQ,OAAO+J,cAAgB,EACxE,GAAIvK,EAAOQ,OAAOsN,gBACb9N,EAAOwR,eAAiB,IAAInZ,SAAQiW,IACjC6C,EAAalN,KAAKqK,EAAM,SAG5B,IAAK1P,EAAI,EAAGA,EAAIuC,KAAKsJ,KAAKzK,EAAOQ,OAAO+J,eAAgB3L,GAAK,EAAG,CAC5D,MAAM+J,EAAQ3I,EAAO0K,YAAc9L,EACnC,GAAI+J,EAAQ3I,EAAOkK,OAAO3R,SAAWiU,EAAW,MAChD2E,EAAalN,KAAKqN,EAAgB3I,GACtC,MAGJwI,EAAalN,KAAKqN,EAAgBtR,EAAO0K,cAI7C,IAAK9L,EAAI,EAAGA,EAAIuS,EAAa5Y,OAAQqG,GAAK,EACtC,QAA+B,IAApBuS,EAAavS,GAAoB,CACxC,MAAMkH,EAASqL,EAAavS,GAAG6S,aAC/BL,EAAYtL,EAASsL,EAAYtL,EAASsL,CAC9C,EAIAA,GAA2B,IAAdA,KAAiBpR,EAAOU,UAAUnH,MAAMuM,OAAS,GAAGsL,MACzE,EAyZIP,mBAvZJ,WACI,MAAM7Q,EAAS/E,KACTiP,EAASlK,EAAOkK,OAEhBwH,EAAc1R,EAAO6J,UAAY7J,EAAO0L,eAAiB1L,EAAOU,UAAUiR,WAAa3R,EAAOU,UAAUkR,UAAY,EAC1H,IAAK,IAAIhT,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EACpCsL,EAAOtL,GAAGiT,mBAAqB7R,EAAO0L,eAAiBxB,EAAOtL,GAAG+S,WAAazH,EAAOtL,GAAGgT,WAAaF,EAAc1R,EAAO8R,uBAElI,EAgZIC,qBAvYJ,SAA8B3R,QACR,IAAdA,IACAA,EAAYnF,MAAQA,KAAKmF,WAAa,GAE1C,MAAMJ,EAAS/E,KACTuF,EAASR,EAAOQ,QAChB0J,OACFA,EACAmC,aAAcC,EAAGO,SACjBA,GACA7M,EACJ,GAAsB,IAAlBkK,EAAO3R,OAAc,YACkB,IAAhC2R,EAAO,GAAG2H,mBAAmC7R,EAAO6Q,qBAC/D,IAAImB,GAAgB5R,EAChBkM,IAAK0F,EAAe5R,GACxBJ,EAAOiS,qBAAuB,GAC9BjS,EAAOwR,cAAgB,GACvB,IAAIlE,EAAe9M,EAAO8M,aACE,iBAAjBA,GAA6BA,EAAapO,QAAQ,MAAQ,EACjEoO,EAAetP,WAAWsP,EAAa9P,QAAQ,IAAK,KAAO,IAAMwC,EAAOsE,KACzC,iBAAjBgJ,IACdA,EAAetP,WAAWsP,IAE9B,IAAK,IAAI1O,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EAAG,CACvC,MAAM0P,EAAQpE,EAAOtL,GACrB,IAAIsT,EAAc5D,EAAMuD,kBACpBrR,EAAOuN,SAAWvN,EAAOsN,iBACzBoE,GAAehI,EAAO,GAAG2H,mBAE7B,MAAMM,GAAiBH,GAAgBxR,EAAOsN,eAAiB9N,EAAOoS,eAAiB,GAAKF,IAAgB5D,EAAMU,gBAAkB1B,GAC9H+E,GAAyBL,EAAenF,EAAS,IAAMrM,EAAOsN,eAAiB9N,EAAOoS,eAAiB,GAAKF,IAAgB5D,EAAMU,gBAAkB1B,GACpJgF,IAAgBN,EAAeE,GAC/BK,EAAaD,EAActS,EAAO+M,gBAAgBnO,GAClD4T,EAAiBF,GAAe,GAAKA,GAAetS,EAAOsE,KAAOtE,EAAO+M,gBAAgBnO,GACzF6T,EAAYH,GAAe,GAAKA,EAActS,EAAOsE,KAAO,GAAKiO,EAAa,GAAKA,GAAcvS,EAAOsE,MAAQgO,GAAe,GAAKC,GAAcvS,EAAOsE,KAC3JmO,IACAzS,EAAOwR,cAAcvN,KAAKqK,GAC1BtO,EAAOiS,qBAAqBhO,KAAKrF,IAErCwK,EAAqBkF,EAAOmE,EAAWjS,EAAOkS,mBAC9CtJ,EAAqBkF,EAAOkE,EAAgBhS,EAAOmS,wBACnDrE,EAAMpN,SAAWoL,GAAO6F,EAAgBA,EACxC7D,EAAMsE,iBAAmBtG,GAAO+F,EAAwBA,CAC5D,CACJ,EA4VIQ,eA1VJ,SAAwBzS,GACpB,MAAMJ,EAAS/E,KACf,QAAyB,IAAdmF,EAA2B,CAClC,MAAM0S,EAAa9S,EAAOqM,cAAgB,EAAI,EAE9CjM,EAAYJ,GAAUA,EAAOI,WAAaJ,EAAOI,UAAY0S,GAAc,CAC/E,CACA,MAAMtS,EAASR,EAAOQ,OAChBuS,EAAiB/S,EAAOgT,eAAiBhT,EAAOoS,eACtD,IAAIlR,SACAA,EAAQ+R,YACRA,EAAWC,MACXA,EAAKC,aACLA,GACAnT,EACJ,MAAMoT,EAAeH,EACfI,EAASH,EACf,GAAuB,IAAnBH,EACA7R,EAAW,EACX+R,GAAc,EACdC,GAAQ,MACL,CACHhS,GAAYd,EAAYJ,EAAOoS,gBAAkBW,EACjD,MAAMO,EAAqBnS,KAAK8N,IAAI7O,EAAYJ,EAAOoS,gBAAkB,EACnEmB,EAAepS,KAAK8N,IAAI7O,EAAYJ,EAAOgT,gBAAkB,EACnEC,EAAcK,GAAsBpS,GAAY,EAChDgS,EAAQK,GAAgBrS,GAAY,EAChCoS,IAAoBpS,EAAW,GAC/BqS,IAAcrS,EAAW,EACjC,CACA,GAAIV,EAAO4K,KAAM,CACb,MAAMoI,EAAkBxT,EAAOuR,oBAAoB,GAC7CkC,EAAiBzT,EAAOuR,oBAAoBvR,EAAOkK,OAAO3R,OAAS,GACnEmb,EAAsB1T,EAAO8M,WAAW0G,GACxCG,EAAqB3T,EAAO8M,WAAW2G,GACvCG,EAAe5T,EAAO8M,WAAW9M,EAAO8M,WAAWvU,OAAS,GAC5Dsb,EAAe1S,KAAK8N,IAAI7O,GAE1B+S,EADAU,GAAgBH,GACAG,EAAeH,GAAuBE,GAEtCC,EAAeD,EAAeD,GAAsBC,EAEpET,EAAe,IAAGA,GAAgB,EAC1C,CACAnb,OAAO8T,OAAO9L,EAAQ,CAClBkB,WACAiS,eACAF,cACAC,WAEA1S,EAAOoQ,qBAAuBpQ,EAAOsN,gBAAkBtN,EAAOsT,aAAY9T,EAAO+R,qBAAqB3R,GACtG6S,IAAgBG,GAChBpT,EAAO8I,KAAK,yBAEZoK,IAAUG,GACVrT,EAAO8I,KAAK,oBAEZsK,IAAiBH,GAAeI,IAAWH,IAC3ClT,EAAO8I,KAAK,YAEhB9I,EAAO8I,KAAK,WAAY5H,EAC5B,EA8RI6S,oBArRJ,WACI,MAAM/T,EAAS/E,MACTiP,OACFA,EAAM1J,OACNA,EAAM2L,SACNA,EAAQzB,YACRA,GACA1K,EACEwM,EAAYxM,EAAOyM,SAAWjM,EAAOiM,QAAQC,QAC7CsB,EAAchO,EAAO2K,MAAQnK,EAAOmK,MAAQnK,EAAOmK,KAAKC,KAAO,EAC/DoJ,EAAmB/R,GACdF,EAAgBoK,EAAU,IAAI3L,EAAOsJ,aAAa7H,kBAAyBA,KAAY,GAElG,IAAIgS,EACAC,EACAC,EACJ,GAAI3H,EACA,GAAIhM,EAAO4K,KAAM,CACb,IAAIyE,EAAanF,EAAc1K,EAAOyM,QAAQiD,aAC1CG,EAAa,IAAGA,EAAa7P,EAAOyM,QAAQvC,OAAO3R,OAASsX,GAC5DA,GAAc7P,EAAOyM,QAAQvC,OAAO3R,SAAQsX,GAAc7P,EAAOyM,QAAQvC,OAAO3R,QACpF0b,EAAcD,EAAiB,6BAA6BnE,MAChE,MACIoE,EAAcD,EAAiB,6BAA6BtJ,YAG5DsD,GACAiG,EAAc/J,EAAO7N,QAAOwF,GAAWA,EAAQoJ,SAAWP,IAAa,GACvEyJ,EAAYjK,EAAO7N,QAAOwF,GAAWA,EAAQoJ,SAAWP,EAAc,IAAG,GACzEwJ,EAAYhK,EAAO7N,QAAOwF,GAAWA,EAAQoJ,SAAWP,EAAc,IAAG,IAEzEuJ,EAAc/J,EAAOQ,GAGzBuJ,IACKjG,IAEDmG,EAp6BZ,SAAwBxX,EAAIsF,GACxB,MAAMmS,EAAU,GAChB,KAAOzX,EAAG0X,oBAAoB,CAC1B,MAAMC,EAAO3X,EAAG0X,mBACZpS,EACIqS,EAAKpS,QAAQD,IAAWmS,EAAQnQ,KAAKqQ,GACtCF,EAAQnQ,KAAKqQ,GACpB3X,EAAK2X,CACT,CACA,OAAOF,CACX,CA05BwBG,CAAeN,EAAa,IAAIzT,EAAOsJ,4BAA4B,GAC3EtJ,EAAO4K,OAAS+I,IAChBA,EAAYjK,EAAO,IAIvBgK,EAr7BZ,SAAwBvX,EAAIsF,GACxB,MAAMuS,EAAU,GAChB,KAAO7X,EAAG8X,wBAAwB,CAC9B,MAAMC,EAAO/X,EAAG8X,uBACZxS,EACIyS,EAAKxS,QAAQD,IAAWuS,EAAQvQ,KAAKyQ,GACtCF,EAAQvQ,KAAKyQ,GACpB/X,EAAK+X,CACT,CACA,OAAOF,CACX,CA26BwBG,CAAeV,EAAa,IAAIzT,EAAOsJ,4BAA4B,GAC3EtJ,EAAO4K,MAAuB,KAAd8I,IAChBA,EAAYhK,EAAOA,EAAO3R,OAAS,MAI/C2R,EAAO7R,SAAQwJ,IACX4H,EAAmB5H,EAASA,IAAYoS,EAAazT,EAAOoU,kBAC5DnL,EAAmB5H,EAASA,IAAYsS,EAAW3T,EAAOqU,gBAC1DpL,EAAmB5H,EAASA,IAAYqS,EAAW1T,EAAOsU,eAAe,IAE7E9U,EAAO+U,mBACX,EA+NIC,kBAtIJ,SAA2BC,GACvB,MAAMjV,EAAS/E,KACTmF,EAAYJ,EAAOqM,aAAerM,EAAOI,WAAaJ,EAAOI,WAC7DyM,SACFA,EAAQrM,OACRA,EACAkK,YAAawK,EACb7J,UAAW8J,EACX7E,UAAW8E,GACXpV,EACJ,IACIsQ,EADA5F,EAAcuK,EAElB,MAAMI,EAAsBC,IACxB,IAAIjK,EAAYiK,EAAStV,EAAOyM,QAAQiD,aAOxC,OANIrE,EAAY,IACZA,EAAYrL,EAAOyM,QAAQvC,OAAO3R,OAAS8S,GAE3CA,GAAarL,EAAOyM,QAAQvC,OAAO3R,SACnC8S,GAAarL,EAAOyM,QAAQvC,OAAO3R,QAEhC8S,CAAS,EAKpB,QAH2B,IAAhBX,IACPA,EA/CR,SAAmC1K,GAC/B,MAAM8M,WACFA,EAAUtM,OACVA,GACAR,EACEI,EAAYJ,EAAOqM,aAAerM,EAAOI,WAAaJ,EAAOI,UACnE,IAAIsK,EACJ,IAAK,IAAI9L,EAAI,EAAGA,EAAIkO,EAAWvU,OAAQqG,GAAK,OACP,IAAtBkO,EAAWlO,EAAI,GAClBwB,GAAa0M,EAAWlO,IAAMwB,EAAY0M,EAAWlO,EAAI,IAAMkO,EAAWlO,EAAI,GAAKkO,EAAWlO,IAAM,EACpG8L,EAAc9L,EACPwB,GAAa0M,EAAWlO,IAAMwB,EAAY0M,EAAWlO,EAAI,KAChE8L,EAAc9L,EAAI,GAEfwB,GAAa0M,EAAWlO,KAC/B8L,EAAc9L,GAOtB,OAHI4B,EAAO+U,sBACH7K,EAAc,QAA4B,IAAhBA,KAA6BA,EAAc,GAEtEA,CACX,CAwBsB8K,CAA0BxV,IAExC6M,EAAS3N,QAAQkB,IAAc,EAC/BkQ,EAAYzD,EAAS3N,QAAQkB,OAC1B,CACH,MAAMqV,EAAOtU,KAAKE,IAAIb,EAAO2O,mBAAoBzE,GACjD4F,EAAYmF,EAAOtU,KAAK4N,OAAOrE,EAAc+K,GAAQjV,EAAO0O,eAChE,CAEA,GADIoB,GAAazD,EAAStU,SAAQ+X,EAAYzD,EAAStU,OAAS,GAC5DmS,IAAgBwK,IAAkBlV,EAAOQ,OAAO4K,KAKhD,YAJIkF,IAAc8E,IACdpV,EAAOsQ,UAAYA,EACnBtQ,EAAO8I,KAAK,qBAIpB,GAAI4B,IAAgBwK,GAAiBlV,EAAOQ,OAAO4K,MAAQpL,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAE/F,YADA1M,EAAOqL,UAAYgK,EAAoB3K,IAG3C,MAAMsD,EAAchO,EAAO2K,MAAQnK,EAAOmK,MAAQnK,EAAOmK,KAAKC,KAAO,EAGrE,IAAIS,EACJ,GAAIrL,EAAOyM,SAAWjM,EAAOiM,QAAQC,SAAWlM,EAAO4K,KACnDC,EAAYgK,EAAoB3K,QAC7B,GAAIsD,EAAa,CACpB,MAAM0H,EAAqB1V,EAAOkK,OAAO7N,QAAOwF,GAAWA,EAAQoJ,SAAWP,IAAa,GAC3F,IAAIiL,EAAmB/J,SAAS8J,EAAmBE,aAAa,2BAA4B,IACxF5O,OAAO6E,MAAM8J,KACbA,EAAmBxU,KAAKC,IAAIpB,EAAOkK,OAAOhL,QAAQwW,GAAqB,IAE3ErK,EAAYlK,KAAK4N,MAAM4G,EAAmBnV,EAAOmK,KAAKC,KAC1D,MAAO,GAAI5K,EAAOkK,OAAOQ,GAAc,CACnC,MAAMmF,EAAa7P,EAAOkK,OAAOQ,GAAakL,aAAa,2BAEvDvK,EADAwE,EACYjE,SAASiE,EAAY,IAErBnF,CAEpB,MACIW,EAAYX,EAEhB1S,OAAO8T,OAAO9L,EAAQ,CAClBoV,oBACA9E,YACA6E,oBACA9J,YACA6J,gBACAxK,gBAEA1K,EAAO6V,aACPzL,EAAQpK,GAEZA,EAAO8I,KAAK,qBACZ9I,EAAO8I,KAAK,oBACR9I,EAAO6V,aAAe7V,EAAOQ,OAAOsV,sBAChCX,IAAsB9J,GACtBrL,EAAO8I,KAAK,mBAEhB9I,EAAO8I,KAAK,eAEpB,EAkDIiN,mBAhDJ,SAA4BpZ,EAAIqZ,GAC5B,MAAMhW,EAAS/E,KACTuF,EAASR,EAAOQ,OACtB,IAAI8N,EAAQ3R,EAAGiN,QAAQ,IAAIpJ,EAAOsJ,6BAC7BwE,GAAStO,EAAO6J,WAAamM,GAAQA,EAAKzd,OAAS,GAAKyd,EAAKpP,SAASjK,IACvE,IAAIqZ,EAAK1X,MAAM0X,EAAK9W,QAAQvC,GAAM,EAAGqZ,EAAKzd,SAASF,SAAQ4d,KAClD3H,GAAS2H,EAAO/T,SAAW+T,EAAO/T,QAAQ,IAAI1B,EAAOsJ,8BACtDwE,EAAQ2H,EACZ,IAGR,IACIpG,EADAqG,GAAa,EAEjB,GAAI5H,EACA,IAAK,IAAI1P,EAAI,EAAGA,EAAIoB,EAAOkK,OAAO3R,OAAQqG,GAAK,EAC3C,GAAIoB,EAAOkK,OAAOtL,KAAO0P,EAAO,CAC5B4H,GAAa,EACbrG,EAAajR,EACb,KACJ,CAGR,IAAI0P,IAAS4H,EAUT,OAFAlW,EAAOmW,kBAAezX,OACtBsB,EAAOoW,kBAAe1X,GARtBsB,EAAOmW,aAAe7H,EAClBtO,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QACxC1M,EAAOoW,aAAexK,SAAS0C,EAAMsH,aAAa,2BAA4B,IAE9E5V,EAAOoW,aAAevG,EAO1BrP,EAAO6V,0BAA+C3X,IAAxBsB,EAAOoW,cAA8BpW,EAAOoW,eAAiBpW,EAAO0K,aAClG1K,EAAOqW,qBAEf,GA+KA,IAAIjW,EAAY,CACZ1D,aAlKJ,SAA4BE,QACX,IAATA,IACAA,EAAO3B,KAAKyQ,eAAiB,IAAM,KAEvC,MACMlL,OACFA,EACA6L,aAAcC,EAAGlM,UACjBA,EAASM,UACTA,GALWzF,KAOf,GAAIuF,EAAO8V,iBACP,OAAOhK,GAAOlM,EAAYA,EAE9B,GAAII,EAAOuN,QACP,OAAO3N,EAEX,IAAImW,EAAmB7Z,EAAagE,EAAW9D,GAG/C,OAFA2Z,GAdetb,KAcY6W,wBACvBxF,IAAKiK,GAAoBA,GACtBA,GAAoB,CAC/B,EA8IIC,aA5IJ,SAAsBpW,EAAWqW,GAC7B,MAAMzW,EAAS/E,MAEXoR,aAAcC,EAAG9L,OACjBA,EAAME,UACNA,EAASQ,SACTA,GACAlB,EACJ,IA0BI0W,EA1BAC,EAAI,EACJC,EAAI,EAEJ5W,EAAO0L,eACPiL,EAAIrK,GAAOlM,EAAYA,EAEvBwW,EAAIxW,EAEJI,EAAOmO,eACPgI,EAAIxV,KAAK4N,MAAM4H,GACfC,EAAIzV,KAAK4N,MAAM6H,IAEnB5W,EAAO6W,kBAAoB7W,EAAOI,UAClCJ,EAAOI,UAAYJ,EAAO0L,eAAiBiL,EAAIC,EAC3CpW,EAAOuN,QACPrN,EAAUV,EAAO0L,eAAiB,aAAe,aAAe1L,EAAO0L,gBAAkBiL,GAAKC,EACtFpW,EAAO8V,mBACXtW,EAAO0L,eACPiL,GAAK3W,EAAO8R,wBAEZ8E,GAAK5W,EAAO8R,wBAEhBpR,EAAUnH,MAAM6D,UAAY,eAAeuZ,QAAQC,aAKvD,MAAM7D,EAAiB/S,EAAOgT,eAAiBhT,EAAOoS,eAElDsE,EADmB,IAAnB3D,EACc,GAEC3S,EAAYJ,EAAOoS,gBAAkBW,EAEpD2D,IAAgBxV,GAChBlB,EAAO6S,eAAezS,GAE1BJ,EAAO8I,KAAK,eAAgB9I,EAAOI,UAAWqW,EAClD,EAgGIrE,aA9FJ,WACI,OAAQnX,KAAK4R,SAAS,EAC1B,EA6FImG,aA3FJ,WACI,OAAQ/X,KAAK4R,SAAS5R,KAAK4R,SAAStU,OAAS,EACjD,EA0FIue,YAxFJ,SAAqB1W,EAAWK,EAAOsW,EAAcC,EAAiBC,QAChD,IAAd7W,IACAA,EAAY,QAEF,IAAVK,IACAA,EAAQxF,KAAKuF,OAAOC,YAEH,IAAjBsW,IACAA,GAAe,QAEK,IAApBC,IACAA,GAAkB,GAEtB,MAAMhX,EAAS/E,MACTuF,OACFA,EAAME,UACNA,GACAV,EACJ,GAAIA,EAAOkX,WAAa1W,EAAO2W,+BAC3B,OAAO,EAEX,MAAM/E,EAAepS,EAAOoS,eACtBY,EAAehT,EAAOgT,eAC5B,IAAIoE,EAKJ,GAJiDA,EAA7CJ,GAAmB5W,EAAYgS,EAA6BA,EAAsB4E,GAAmB5W,EAAY4S,EAA6BA,EAAiC5S,EAGnLJ,EAAO6S,eAAeuE,GAClB5W,EAAOuN,QAAS,CAChB,MAAMsJ,EAAMrX,EAAO0L,eACnB,GAAc,IAAVjL,EACAC,EAAU2W,EAAM,aAAe,cAAgBD,MAC5C,CACH,IAAKpX,EAAO0E,QAAQI,aAMhB,OALAhF,EAAqB,CACjBE,SACAC,gBAAiBmX,EACjBlX,KAAMmX,EAAM,OAAS,SAElB,EAEX3W,EAAUgB,SAAS,CACf,CAAC2V,EAAM,OAAS,QAASD,EACzBE,SAAU,UAElB,CACA,OAAO,CACX,CAiCA,OAhCc,IAAV7W,GACAT,EAAOqR,cAAc,GACrBrR,EAAOwW,aAAaY,GAChBL,IACA/W,EAAO8I,KAAK,wBAAyBrI,EAAOwW,GAC5CjX,EAAO8I,KAAK,oBAGhB9I,EAAOqR,cAAc5Q,GACrBT,EAAOwW,aAAaY,GAChBL,IACA/W,EAAO8I,KAAK,wBAAyBrI,EAAOwW,GAC5CjX,EAAO8I,KAAK,oBAEX9I,EAAOkX,YACRlX,EAAOkX,WAAY,EACdlX,EAAOuX,oCACRvX,EAAOuX,kCAAoC,SAAuBnT,GACzDpE,IAAUA,EAAO6H,WAClBzD,EAAElM,SAAW+C,OACjB+E,EAAOU,UAAU/H,oBAAoB,gBAAiBqH,EAAOuX,mCAC7DvX,EAAOuX,kCAAoC,YACpCvX,EAAOuX,kCACdvX,EAAOkX,WAAY,EACfH,GACA/W,EAAO8I,KAAK,iBAEpB,GAEJ9I,EAAOU,UAAUhI,iBAAiB,gBAAiBsH,EAAOuX,sCAG3D,CACX,GAmBA,SAASC,EAAezX,GACpB,IAAIC,OACAA,EAAM+W,aACNA,EAAYU,UACZA,EAASC,KACTA,GACA3X,EACJ,MAAM2K,YACFA,EAAWwK,cACXA,GACAlV,EACJ,IAAIa,EAAM4W,EAKV,GAJK5W,IACgCA,EAA7B6J,EAAcwK,EAAqB,OAAgBxK,EAAcwK,EAAqB,OAAkB,SAEhHlV,EAAO8I,KAAK,aAAa4O,KACrBX,GAAgBrM,IAAgBwK,EAAe,CAC/C,GAAY,UAARrU,EAEA,YADAb,EAAO8I,KAAK,uBAAuB4O,KAGvC1X,EAAO8I,KAAK,wBAAwB4O,KACxB,SAAR7W,EACAb,EAAO8I,KAAK,sBAAsB4O,KAElC1X,EAAO8I,KAAK,sBAAsB4O,IAE1C,CACJ,CAsdA,IAAIpJ,EAAQ,CACRqJ,QAxaJ,SAAiBhP,EAAOlI,EAAOsW,EAAcE,EAAUW,QACrC,IAAVjP,IACAA,EAAQ,QAES,IAAjBoO,IACAA,GAAe,GAEE,iBAAVpO,IACPA,EAAQiD,SAASjD,EAAO,KAE5B,MAAM3I,EAAS/E,KACf,IAAI4U,EAAalH,EACbkH,EAAa,IAAGA,EAAa,GACjC,MAAMrP,OACFA,EAAMqM,SACNA,EAAQC,WACRA,EAAUoI,cACVA,EAAaxK,YACbA,EACA2B,aAAcC,EAAG5L,UACjBA,EAASgM,QACTA,GACA1M,EACJ,IAAK0M,IAAYuK,IAAaW,GAAW5X,EAAO6H,WAAa7H,EAAOkX,WAAa1W,EAAO2W,+BACpF,OAAO,OAEU,IAAV1W,IACPA,EAAQT,EAAOQ,OAAOC,OAE1B,MAAMgV,EAAOtU,KAAKE,IAAIrB,EAAOQ,OAAO2O,mBAAoBU,GACxD,IAAIS,EAAYmF,EAAOtU,KAAK4N,OAAOc,EAAa4F,GAAQzV,EAAOQ,OAAO0O,gBAClEoB,GAAazD,EAAStU,SAAQ+X,EAAYzD,EAAStU,OAAS,GAChE,MAAM6H,GAAayM,EAASyD,GAE5B,GAAI9P,EAAO+U,oBACP,IAAK,IAAI3W,EAAI,EAAGA,EAAIkO,EAAWvU,OAAQqG,GAAK,EAAG,CAC3C,MAAMiZ,GAAuB1W,KAAK4N,MAAkB,IAAZ3O,GAClC0X,EAAiB3W,KAAK4N,MAAsB,IAAhBjC,EAAWlO,IACvCmZ,EAAqB5W,KAAK4N,MAA0B,IAApBjC,EAAWlO,EAAI,SACpB,IAAtBkO,EAAWlO,EAAI,GAClBiZ,GAAuBC,GAAkBD,EAAsBE,GAAsBA,EAAqBD,GAAkB,EAC5HjI,EAAajR,EACNiZ,GAAuBC,GAAkBD,EAAsBE,IACtElI,EAAajR,EAAI,GAEdiZ,GAAuBC,IAC9BjI,EAAajR,EAErB,CAGJ,GAAIoB,EAAO6V,aAAehG,IAAenF,EAAa,CAClD,IAAK1K,EAAOgY,iBAAmB1L,EAAMlM,EAAYJ,EAAOI,WAAaA,EAAYJ,EAAOoS,eAAiBhS,EAAYJ,EAAOI,WAAaA,EAAYJ,EAAOoS,gBACxJ,OAAO,EAEX,IAAKpS,EAAOiY,gBAAkB7X,EAAYJ,EAAOI,WAAaA,EAAYJ,EAAOgT,iBACxEtI,GAAe,KAAOmF,EACvB,OAAO,CAGnB,CAOA,IAAI4H,EAIJ,GAVI5H,KAAgBqF,GAAiB,IAAM6B,GACvC/W,EAAO8I,KAAK,0BAIhB9I,EAAO6S,eAAezS,GAEQqX,EAA1B5H,EAAanF,EAAyB,OAAgBmF,EAAanF,EAAyB,OAAwB,QAGpH4B,IAAQlM,IAAcJ,EAAOI,YAAckM,GAAOlM,IAAcJ,EAAOI,UAcvE,OAbAJ,EAAOgV,kBAAkBnF,GAErBrP,EAAOsT,YACP9T,EAAOkR,mBAEXlR,EAAO+T,sBACe,UAAlBvT,EAAO4O,QACPpP,EAAOwW,aAAapW,GAEN,UAAdqX,IACAzX,EAAOkY,gBAAgBnB,EAAcU,GACrCzX,EAAOmY,cAAcpB,EAAcU,KAEhC,EAEX,GAAIjX,EAAOuN,QAAS,CAChB,MAAMsJ,EAAMrX,EAAO0L,eACb0M,EAAI9L,EAAMlM,GAAaA,EAC7B,GAAc,IAAVK,EAAa,CACb,MAAM+L,EAAYxM,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QACtDF,IACAxM,EAAOU,UAAUnH,MAAMoH,eAAiB,OACxCX,EAAOqY,mBAAoB,GAE3B7L,IAAcxM,EAAOsY,2BAA6BtY,EAAOQ,OAAO+X,aAAe,GAC/EvY,EAAOsY,2BAA4B,EACnC5c,uBAAsB,KAClBgF,EAAU2W,EAAM,aAAe,aAAee,CAAC,KAGnD1X,EAAU2W,EAAM,aAAe,aAAee,EAE9C5L,GACA9Q,uBAAsB,KAClBsE,EAAOU,UAAUnH,MAAMoH,eAAiB,GACxCX,EAAOqY,mBAAoB,CAAK,GAG5C,KAAO,CACH,IAAKrY,EAAO0E,QAAQI,aAMhB,OALAhF,EAAqB,CACjBE,SACAC,eAAgBmY,EAChBlY,KAAMmX,EAAM,OAAS,SAElB,EAEX3W,EAAUgB,SAAS,CACf,CAAC2V,EAAM,OAAS,OAAQe,EACxBd,SAAU,UAElB,CACA,OAAO,CACX,CAuBA,OAtBAtX,EAAOqR,cAAc5Q,GACrBT,EAAOwW,aAAapW,GACpBJ,EAAOgV,kBAAkBnF,GACzB7P,EAAO+T,sBACP/T,EAAO8I,KAAK,wBAAyBrI,EAAOwW,GAC5CjX,EAAOkY,gBAAgBnB,EAAcU,GACvB,IAAVhX,EACAT,EAAOmY,cAAcpB,EAAcU,GAC3BzX,EAAOkX,YACflX,EAAOkX,WAAY,EACdlX,EAAOwY,gCACRxY,EAAOwY,8BAAgC,SAAuBpU,GACrDpE,IAAUA,EAAO6H,WAClBzD,EAAElM,SAAW+C,OACjB+E,EAAOU,UAAU/H,oBAAoB,gBAAiBqH,EAAOwY,+BAC7DxY,EAAOwY,8BAAgC,YAChCxY,EAAOwY,8BACdxY,EAAOmY,cAAcpB,EAAcU,GACvC,GAEJzX,EAAOU,UAAUhI,iBAAiB,gBAAiBsH,EAAOwY,iCAEvD,CACX,EAoRIC,YAlRJ,SAAqB9P,EAAOlI,EAAOsW,EAAcE,GAO7C,QANc,IAAVtO,IACAA,EAAQ,QAES,IAAjBoO,IACAA,GAAe,GAEE,iBAAVpO,EAAoB,CAE3BA,EADsBiD,SAASjD,EAAO,GAE1C,CACA,MAAM3I,EAAS/E,KACf,GAAI+E,EAAO6H,UAAW,YACD,IAAVpH,IACPA,EAAQT,EAAOQ,OAAOC,OAE1B,MAAMuN,EAAchO,EAAO2K,MAAQ3K,EAAOQ,OAAOmK,MAAQ3K,EAAOQ,OAAOmK,KAAKC,KAAO,EACnF,IAAI8N,EAAW/P,EACf,GAAI3I,EAAOQ,OAAO4K,KACd,GAAIpL,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAExCgM,GAAsB1Y,EAAOyM,QAAQiD,iBAClC,CACH,IAAIiJ,EACJ,GAAI3K,EAAa,CACb,MAAM6B,EAAa6I,EAAW1Y,EAAOQ,OAAOmK,KAAKC,KACjD+N,EAAmB3Y,EAAOkK,OAAO7N,QAAOwF,GAA6D,EAAlDA,EAAQ+T,aAAa,6BAAmC/F,IAAY,GAAG5E,MAC9H,MACI0N,EAAmB3Y,EAAOuR,oBAAoBmH,GAElD,MAAME,EAAO5K,EAAc7M,KAAKsJ,KAAKzK,EAAOkK,OAAO3R,OAASyH,EAAOQ,OAAOmK,KAAKC,MAAQ5K,EAAOkK,OAAO3R,QAC/FuV,eACFA,GACA9N,EAAOQ,OACX,IAAI+J,EAAgBvK,EAAOQ,OAAO+J,cACZ,SAAlBA,EACAA,EAAgBvK,EAAOwK,wBAEvBD,EAAgBpJ,KAAKsJ,KAAKzM,WAAWgC,EAAOQ,OAAO+J,cAAe,KAC9DuD,GAAkBvD,EAAgB,GAAM,IACxCA,GAAgC,IAGxC,IAAIsO,EAAcD,EAAOD,EAAmBpO,EAO5C,GANIuD,IACA+K,EAAcA,GAAeF,EAAmBxX,KAAKsJ,KAAKF,EAAgB,IAE1E0M,GAAYnJ,GAAkD,SAAhC9N,EAAOQ,OAAO+J,gBAA6ByD,IACzE6K,GAAc,GAEdA,EAAa,CACb,MAAMpB,EAAY3J,EAAiB6K,EAAmB3Y,EAAO0K,YAAc,OAAS,OAASiO,EAAmB3Y,EAAO0K,YAAc,EAAI1K,EAAOQ,OAAO+J,cAAgB,OAAS,OAChLvK,EAAO8Y,QAAQ,CACXrB,YACAE,SAAS,EACThC,iBAAgC,SAAd8B,EAAuBkB,EAAmB,EAAIA,EAAmBC,EAAO,EAC1FG,eAA8B,SAAdtB,EAAuBzX,EAAOqL,eAAY3M,GAElE,CACA,GAAIsP,EAAa,CACb,MAAM6B,EAAa6I,EAAW1Y,EAAOQ,OAAOmK,KAAKC,KACjD8N,EAAW1Y,EAAOkK,OAAO7N,QAAOwF,GAA6D,EAAlDA,EAAQ+T,aAAa,6BAAmC/F,IAAY,GAAG5E,MACtH,MACIyN,EAAW1Y,EAAOuR,oBAAoBmH,EAE9C,CAKJ,OAHAhd,uBAAsB,KAClBsE,EAAO2X,QAAQe,EAAUjY,EAAOsW,EAAcE,EAAS,IAEpDjX,CACX,EA4MIgZ,UAzMJ,SAAmBvY,EAAOsW,EAAcE,QACf,IAAjBF,IACAA,GAAe,GAEnB,MAAM/W,EAAS/E,MACTyR,QACFA,EAAOlM,OACPA,EAAM0W,UACNA,GACAlX,EACJ,IAAK0M,GAAW1M,EAAO6H,UAAW,OAAO7H,OACpB,IAAVS,IACPA,EAAQT,EAAOQ,OAAOC,OAE1B,IAAIwY,EAAWzY,EAAO0O,eACO,SAAzB1O,EAAO+J,eAAsD,IAA1B/J,EAAO0O,gBAAwB1O,EAAO0Y,qBACzED,EAAW9X,KAAKC,IAAIpB,EAAOwK,qBAAqB,WAAW,GAAO,IAEtE,MAAM2O,EAAYnZ,EAAO0K,YAAclK,EAAO2O,mBAAqB,EAAI8J,EACjEzM,EAAYxM,EAAOyM,SAAWjM,EAAOiM,QAAQC,QACnD,GAAIlM,EAAO4K,KAAM,CACb,GAAI8L,IAAc1K,GAAahM,EAAO4Y,oBAAqB,OAAO,EAMlE,GALApZ,EAAO8Y,QAAQ,CACXrB,UAAW,SAGfzX,EAAOqZ,YAAcrZ,EAAOU,UAAUuC,WAClCjD,EAAO0K,cAAgB1K,EAAOkK,OAAO3R,OAAS,GAAKiI,EAAOuN,QAI1D,OAHArS,uBAAsB,KAClBsE,EAAO2X,QAAQ3X,EAAO0K,YAAcyO,EAAW1Y,EAAOsW,EAAcE,EAAS,KAE1E,CAEf,CACA,OAAIzW,EAAO2K,QAAUnL,EAAOkT,MACjBlT,EAAO2X,QAAQ,EAAGlX,EAAOsW,EAAcE,GAE3CjX,EAAO2X,QAAQ3X,EAAO0K,YAAcyO,EAAW1Y,EAAOsW,EAAcE,EAC/E,EAoKIqC,UAjKJ,SAAmB7Y,EAAOsW,EAAcE,QACf,IAAjBF,IACAA,GAAe,GAEnB,MAAM/W,EAAS/E,MACTuF,OACFA,EAAMqM,SACNA,EAAQC,WACRA,EAAUT,aACVA,EAAYK,QACZA,EAAOwK,UACPA,GACAlX,EACJ,IAAK0M,GAAW1M,EAAO6H,UAAW,OAAO7H,OACpB,IAAVS,IACPA,EAAQT,EAAOQ,OAAOC,OAE1B,MAAM+L,EAAYxM,EAAOyM,SAAWjM,EAAOiM,QAAQC,QACnD,GAAIlM,EAAO4K,KAAM,CACb,GAAI8L,IAAc1K,GAAahM,EAAO4Y,oBAAqB,OAAO,EAClEpZ,EAAO8Y,QAAQ,CACXrB,UAAW,SAGfzX,EAAOqZ,YAAcrZ,EAAOU,UAAUuC,UAC1C,CAEA,SAASsW,EAAUC,GACf,OAAIA,EAAM,GAAWrY,KAAK4N,MAAM5N,KAAK8N,IAAIuK,IAClCrY,KAAK4N,MAAMyK,EACtB,CACA,MAAM3B,EAAsB0B,EALVlN,EAAerM,EAAOI,WAAaJ,EAAOI,WAMtDqZ,EAAqB5M,EAASvP,KAAIkc,GAAOD,EAAUC,KACzD,IAAIE,EAAW7M,EAAS4M,EAAmBva,QAAQ2Y,GAAuB,GAC1E,QAAwB,IAAb6B,GAA4BlZ,EAAOuN,QAAS,CACnD,IAAI4L,EACJ9M,EAASxU,SAAQ,CAAC6X,EAAMI,KAChBuH,GAAuB3H,IAEvByJ,EAAgBrJ,EACpB,SAEyB,IAAlBqJ,IACPD,EAAW7M,EAAS8M,EAAgB,EAAIA,EAAgB,EAAIA,GAEpE,CACA,IAAIC,EAAY,EAShB,QARwB,IAAbF,IACPE,EAAY9M,EAAW5N,QAAQwa,GAC3BE,EAAY,IAAGA,EAAY5Z,EAAO0K,YAAc,GACvB,SAAzBlK,EAAO+J,eAAsD,IAA1B/J,EAAO0O,gBAAwB1O,EAAO0Y,qBACzEU,EAAYA,EAAY5Z,EAAOwK,qBAAqB,YAAY,GAAQ,EACxEoP,EAAYzY,KAAKC,IAAIwY,EAAW,KAGpCpZ,EAAO2K,QAAUnL,EAAOiT,YAAa,CACrC,MAAM4G,EAAY7Z,EAAOQ,OAAOiM,SAAWzM,EAAOQ,OAAOiM,QAAQC,SAAW1M,EAAOyM,QAAUzM,EAAOyM,QAAQvC,OAAO3R,OAAS,EAAIyH,EAAOkK,OAAO3R,OAAS,EACvJ,OAAOyH,EAAO2X,QAAQkC,EAAWpZ,EAAOsW,EAAcE,EAC1D,CAAO,OAAIzW,EAAO4K,MAA+B,IAAvBpL,EAAO0K,aAAqBlK,EAAOuN,SACzDrS,uBAAsB,KAClBsE,EAAO2X,QAAQiC,EAAWnZ,EAAOsW,EAAcE,EAAS,KAErD,GAEJjX,EAAO2X,QAAQiC,EAAWnZ,EAAOsW,EAAcE,EAC1D,EAiGI6C,WA9FJ,SAAoBrZ,EAAOsW,EAAcE,QAChB,IAAjBF,IACAA,GAAe,GAEnB,MAAM/W,EAAS/E,KACf,IAAI+E,EAAO6H,UAIX,YAHqB,IAAVpH,IACPA,EAAQT,EAAOQ,OAAOC,OAEnBT,EAAO2X,QAAQ3X,EAAO0K,YAAajK,EAAOsW,EAAcE,EACnE,EAqFI8C,eAlFJ,SAAwBtZ,EAAOsW,EAAcE,EAAU+C,QAC9B,IAAjBjD,IACAA,GAAe,QAED,IAAdiD,IACAA,EAAY,IAEhB,MAAMha,EAAS/E,KACf,GAAI+E,EAAO6H,UAAW,YACD,IAAVpH,IACPA,EAAQT,EAAOQ,OAAOC,OAE1B,IAAIkI,EAAQ3I,EAAO0K,YACnB,MAAM+K,EAAOtU,KAAKE,IAAIrB,EAAOQ,OAAO2O,mBAAoBxG,GAClD2H,EAAYmF,EAAOtU,KAAK4N,OAAOpG,EAAQ8M,GAAQzV,EAAOQ,OAAO0O,gBAC7D9O,EAAYJ,EAAOqM,aAAerM,EAAOI,WAAaJ,EAAOI,UACnE,GAAIA,GAAaJ,EAAO6M,SAASyD,GAAY,CAGzC,MAAM2J,EAAcja,EAAO6M,SAASyD,GAEhClQ,EAAY6Z,GADCja,EAAO6M,SAASyD,EAAY,GACH2J,GAAeD,IACrDrR,GAAS3I,EAAOQ,OAAO0O,eAE/B,KAAO,CAGH,MAAMwK,EAAW1Z,EAAO6M,SAASyD,EAAY,GAEzClQ,EAAYsZ,IADI1Z,EAAO6M,SAASyD,GACOoJ,GAAYM,IACnDrR,GAAS3I,EAAOQ,OAAO0O,eAE/B,CAGA,OAFAvG,EAAQxH,KAAKC,IAAIuH,EAAO,GACxBA,EAAQxH,KAAKE,IAAIsH,EAAO3I,EAAO8M,WAAWvU,OAAS,GAC5CyH,EAAO2X,QAAQhP,EAAOlI,EAAOsW,EAAcE,EACtD,EA+CIZ,oBA7CJ,WACI,MAAMrW,EAAS/E,KACf,GAAI+E,EAAO6H,UAAW,OACtB,MAAMrH,OACFA,EAAM2L,SACNA,GACAnM,EACEuK,EAAyC,SAAzB/J,EAAO+J,cAA2BvK,EAAOwK,uBAAyBhK,EAAO+J,cAC/F,IACIc,EADA6O,EAAela,EAAOoW,aAE1B,MAAM+D,EAAgBna,EAAO6J,UAAY,eAAiB,IAAIrJ,EAAOsJ,aACrE,GAAItJ,EAAO4K,KAAM,CACb,GAAIpL,EAAOkX,UAAW,OACtB7L,EAAYO,SAAS5L,EAAOmW,aAAaP,aAAa,2BAA4B,IAC9EpV,EAAOsN,eACHoM,EAAela,EAAOoa,aAAe7P,EAAgB,GAAK2P,EAAela,EAAOkK,OAAO3R,OAASyH,EAAOoa,aAAe7P,EAAgB,GACtIvK,EAAO8Y,UACPoB,EAAela,EAAOqa,cAActY,EAAgBoK,EAAU,GAAGgO,8BAA0C9O,OAAe,IAC1H9O,GAAS,KACLyD,EAAO2X,QAAQuC,EAAa,KAGhCla,EAAO2X,QAAQuC,GAEZA,EAAela,EAAOkK,OAAO3R,OAASgS,GAC7CvK,EAAO8Y,UACPoB,EAAela,EAAOqa,cAActY,EAAgBoK,EAAU,GAAGgO,8BAA0C9O,OAAe,IAC1H9O,GAAS,KACLyD,EAAO2X,QAAQuC,EAAa,KAGhCla,EAAO2X,QAAQuC,EAEvB,MACIla,EAAO2X,QAAQuC,EAEvB,GAoSA,IAAI9O,EAAO,CACPkP,WAzRJ,SAAoBvB,GAChB,MAAM/Y,EAAS/E,MACTuF,OACFA,EAAM2L,SACNA,GACAnM,EACJ,IAAKQ,EAAO4K,MAAQpL,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAAS,OACrE,MAAMwB,EAAa,KACAnM,EAAgBoK,EAAU,IAAI3L,EAAOsJ,4BAC7CzR,SAAQ,CAACsE,EAAIgM,KAChBhM,EAAGnD,aAAa,0BAA2BmP,EAAM,GACnD,EAEAqF,EAAchO,EAAO2K,MAAQnK,EAAOmK,MAAQnK,EAAOmK,KAAKC,KAAO,EAC/DsE,EAAiB1O,EAAO0O,gBAAkBlB,EAAcxN,EAAOmK,KAAKC,KAAO,GAC3E2P,EAAkBva,EAAOkK,OAAO3R,OAAS2W,GAAmB,EAC5DsL,EAAiBxM,GAAehO,EAAOkK,OAAO3R,OAASiI,EAAOmK,KAAKC,MAAS,EAC5E6P,EAAiBC,IACnB,IAAK,IAAI9b,EAAI,EAAGA,EAAI8b,EAAgB9b,GAAK,EAAG,CACxC,MAAMiD,EAAU7B,EAAO6J,UAAYzQ,EAAc,eAAgB,CAACoH,EAAOma,kBAAoBvhB,EAAc,MAAO,CAACoH,EAAOsJ,WAAYtJ,EAAOma,kBAC7I3a,EAAOmM,SAASyO,OAAO/Y,EAC3B,GAEJ,GAAI0Y,EAAiB,CACjB,GAAI/Z,EAAOqa,mBAAoB,CAE3BJ,EADoBvL,EAAiBlP,EAAOkK,OAAO3R,OAAS2W,GAE5DlP,EAAO8a,eACP9a,EAAO+L,cACX,MACI5J,EAAY,mLAEhB+L,GACJ,MAAO,GAAIsM,EAAgB,CACvB,GAAIha,EAAOqa,mBAAoB,CAE3BJ,EADoBja,EAAOmK,KAAKC,KAAO5K,EAAOkK,OAAO3R,OAASiI,EAAOmK,KAAKC,MAE1E5K,EAAO8a,eACP9a,EAAO+L,cACX,MACI5J,EAAY,8KAEhB+L,GACJ,MACIA,IAEJlO,EAAO8Y,QAAQ,CACXC,iBACAtB,UAAWjX,EAAOsN,oBAAiBpP,EAAY,QAEvD,EAwOIoa,QAtOJ,SAAiBzT,GACb,IAAI0T,eACAA,EAAcpB,QACdA,GAAU,EAAIF,UACdA,EAASjB,aACTA,EAAYb,iBACZA,EAAgBc,aAChBA,EAAYsE,aACZA,QACU,IAAV1V,EAAmB,CAAC,EAAIA,EAC5B,MAAMrF,EAAS/E,KACf,IAAK+E,EAAOQ,OAAO4K,KAAM,OACzBpL,EAAO8I,KAAK,iBACZ,MAAMoB,OACFA,EAAM+N,eACNA,EAAcD,eACdA,EAAc7L,SACdA,EAAQ3L,OACRA,GACAR,GACE8N,eACFA,GACAtN,EAGJ,GAFAR,EAAOiY,gBAAiB,EACxBjY,EAAOgY,gBAAiB,EACpBhY,EAAOyM,SAAWjM,EAAOiM,QAAQC,QAajC,OAZIiL,IACKnX,EAAOsN,gBAAuC,IAArB9N,EAAOsQ,UAE1B9P,EAAOsN,gBAAkB9N,EAAOsQ,UAAY9P,EAAO+J,cAC1DvK,EAAO2X,QAAQ3X,EAAOyM,QAAQvC,OAAO3R,OAASyH,EAAOsQ,UAAW,GAAG,GAAO,GACnEtQ,EAAOsQ,YAActQ,EAAO6M,SAAStU,OAAS,GACrDyH,EAAO2X,QAAQ3X,EAAOyM,QAAQiD,aAAc,GAAG,GAAO,GAJtD1P,EAAO2X,QAAQ3X,EAAOyM,QAAQvC,OAAO3R,OAAQ,GAAG,GAAO,IAO/DyH,EAAOiY,eAAiBA,EACxBjY,EAAOgY,eAAiBA,OACxBhY,EAAO8I,KAAK,WAGhB,IAAIyB,EAAgB/J,EAAO+J,cACL,SAAlBA,EACAA,EAAgBvK,EAAOwK,wBAEvBD,EAAgBpJ,KAAKsJ,KAAKzM,WAAWwC,EAAO+J,cAAe,KACvDuD,GAAkBvD,EAAgB,GAAM,IACxCA,GAAgC,IAGxC,MAAM2E,EAAiB1O,EAAO0Y,mBAAqB3O,EAAgB/J,EAAO0O,eAC1E,IAAIkL,EAAelL,EACfkL,EAAelL,GAAmB,IAClCkL,GAAgBlL,EAAiBkL,EAAelL,GAEpDkL,GAAgB5Z,EAAOwa,qBACvBhb,EAAOoa,aAAeA,EACtB,MAAMpM,EAAchO,EAAO2K,MAAQnK,EAAOmK,MAAQnK,EAAOmK,KAAKC,KAAO,EACjEV,EAAO3R,OAASgS,EAAgB6P,EAChCjY,EAAY,6OACL6L,GAAoC,QAArBxN,EAAOmK,KAAKsQ,MAClC9Y,EAAY,2EAEhB,MAAM+Y,EAAuB,GACvBC,EAAsB,GAC5B,IAAIzQ,EAAc1K,EAAO0K,iBACO,IAArBiL,EACPA,EAAmB3V,EAAOqa,cAAcnQ,EAAO7N,QAAOM,GAAMA,EAAG8F,UAAU8G,SAAS/I,EAAOoU,oBAAmB,IAE5GlK,EAAciL,EAElB,MAAMyF,EAAuB,SAAd3D,IAAyBA,EAClC4D,EAAuB,SAAd5D,IAAyBA,EACxC,IAAI6D,EAAkB,EAClBC,EAAiB,EACrB,MAAM3C,EAAO5K,EAAc7M,KAAKsJ,KAAKP,EAAO3R,OAASiI,EAAOmK,KAAKC,MAAQV,EAAO3R,OAE1EijB,GADiBxN,EAAc9D,EAAOyL,GAAkB1K,OAAS0K,IACrB7H,QAA0C,IAAjB0I,GAAgCjM,EAAgB,EAAI,GAAM,GAErI,GAAIiR,EAA0BpB,EAAc,CACxCkB,EAAkBna,KAAKC,IAAIgZ,EAAeoB,EAAyBtM,GACnE,IAAK,IAAItQ,EAAI,EAAGA,EAAIwb,EAAeoB,EAAyB5c,GAAK,EAAG,CAChE,MAAM+J,EAAQ/J,EAAIuC,KAAK4N,MAAMnQ,EAAIga,GAAQA,EACzC,GAAI5K,EAAa,CACb,MAAMyN,EAAoB7C,EAAOjQ,EAAQ,EACzC,IAAK,IAAI/J,EAAIsL,EAAO3R,OAAS,EAAGqG,GAAK,EAAGA,GAAK,EACrCsL,EAAOtL,GAAGqM,SAAWwQ,GAAmBP,EAAqBjX,KAAKrF,EAK9E,MACIsc,EAAqBjX,KAAK2U,EAAOjQ,EAAQ,EAEjD,CACJ,MAAO,GAAI6S,EAA0BjR,EAAgBqO,EAAOwB,EAAc,CACtEmB,EAAiBpa,KAAKC,IAAIoa,GAA2B5C,EAAsB,EAAfwB,GAAmBlL,GAC/E,IAAK,IAAItQ,EAAI,EAAGA,EAAI2c,EAAgB3c,GAAK,EAAG,CACxC,MAAM+J,EAAQ/J,EAAIuC,KAAK4N,MAAMnQ,EAAIga,GAAQA,EACrC5K,EACA9D,EAAO7R,SAAQ,CAACiW,EAAOuB,KACfvB,EAAMrD,SAAWtC,GAAOwS,EAAoBlX,KAAK4L,EAAW,IAGpEsL,EAAoBlX,KAAK0E,EAEjC,CACJ,CA8BA,GA7BA3I,EAAO0b,qBAAsB,EAC7BhgB,uBAAsB,KAClBsE,EAAO0b,qBAAsB,CAAK,IAElCL,GACAH,EAAqB7iB,SAAQsQ,IACzBuB,EAAOvB,GAAOgT,mBAAoB,EAClCxP,EAASyP,QAAQ1R,EAAOvB,IACxBuB,EAAOvB,GAAOgT,mBAAoB,CAAK,IAG3CP,GACAD,EAAoB9iB,SAAQsQ,IACxBuB,EAAOvB,GAAOgT,mBAAoB,EAClCxP,EAASyO,OAAO1Q,EAAOvB,IACvBuB,EAAOvB,GAAOgT,mBAAoB,CAAK,IAG/C3b,EAAO8a,eACsB,SAAzBta,EAAO+J,cACPvK,EAAO+L,eACAiC,IAAgBkN,EAAqB3iB,OAAS,GAAK8iB,GAAUF,EAAoB5iB,OAAS,GAAK6iB,IACtGpb,EAAOkK,OAAO7R,SAAQ,CAACiW,EAAOuB,KAC1B7P,EAAO2K,KAAK4D,YAAYsB,EAAYvB,EAAOtO,EAAOkK,OAAO,IAG7D1J,EAAOoQ,qBACP5Q,EAAO6Q,qBAEP8G,EACA,GAAIuD,EAAqB3iB,OAAS,GAAK8iB,GACnC,QAA8B,IAAnBtC,EAAgC,CACvC,MAAM8C,EAAwB7b,EAAO8M,WAAWpC,GAE1CoR,EADoB9b,EAAO8M,WAAWpC,EAAc4Q,GACzBO,EAC7Bd,EACA/a,EAAOwW,aAAaxW,EAAOI,UAAY0b,IAEvC9b,EAAO2X,QAAQjN,EAAcvJ,KAAKsJ,KAAK6Q,GAAkB,GAAG,GAAO,GAC/D9E,IACAxW,EAAO+b,gBAAgBC,eAAiBhc,EAAO+b,gBAAgBC,eAAiBF,EAChF9b,EAAO+b,gBAAgBxF,iBAAmBvW,EAAO+b,gBAAgBxF,iBAAmBuF,GAGhG,MACI,GAAItF,EAAc,CACd,MAAMyF,EAAQjO,EAAckN,EAAqB3iB,OAASiI,EAAOmK,KAAKC,KAAOsQ,EAAqB3iB,OAClGyH,EAAO2X,QAAQ3X,EAAO0K,YAAcuR,EAAO,GAAG,GAAO,GACrDjc,EAAO+b,gBAAgBxF,iBAAmBvW,EAAOI,SACrD,OAED,GAAI+a,EAAoB5iB,OAAS,GAAK6iB,EACzC,QAA8B,IAAnBrC,EAAgC,CACvC,MAAM8C,EAAwB7b,EAAO8M,WAAWpC,GAE1CoR,EADoB9b,EAAO8M,WAAWpC,EAAc6Q,GACzBM,EAC7Bd,EACA/a,EAAOwW,aAAaxW,EAAOI,UAAY0b,IAEvC9b,EAAO2X,QAAQjN,EAAc6Q,EAAgB,GAAG,GAAO,GACnD/E,IACAxW,EAAO+b,gBAAgBC,eAAiBhc,EAAO+b,gBAAgBC,eAAiBF,EAChF9b,EAAO+b,gBAAgBxF,iBAAmBvW,EAAO+b,gBAAgBxF,iBAAmBuF,GAGhG,KAAO,CACH,MAAMG,EAAQjO,EAAcmN,EAAoB5iB,OAASiI,EAAOmK,KAAKC,KAAOuQ,EAAoB5iB,OAChGyH,EAAO2X,QAAQ3X,EAAO0K,YAAcuR,EAAO,GAAG,GAAO,EACzD,CAKR,GAFAjc,EAAOiY,eAAiBA,EACxBjY,EAAOgY,eAAiBA,EACpBhY,EAAOkc,YAAclc,EAAOkc,WAAWC,UAAY1F,EAAc,CACjE,MAAM2F,EAAa,CACfrD,iBACAtB,YACAjB,eACAb,mBACAc,cAAc,GAEd9T,MAAMC,QAAQ5C,EAAOkc,WAAWC,SAChCnc,EAAOkc,WAAWC,QAAQ9jB,SAAQiE,KACzBA,EAAEuL,WAAavL,EAAEkE,OAAO4K,MAAM9O,EAAEwc,QAAQ,IACtCsD,EACHzE,QAASrb,EAAEkE,OAAO+J,gBAAkB/J,EAAO+J,eAAgBoN,GAC7D,IAEC3X,EAAOkc,WAAWC,mBAAmBnc,EAAOjI,aAAeiI,EAAOkc,WAAWC,QAAQ3b,OAAO4K,MACnGpL,EAAOkc,WAAWC,QAAQrD,QAAQ,IAC3BsD,EACHzE,QAAS3X,EAAOkc,WAAWC,QAAQ3b,OAAO+J,gBAAkB/J,EAAO+J,eAAgBoN,GAG/F,CACA3X,EAAO8I,KAAK,UAChB,EA4BIuT,YA1BJ,WACI,MAAMrc,EAAS/E,MACTuF,OACFA,EAAM2L,SACNA,GACAnM,EACJ,IAAKQ,EAAO4K,MAAQpL,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAAS,OACrE1M,EAAO8a,eACP,MAAMwB,EAAiB,GACvBtc,EAAOkK,OAAO7R,SAAQwJ,IAClB,MAAM8G,OAA4C,IAA7B9G,EAAQ0a,iBAAqF,EAAlD1a,EAAQ+T,aAAa,2BAAiC/T,EAAQ0a,iBAC9HD,EAAe3T,GAAS9G,CAAO,IAEnC7B,EAAOkK,OAAO7R,SAAQwJ,IAClBA,EAAQsI,gBAAgB,0BAA0B,IAEtDmS,EAAejkB,SAAQwJ,IACnBsK,EAASyO,OAAO/Y,EAAQ,IAE5B7B,EAAO8a,eACP9a,EAAO2X,QAAQ3X,EAAOqL,UAAW,EACrC,GA6DA,SAASmR,EAAiBxc,EAAQ+H,EAAO0U,GACrC,MAAMzgB,EAASF,KACT0E,OACFA,GACAR,EACE0c,EAAqBlc,EAAOkc,mBAC5BC,EAAqBnc,EAAOmc,mBAClC,OAAID,KAAuBD,GAAUE,GAAsBF,GAAUzgB,EAAO4gB,WAAaD,IAC1D,YAAvBD,IACA3U,EAAM8U,kBACC,EAKnB,CACA,SAASC,EAAa/U,GAClB,MAAM/H,EAAS/E,KACTV,EAAWF,IACjB,IAAI+J,EAAI2D,EACJ3D,EAAE2Y,gBAAe3Y,EAAIA,EAAE2Y,eAC3B,MAAMhU,EAAO/I,EAAO+b,gBACpB,GAAe,gBAAX3X,EAAE4Y,KAAwB,CAC1B,GAAuB,OAAnBjU,EAAKkU,WAAsBlU,EAAKkU,YAAc7Y,EAAE6Y,UAChD,OAEJlU,EAAKkU,UAAY7Y,EAAE6Y,SACvB,KAAsB,eAAX7Y,EAAE4Y,MAAoD,IAA3B5Y,EAAE8Y,cAAc3kB,SAClDwQ,EAAKoU,QAAU/Y,EAAE8Y,cAAc,GAAGE,YAEtC,GAAe,eAAXhZ,EAAE4Y,KAGF,YADAR,EAAiBxc,EAAQoE,EAAGA,EAAE8Y,cAAc,GAAGG,OAGnD,MAAM7c,OACFA,EAAM8c,QACNA,EAAO5Q,QACPA,GACA1M,EACJ,IAAK0M,EAAS,OACd,IAAKlM,EAAO+c,eAAmC,UAAlBnZ,EAAEoZ,YAAyB,OACxD,GAAIxd,EAAOkX,WAAa1W,EAAO2W,+BAC3B,QAECnX,EAAOkX,WAAa1W,EAAOuN,SAAWvN,EAAO4K,MAC9CpL,EAAO8Y,UAEX,IAAI2E,EAAWrZ,EAAElM,OACjB,GAAiC,YAA7BsI,EAAOkd,oBACF1d,EAAOU,UAAU6I,SAASkU,GAAW,OAE9C,GAAI,UAAWrZ,GAAiB,IAAZA,EAAEuZ,MAAa,OACnC,GAAI,WAAYvZ,GAAKA,EAAEwZ,OAAS,EAAG,OACnC,GAAI7U,EAAK8U,WAAa9U,EAAK+U,QAAS,OAGpC,MAAMC,IAAyBvd,EAAOwd,gBAA4C,KAA1Bxd,EAAOwd,eAEzDC,EAAY7Z,EAAE8Z,aAAe9Z,EAAE8Z,eAAiB9Z,EAAE4R,KACpD+H,GAAwB3Z,EAAElM,QAAUkM,EAAElM,OAAO4J,YAAcmc,IAC3DR,EAAWQ,EAAU,IAEzB,MAAME,EAAoB3d,EAAO2d,kBAAoB3d,EAAO2d,kBAAoB,IAAI3d,EAAOwd,iBACrFI,KAAoBha,EAAElM,SAAUkM,EAAElM,OAAO4J,YAG/C,GAAItB,EAAO6d,YAAcD,EAlF7B,SAAwBnc,EAAUqc,GAa9B,YAZa,IAATA,IACAA,EAAOrjB,MAEX,SAASsjB,EAAc5hB,GACnB,IAAKA,GAAMA,IAAOtC,KAAiBsC,IAAOb,IAAa,OAAO,KAC1Da,EAAG6hB,eAAc7hB,EAAKA,EAAG6hB,cAC7B,MAAMC,EAAQ9hB,EAAGiN,QAAQ3H,GACzB,OAAKwc,GAAU9hB,EAAG+hB,YAGXD,GAASF,EAAc5hB,EAAG+hB,cAAc5kB,MAFpC,IAGf,CACOykB,CAAcD,EACzB,CAoE8CK,CAAeR,EAAmBV,GAAYA,EAAS7T,QAAQuU,IAErG,YADAne,EAAO4e,YAAa,GAGxB,GAAIpe,EAAOqe,eACFpB,EAAS7T,QAAQpJ,EAAOqe,cAAe,OAEhDvB,EAAQwB,SAAW1a,EAAEiZ,MACrBC,EAAQyB,SAAW3a,EAAE4a,MACrB,MAAMvC,EAASa,EAAQwB,SACjBG,EAAS3B,EAAQyB,SAIvB,IAAKvC,EAAiBxc,EAAQoE,EAAGqY,GAC7B,OAEJzkB,OAAO8T,OAAO/C,EAAM,CAChB8U,WAAW,EACXC,SAAS,EACToB,qBAAqB,EACrBC,iBAAazgB,EACb0gB,iBAAa1gB,IAEjB4e,EAAQb,OAASA,EACjBa,EAAQ2B,OAASA,EACjBlW,EAAKsW,eAAiB5iB,IACtBuD,EAAO4e,YAAa,EACpB5e,EAAOuL,aACPvL,EAAOsf,oBAAiB5gB,EACpB8B,EAAOwZ,UAAY,IAAGjR,EAAKwW,oBAAqB,GACpD,IAAI1C,GAAiB,EACjBY,EAASvb,QAAQ6G,EAAKyW,qBACtB3C,GAAiB,EACS,WAAtBY,EAAS3kB,WACTiQ,EAAK8U,WAAY,IAGrBtjB,EAAS3B,eAAiB2B,EAAS3B,cAAcsJ,QAAQ6G,EAAKyW,oBAAsBjlB,EAAS3B,gBAAkB6kB,GAC/GljB,EAAS3B,cAAcC,OAE3B,MAAM4mB,EAAuB5C,GAAkB7c,EAAO0f,gBAAkBlf,EAAOmf,0BAC1Enf,EAAOof,gCAAiCH,GAA0BhC,EAASoC,mBAC5Ezb,EAAEyY,iBAEFrc,EAAOsf,UAAYtf,EAAOsf,SAASpT,SAAW1M,EAAO8f,UAAY9f,EAAOkX,YAAc1W,EAAOuN,SAC7F/N,EAAO8f,SAAShD,eAEpB9c,EAAO8I,KAAK,aAAc1E,EAC9B,CAEA,SAAS2b,EAAYhY,GACjB,MAAMxN,EAAWF,IACX2F,EAAS/E,KACT8N,EAAO/I,EAAO+b,iBACdvb,OACFA,EAAM8c,QACNA,EACAjR,aAAcC,EAAGI,QACjBA,GACA1M,EACJ,IAAK0M,EAAS,OACd,IAAKlM,EAAO+c,eAAuC,UAAtBxV,EAAMyV,YAAyB,OAC5D,IAOIwC,EAPA5b,EAAI2D,EAER,GADI3D,EAAE2Y,gBAAe3Y,EAAIA,EAAE2Y,eACZ,gBAAX3Y,EAAE4Y,KAAwB,CAC1B,GAAqB,OAAjBjU,EAAKoU,QAAkB,OAE3B,GADW/Y,EAAE6Y,YACFlU,EAAKkU,UAAW,MAC/B,CAEA,GAAe,cAAX7Y,EAAE4Y,MAEF,GADAgD,EAAc,IAAI5b,EAAE6b,gBAAgB5jB,QAAO+b,GAAKA,EAAEgF,aAAerU,EAAKoU,UAAS,IAC1E6C,GAAeA,EAAY5C,aAAerU,EAAKoU,QAAS,YAE7D6C,EAAc5b,EAElB,IAAK2E,EAAK8U,UAIN,YAHI9U,EAAKqW,aAAerW,EAAKoW,aACzBnf,EAAO8I,KAAK,oBAAqB1E,IAIzC,MAAMiZ,EAAQ2C,EAAY3C,MACpB2B,EAAQgB,EAAYhB,MAC1B,GAAI5a,EAAE8b,wBAGF,OAFA5C,EAAQb,OAASY,OACjBC,EAAQ2B,OAASD,GAGrB,IAAKhf,EAAO0f,eAaR,OAZKtb,EAAElM,OAAOgK,QAAQ6G,EAAKyW,qBACvBxf,EAAO4e,YAAa,QAEpB7V,EAAK8U,YACL7lB,OAAO8T,OAAOwR,EAAS,CACnBb,OAAQY,EACR4B,OAAQD,EACRF,SAAUzB,EACV0B,SAAUC,IAEdjW,EAAKsW,eAAiB5iB,MAI9B,GAAI+D,EAAO2f,sBAAwB3f,EAAO4K,KACtC,GAAIpL,EAAO2L,cAEP,GAAIqT,EAAQ1B,EAAQ2B,QAAUjf,EAAOI,WAAaJ,EAAOgT,gBAAkBgM,EAAQ1B,EAAQ2B,QAAUjf,EAAOI,WAAaJ,EAAOoS,eAG5H,OAFArJ,EAAK8U,WAAY,OACjB9U,EAAK+U,SAAU,QAGhB,GAAIT,EAAQC,EAAQb,QAAUzc,EAAOI,WAAaJ,EAAOgT,gBAAkBqK,EAAQC,EAAQb,QAAUzc,EAAOI,WAAaJ,EAAOoS,eACnI,OAGR,GAAI7X,EAAS3B,eACLwL,EAAElM,SAAWqC,EAAS3B,eAAiBwL,EAAElM,OAAOgK,QAAQ6G,EAAKyW,mBAG7D,OAFAzW,EAAK+U,SAAU,OACf9d,EAAO4e,YAAa,GAIxB7V,EAAKmW,qBACLlf,EAAO8I,KAAK,YAAa1E,GAE7BkZ,EAAQ8C,UAAY9C,EAAQwB,SAC5BxB,EAAQ+C,UAAY/C,EAAQyB,SAC5BzB,EAAQwB,SAAWzB,EACnBC,EAAQyB,SAAWC,EACnB,MAAMsB,EAAQhD,EAAQwB,SAAWxB,EAAQb,OACnC8D,EAAQjD,EAAQyB,SAAWzB,EAAQ2B,OACzC,GAAIjf,EAAOQ,OAAOwZ,WAAa7Y,KAAKqf,KAAKF,GAAS,EAAIC,GAAS,GAAKvgB,EAAOQ,OAAOwZ,UAAW,OAC7F,QAAgC,IAArBjR,EAAKoW,YAA6B,CACzC,IAAIsB,EACAzgB,EAAO0L,gBAAkB4R,EAAQyB,WAAazB,EAAQ2B,QAAUjf,EAAO2L,cAAgB2R,EAAQwB,WAAaxB,EAAQb,OACpH1T,EAAKoW,aAAc,EAGfmB,EAAQA,EAAQC,EAAQA,GAAS,KACjCE,EAA4D,IAA/Ctf,KAAKuf,MAAMvf,KAAK8N,IAAIsR,GAAQpf,KAAK8N,IAAIqR,IAAgBnf,KAAKK,GACvEuH,EAAKoW,YAAcnf,EAAO0L,eAAiB+U,EAAajgB,EAAOigB,WAAa,GAAKA,EAAajgB,EAAOigB,WAGjH,CASA,GARI1X,EAAKoW,aACLnf,EAAO8I,KAAK,oBAAqB1E,QAEL,IAArB2E,EAAKqW,cACR9B,EAAQwB,WAAaxB,EAAQb,QAAUa,EAAQyB,WAAazB,EAAQ2B,SACpElW,EAAKqW,aAAc,IAGvBrW,EAAKoW,aAA0B,cAAX/a,EAAE4Y,MAAwBjU,EAAK4X,gCAEnD,YADA5X,EAAK8U,WAAY,GAGrB,IAAK9U,EAAKqW,YACN,OAEJpf,EAAO4e,YAAa,GACfpe,EAAOuN,SAAW3J,EAAEwc,YACrBxc,EAAEyY,iBAEFrc,EAAOqgB,2BAA6BrgB,EAAOsgB,QAC3C1c,EAAE2c,kBAEN,IAAIjF,EAAO9b,EAAO0L,eAAiB4U,EAAQC,EACvCS,EAAchhB,EAAO0L,eAAiB4R,EAAQwB,SAAWxB,EAAQ8C,UAAY9C,EAAQyB,SAAWzB,EAAQ+C,UACxG7f,EAAOygB,iBACPnF,EAAO3a,KAAK8N,IAAI6M,IAASxP,EAAM,GAAK,GACpC0U,EAAc7f,KAAK8N,IAAI+R,IAAgB1U,EAAM,GAAK,IAEtDgR,EAAQxB,KAAOA,EACfA,GAAQtb,EAAO0gB,WACX5U,IACAwP,GAAQA,EACRkF,GAAeA,GAEnB,MAAMG,EAAuBnhB,EAAOohB,iBACpCphB,EAAOsf,eAAiBxD,EAAO,EAAI,OAAS,OAC5C9b,EAAOohB,iBAAmBJ,EAAc,EAAI,OAAS,OACrD,MAAMK,EAASrhB,EAAOQ,OAAO4K,OAAS5K,EAAOuN,QACvCuT,EAA2C,SAA5BthB,EAAOohB,kBAA+BphB,EAAOgY,gBAA8C,SAA5BhY,EAAOohB,kBAA+BphB,EAAOiY,eACjI,IAAKlP,EAAK+U,QAAS,CAQf,GAPIuD,GAAUC,GACVthB,EAAO8Y,QAAQ,CACXrB,UAAWzX,EAAOsf,iBAG1BvW,EAAKiT,eAAiBhc,EAAOtD,eAC7BsD,EAAOqR,cAAc,GACjBrR,EAAOkX,UAAW,CAClB,MAAMqK,EAAM,IAAIvlB,OAAOhB,YAAY,gBAAiB,CAChDwmB,SAAS,EACTZ,YAAY,EACZa,OAAQ,CACJC,mBAAmB,KAG3B1hB,EAAOU,UAAUihB,cAAcJ,EACnC,CACAxY,EAAK6Y,qBAAsB,GAEvBphB,EAAOqhB,aAAyC,IAA1B7hB,EAAOgY,iBAAqD,IAA1BhY,EAAOiY,gBAC/DjY,EAAO8hB,eAAc,GAEzB9hB,EAAO8I,KAAK,kBAAmB1E,EACnC,CAGA,IADA,IAAI/I,MAAO4F,UACP8H,EAAK+U,SAAW/U,EAAKwW,oBAAsB4B,IAAyBnhB,EAAOohB,kBAAoBC,GAAUC,GAAgBngB,KAAK8N,IAAI6M,IAAS,EAU3I,OATA9jB,OAAO8T,OAAOwR,EAAS,CACnBb,OAAQY,EACR4B,OAAQD,EACRF,SAAUzB,EACV0B,SAAUC,EACVhD,eAAgBjT,EAAKwN,mBAEzBxN,EAAKgZ,eAAgB,OACrBhZ,EAAKiT,eAAiBjT,EAAKwN,kBAG/BvW,EAAO8I,KAAK,aAAc1E,GAC1B2E,EAAK+U,SAAU,EACf/U,EAAKwN,iBAAmBuF,EAAO/S,EAAKiT,eACpC,IAAIgG,GAAsB,EACtBC,EAAkBzhB,EAAOyhB,gBAiD7B,GAhDIzhB,EAAO2f,sBACP8B,EAAkB,GAElBnG,EAAO,GACHuF,GAAUC,GAA8BvY,EAAKwW,oBAAsBxW,EAAKwN,kBAAoB/V,EAAOsN,eAAiB9N,EAAOoS,eAAiBpS,EAAO+M,gBAAgB/M,EAAO0K,YAAc,GAAK1K,EAAOoS,iBACpMpS,EAAO8Y,QAAQ,CACXrB,UAAW,OACXjB,cAAc,EACdb,iBAAkB,IAGtB5M,EAAKwN,iBAAmBvW,EAAOoS,iBAC/B4P,GAAsB,EAClBxhB,EAAO0hB,aACPnZ,EAAKwN,iBAAmBvW,EAAOoS,eAAiB,IAAMpS,EAAOoS,eAAiBrJ,EAAKiT,eAAiBF,IAASmG,KAG9GnG,EAAO,IACVuF,GAAUC,GAA8BvY,EAAKwW,oBAAsBxW,EAAKwN,kBAAoB/V,EAAOsN,eAAiB9N,EAAOgT,eAAiBhT,EAAO+M,gBAAgB/M,EAAO+M,gBAAgBxU,OAAS,GAAKyH,EAAOgT,iBAC/MhT,EAAO8Y,QAAQ,CACXrB,UAAW,OACXjB,cAAc,EACdb,iBAAkB3V,EAAOkK,OAAO3R,QAAmC,SAAzBiI,EAAO+J,cAA2BvK,EAAOwK,uBAAyBrJ,KAAKsJ,KAAKzM,WAAWwC,EAAO+J,cAAe,QAG3JxB,EAAKwN,iBAAmBvW,EAAOgT,iBAC/BgP,GAAsB,EAClBxhB,EAAO0hB,aACPnZ,EAAKwN,iBAAmBvW,EAAOgT,eAAiB,GAAKhT,EAAOgT,eAAiBjK,EAAKiT,eAAiBF,IAASmG,KAIpHD,IACA5d,EAAE8b,yBAA0B,IAI3BlgB,EAAOgY,gBAA4C,SAA1BhY,EAAOsf,gBAA6BvW,EAAKwN,iBAAmBxN,EAAKiT,iBAC3FjT,EAAKwN,iBAAmBxN,EAAKiT,iBAE5Bhc,EAAOiY,gBAA4C,SAA1BjY,EAAOsf,gBAA6BvW,EAAKwN,iBAAmBxN,EAAKiT,iBAC3FjT,EAAKwN,iBAAmBxN,EAAKiT,gBAE5Bhc,EAAOiY,gBAAmBjY,EAAOgY,iBAClCjP,EAAKwN,iBAAmBxN,EAAKiT,gBAI7Bxb,EAAOwZ,UAAY,EAAG,CACtB,KAAI7Y,KAAK8N,IAAI6M,GAAQtb,EAAOwZ,WAAajR,EAAKwW,oBAW1C,YADAxW,EAAKwN,iBAAmBxN,EAAKiT,gBAT7B,IAAKjT,EAAKwW,mBAMN,OALAxW,EAAKwW,oBAAqB,EAC1BjC,EAAQb,OAASa,EAAQwB,SACzBxB,EAAQ2B,OAAS3B,EAAQyB,SACzBhW,EAAKwN,iBAAmBxN,EAAKiT,oBAC7BsB,EAAQxB,KAAO9b,EAAO0L,eAAiB4R,EAAQwB,SAAWxB,EAAQb,OAASa,EAAQyB,SAAWzB,EAAQ2B,OAOlH,CACKze,EAAO2hB,eAAgB3hB,EAAOuN,WAG/BvN,EAAOsf,UAAYtf,EAAOsf,SAASpT,SAAW1M,EAAO8f,UAAYtf,EAAOoQ,uBACxE5Q,EAAOgV,oBACPhV,EAAO+T,uBAEPvT,EAAOsf,UAAYtf,EAAOsf,SAASpT,SAAW1M,EAAO8f,UACrD9f,EAAO8f,SAASC,cAGpB/f,EAAO6S,eAAe9J,EAAKwN,kBAE3BvW,EAAOwW,aAAazN,EAAKwN,kBAC7B,CAEA,SAAS6L,EAAWra,GAChB,MAAM/H,EAAS/E,KACT8N,EAAO/I,EAAO+b,gBACpB,IAEIiE,EAFA5b,EAAI2D,EACJ3D,EAAE2Y,gBAAe3Y,EAAIA,EAAE2Y,eAG3B,GADgC,aAAX3Y,EAAE4Y,MAAkC,gBAAX5Y,EAAE4Y,MAO5C,GADAgD,EAAc,IAAI5b,EAAE6b,gBAAgB5jB,QAAO+b,GAAKA,EAAEgF,aAAerU,EAAKoU,UAAS,IAC1E6C,GAAeA,EAAY5C,aAAerU,EAAKoU,QAAS,WAN9C,CACf,GAAqB,OAAjBpU,EAAKoU,QAAkB,OAC3B,GAAI/Y,EAAE6Y,YAAclU,EAAKkU,UAAW,OACpC+C,EAAc5b,CAClB,CAIA,GAAI,CAAC,gBAAiB,aAAc,eAAgB,eAAewC,SAASxC,EAAE4Y,MAAO,CAEjF,KADgB,CAAC,gBAAiB,eAAepW,SAASxC,EAAE4Y,QAAUhd,EAAO4E,QAAQ6B,UAAYzG,EAAO4E,QAAQqC,YAE5G,MAER,CACA8B,EAAKkU,UAAY,KACjBlU,EAAKoU,QAAU,KACf,MAAM3c,OACFA,EAAM8c,QACNA,EACAjR,aAAcC,EAAGQ,WACjBA,EAAUJ,QACVA,GACA1M,EACJ,IAAK0M,EAAS,OACd,IAAKlM,EAAO+c,eAAmC,UAAlBnZ,EAAEoZ,YAAyB,OAKxD,GAJIzU,EAAKmW,qBACLlf,EAAO8I,KAAK,WAAY1E,GAE5B2E,EAAKmW,qBAAsB,GACtBnW,EAAK8U,UAMN,OALI9U,EAAK+U,SAAWtd,EAAOqhB,YACvB7hB,EAAO8hB,eAAc,GAEzB/Y,EAAK+U,SAAU,OACf/U,EAAKqW,aAAc,GAKnB5e,EAAOqhB,YAAc9Y,EAAK+U,SAAW/U,EAAK8U,aAAwC,IAA1B7d,EAAOgY,iBAAqD,IAA1BhY,EAAOiY,iBACjGjY,EAAO8hB,eAAc,GAIzB,MAAMO,EAAe5lB,IACf6lB,EAAWD,EAAetZ,EAAKsW,eAGrC,GAAIrf,EAAO4e,WAAY,CACnB,MAAM2D,EAAWne,EAAE4R,MAAQ5R,EAAE8Z,cAAgB9Z,EAAE8Z,eAC/Cle,EAAO+V,mBAAmBwM,GAAYA,EAAS,IAAMne,EAAElM,OAAQqqB,GAC/DviB,EAAO8I,KAAK,YAAa1E,GACrBke,EAAW,KAAOD,EAAetZ,EAAKyZ,cAAgB,KACtDxiB,EAAO8I,KAAK,wBAAyB1E,EAE7C,CAKA,GAJA2E,EAAKyZ,cAAgB/lB,IACrBF,GAAS,KACAyD,EAAO6H,YAAW7H,EAAO4e,YAAa,EAAI,KAE9C7V,EAAK8U,YAAc9U,EAAK+U,UAAY9d,EAAOsf,gBAAmC,IAAjBhC,EAAQxB,OAAe/S,EAAKgZ,eAAiBhZ,EAAKwN,mBAAqBxN,EAAKiT,iBAAmBjT,EAAKgZ,cAIlK,OAHAhZ,EAAK8U,WAAY,EACjB9U,EAAK+U,SAAU,OACf/U,EAAKqW,aAAc,GAMvB,IAAIqD,EAMJ,GATA1Z,EAAK8U,WAAY,EACjB9U,EAAK+U,SAAU,EACf/U,EAAKqW,aAAc,EAGfqD,EADAjiB,EAAO2hB,aACM7V,EAAMtM,EAAOI,WAAaJ,EAAOI,WAEhC2I,EAAKwN,iBAEnB/V,EAAOuN,QACP,OAEJ,GAAIvN,EAAOsf,UAAYtf,EAAOsf,SAASpT,QAInC,YAHA1M,EAAO8f,SAASsC,WAAW,CACvBK,eAMR,MAAMC,EAAcD,IAAeziB,EAAOgT,iBAAmBhT,EAAOQ,OAAO4K,KAC3E,IAAIuX,EAAY,EACZ/S,EAAY5P,EAAO+M,gBAAgB,GACvC,IAAK,IAAInO,EAAI,EAAGA,EAAIkO,EAAWvU,OAAQqG,GAAKA,EAAI4B,EAAO2O,mBAAqB,EAAI3O,EAAO0O,eAAgB,CACnG,MAAMiK,EAAYva,EAAI4B,EAAO2O,mBAAqB,EAAI,EAAI3O,EAAO0O,oBACxB,IAA9BpC,EAAWlO,EAAIua,IAClBuJ,GAAeD,GAAc3V,EAAWlO,IAAM6jB,EAAa3V,EAAWlO,EAAIua,MAC1EwJ,EAAY/jB,EACZgR,EAAY9C,EAAWlO,EAAIua,GAAarM,EAAWlO,KAEhD8jB,GAAeD,GAAc3V,EAAWlO,MAC/C+jB,EAAY/jB,EACZgR,EAAY9C,EAAWA,EAAWvU,OAAS,GAAKuU,EAAWA,EAAWvU,OAAS,GAEvF,CACA,IAAIqqB,EAAmB,KACnBC,EAAkB,KAClBriB,EAAO2K,SACHnL,EAAOiT,YACP4P,EAAkBriB,EAAOiM,SAAWjM,EAAOiM,QAAQC,SAAW1M,EAAOyM,QAAUzM,EAAOyM,QAAQvC,OAAO3R,OAAS,EAAIyH,EAAOkK,OAAO3R,OAAS,EAClIyH,EAAOkT,QACd0P,EAAmB,IAI3B,MAAME,GAASL,EAAa3V,EAAW6V,IAAc/S,EAC/CuJ,EAAYwJ,EAAYniB,EAAO2O,mBAAqB,EAAI,EAAI3O,EAAO0O,eACzE,GAAIoT,EAAW9hB,EAAOuiB,aAAc,CAEhC,IAAKviB,EAAOwiB,WAER,YADAhjB,EAAO2X,QAAQ3X,EAAO0K,aAGI,SAA1B1K,EAAOsf,iBACHwD,GAAStiB,EAAOyiB,gBAAiBjjB,EAAO2X,QAAQnX,EAAO2K,QAAUnL,EAAOkT,MAAQ0P,EAAmBD,EAAYxJ,GAAgBnZ,EAAO2X,QAAQgL,IAExH,SAA1B3iB,EAAOsf,iBACHwD,EAAQ,EAAItiB,EAAOyiB,gBACnBjjB,EAAO2X,QAAQgL,EAAYxJ,GACA,OAApB0J,GAA4BC,EAAQ,GAAK3hB,KAAK8N,IAAI6T,GAAStiB,EAAOyiB,gBACzEjjB,EAAO2X,QAAQkL,GAEf7iB,EAAO2X,QAAQgL,GAG3B,KAAO,CAEH,IAAKniB,EAAO0iB,YAER,YADAljB,EAAO2X,QAAQ3X,EAAO0K,aAGA1K,EAAOmjB,aAAe/e,EAAElM,SAAW8H,EAAOmjB,WAAWC,QAAUhf,EAAElM,SAAW8H,EAAOmjB,WAAWE,QAQ7Gjf,EAAElM,SAAW8H,EAAOmjB,WAAWC,OACtCpjB,EAAO2X,QAAQgL,EAAYxJ,GAE3BnZ,EAAO2X,QAAQgL,IATe,SAA1B3iB,EAAOsf,gBACPtf,EAAO2X,QAA6B,OAArBiL,EAA4BA,EAAmBD,EAAYxJ,GAEhD,SAA1BnZ,EAAOsf,gBACPtf,EAAO2X,QAA4B,OAApBkL,EAA2BA,EAAkBF,GAOxE,CACJ,CAEA,SAASW,IACL,MAAMtjB,EAAS/E,MACTuF,OACFA,EAAM7D,GACNA,GACAqD,EACJ,GAAIrD,GAAyB,IAAnBA,EAAG6H,YAAmB,OAG5BhE,EAAO6N,aACPrO,EAAOujB,gBAIX,MAAMvL,eACFA,EAAcC,eACdA,EAAcpL,SACdA,GACA7M,EACEwM,EAAYxM,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAG1D1M,EAAOgY,gBAAiB,EACxBhY,EAAOiY,gBAAiB,EACxBjY,EAAOuL,aACPvL,EAAO+L,eACP/L,EAAO+T,sBACP,MAAMyP,EAAgBhX,GAAahM,EAAO4K,OACZ,SAAzB5K,EAAO+J,eAA4B/J,EAAO+J,cAAgB,KAAMvK,EAAOkT,OAAUlT,EAAOiT,aAAgBjT,EAAOQ,OAAOsN,gBAAmB0V,EAGtIxjB,EAAOQ,OAAO4K,OAASoB,EACvBxM,EAAOyY,YAAYzY,EAAOqL,UAAW,GAAG,GAAO,GAE/CrL,EAAO2X,QAAQ3X,EAAO0K,YAAa,GAAG,GAAO,GALjD1K,EAAO2X,QAAQ3X,EAAOkK,OAAO3R,OAAS,EAAG,GAAG,GAAO,GAQnDyH,EAAOyjB,UAAYzjB,EAAOyjB,SAASC,SAAW1jB,EAAOyjB,SAASE,SAC9DnoB,aAAawE,EAAOyjB,SAASG,eAC7B5jB,EAAOyjB,SAASG,cAAgBroB,YAAW,KACnCyE,EAAOyjB,UAAYzjB,EAAOyjB,SAASC,SAAW1jB,EAAOyjB,SAASE,QAC9D3jB,EAAOyjB,SAASI,QACpB,GACD,MAGP7jB,EAAOiY,eAAiBA,EACxBjY,EAAOgY,eAAiBA,EACpBhY,EAAOQ,OAAOkQ,eAAiB7D,IAAa7M,EAAO6M,UACnD7M,EAAO2Q,eAEf,CAEA,SAASmT,EAAQ1f,GACb,MAAMpE,EAAS/E,KACV+E,EAAO0M,UACP1M,EAAO4e,aACJ5e,EAAOQ,OAAOujB,eAAe3f,EAAEyY,iBAC/B7c,EAAOQ,OAAOwjB,0BAA4BhkB,EAAOkX,YACjD9S,EAAE2c,kBACF3c,EAAE6f,6BAGd,CAEA,SAASC,IACL,MAAMlkB,EAAS/E,MACTyF,UACFA,EAAS2L,aACTA,EAAYK,QACZA,GACA1M,EACJ,IAAK0M,EAAS,OAWd,IAAIgK,EAVJ1W,EAAO6W,kBAAoB7W,EAAOI,UAC9BJ,EAAO0L,eACP1L,EAAOI,WAAaM,EAAU0C,WAE9BpD,EAAOI,WAAaM,EAAUwC,UAGT,IAArBlD,EAAOI,YAAiBJ,EAAOI,UAAY,GAC/CJ,EAAOgV,oBACPhV,EAAO+T,sBAEP,MAAMhB,EAAiB/S,EAAOgT,eAAiBhT,EAAOoS,eAElDsE,EADmB,IAAnB3D,EACc,GAEC/S,EAAOI,UAAYJ,EAAOoS,gBAAkBW,EAE3D2D,IAAgB1W,EAAOkB,UACvBlB,EAAO6S,eAAexG,GAAgBrM,EAAOI,UAAYJ,EAAOI,WAEpEJ,EAAO8I,KAAK,eAAgB9I,EAAOI,WAAW,EAClD,CAEA,SAAS+jB,EAAO/f,GACZ,MAAMpE,EAAS/E,KACfyO,EAAqB1J,EAAQoE,EAAElM,QAC3B8H,EAAOQ,OAAOuN,SAA2C,SAAhC/N,EAAOQ,OAAO+J,gBAA6BvK,EAAOQ,OAAOsT,YAGtF9T,EAAOsL,QACX,CAEA,SAAS8Y,IACL,MAAMpkB,EAAS/E,KACX+E,EAAOqkB,gCACXrkB,EAAOqkB,+BAAgC,EACnCrkB,EAAOQ,OAAO2f,sBACdngB,EAAOrD,GAAGpD,MAAM+qB,YAAc,QAEtC,CAEA,MAAM9c,EAAS,CAACxH,EAAQ8H,KACpB,MAAMvN,EAAWF,KACXmG,OACFA,EAAM7D,GACNA,EAAE+D,UACFA,EAAS8E,OACTA,GACAxF,EACEukB,IAAY/jB,EAAOsgB,OACnB0D,EAAuB,OAAX1c,EAAkB,mBAAqB,sBACnD2c,EAAe3c,EAChBnL,GAAoB,iBAAPA,IAGlBpC,EAASiqB,GAAW,aAAcxkB,EAAOokB,qBAAsB,CAC3DM,SAAS,EACTH,YAEJ5nB,EAAG6nB,GAAW,aAAcxkB,EAAO8c,aAAc,CAC7C4H,SAAS,IAEb/nB,EAAG6nB,GAAW,cAAexkB,EAAO8c,aAAc,CAC9C4H,SAAS,IAEbnqB,EAASiqB,GAAW,YAAaxkB,EAAO+f,YAAa,CACjD2E,SAAS,EACTH,YAEJhqB,EAASiqB,GAAW,cAAexkB,EAAO+f,YAAa,CACnD2E,SAAS,EACTH,YAEJhqB,EAASiqB,GAAW,WAAYxkB,EAAOoiB,WAAY,CAC/CsC,SAAS,IAEbnqB,EAASiqB,GAAW,YAAaxkB,EAAOoiB,WAAY,CAChDsC,SAAS,IAEbnqB,EAASiqB,GAAW,gBAAiBxkB,EAAOoiB,WAAY,CACpDsC,SAAS,IAEbnqB,EAASiqB,GAAW,cAAexkB,EAAOoiB,WAAY,CAClDsC,SAAS,IAEbnqB,EAASiqB,GAAW,aAAcxkB,EAAOoiB,WAAY,CACjDsC,SAAS,IAEbnqB,EAASiqB,GAAW,eAAgBxkB,EAAOoiB,WAAY,CACnDsC,SAAS,IAEbnqB,EAASiqB,GAAW,cAAexkB,EAAOoiB,WAAY,CAClDsC,SAAS,KAITlkB,EAAOujB,eAAiBvjB,EAAOwjB,2BAC/BrnB,EAAG6nB,GAAW,QAASxkB,EAAO8jB,SAAS,GAEvCtjB,EAAOuN,SACPrN,EAAU8jB,GAAW,SAAUxkB,EAAOkkB,UAItC1jB,EAAOmkB,qBACP3kB,EAAOykB,GAAcjf,EAAOC,KAAOD,EAAOE,QAAU,0CAA4C,wBAAyB4d,GAAU,GAEnItjB,EAAOykB,GAAc,iBAAkBnB,GAAU,GAIrD3mB,EAAG6nB,GAAW,OAAQxkB,EAAOmkB,OAAQ,CACjCI,SAAS,IACX,EA2BN,MAAMK,EAAgB,CAAC5kB,EAAQQ,IACpBR,EAAO2K,MAAQnK,EAAOmK,MAAQnK,EAAOmK,KAAKC,KAAO,EAmO5D,IAIIia,EAAW,CACXC,MAAM,EACNrN,UAAW,aACXwJ,gBAAgB,EAChB8D,sBAAuB,mBACvBrH,kBAAmB,UACnBnF,aAAc,EACd9X,MAAO,IACPsN,SAAS,EACT4W,sBAAsB,EACtBK,gBAAgB,EAChBlE,QAAQ,EACRmE,gBAAgB,EAChBC,aAAc,SACdxY,SAAS,EACT8S,kBAAmB,wDAEnB5Z,MAAO,KACPE,OAAQ,KAERqR,gCAAgC,EAEhCzc,UAAW,KACXyqB,IAAK,KAELzI,oBAAoB,EACpBC,mBAAoB,GAEpB7I,YAAY,EAEZzE,gBAAgB,EAEhBiH,kBAAkB,EAElBlH,OAAQ,QAIRf,iBAAa3P,EACb0mB,gBAAiB,SAEjB9X,aAAc,EACd/C,cAAe,EACf2E,eAAgB,EAChBC,mBAAoB,EACpB+J,oBAAoB,EACpBpL,gBAAgB,EAChBgC,sBAAsB,EACtB7C,mBAAoB,EAEpBE,kBAAmB,EAEnBoI,qBAAqB,EACrBpF,0BAA0B,EAE1BO,eAAe,EAEf/B,cAAc,EAEduS,WAAY,EACZT,WAAY,GACZlD,eAAe,EACf2F,aAAa,EACbF,YAAY,EACZC,gBAAiB,GACjBF,aAAc,IACdZ,cAAc,EACdzC,gBAAgB,EAChB1F,UAAW,EACX6G,0BAA0B,EAC1BlB,0BAA0B,EAC1BC,+BAA+B,EAC/BO,qBAAqB,EAErBkF,mBAAmB,EAEnBnD,YAAY,EACZD,gBAAiB,IAEjBrR,qBAAqB,EAErBiR,YAAY,EAEZkC,eAAe,EACfC,0BAA0B,EAC1B3N,qBAAqB,EAErBjL,MAAM,EACNyP,oBAAoB,EACpBG,qBAAsB,EACtB5B,qBAAqB,EAErBjO,QAAQ,EAER8M,gBAAgB,EAChBD,gBAAgB,EAChB6G,aAAc,KAEdR,WAAW,EACXL,eAAgB,oBAChBG,kBAAmB,KAEnBmH,kBAAkB,EAClBrU,wBAAyB,GAEzBF,uBAAwB,UAExBjH,WAAY,eACZ6Q,gBAAiB,qBACjB/F,iBAAkB,sBAClBlC,kBAAmB,uBACnBC,uBAAwB,6BACxBkC,eAAgB,oBAChBC,eAAgB,oBAChByQ,aAAc,iBACdvb,mBAAoB,wBACpBM,oBAAqB,EAErBwL,oBAAoB,EAEpB0P,cAAc,GAGlB,SAASC,GAAmBjlB,EAAQklB,GAChC,OAAO,SAAsB5tB,QACb,IAARA,IACAA,EAAM,CAAC,GAEX,MAAM6tB,EAAkB3tB,OAAOI,KAAKN,GAAK,GACnC8tB,EAAe9tB,EAAI6tB,GACG,iBAAjBC,GAA8C,OAAjBA,IAIR,IAA5BplB,EAAOmlB,KACPnlB,EAAOmlB,GAAmB,CACtBjZ,SAAS,IAGO,eAApBiZ,GAAoCnlB,EAAOmlB,IAAoBnlB,EAAOmlB,GAAiBjZ,UAAYlM,EAAOmlB,GAAiBtC,SAAW7iB,EAAOmlB,GAAiBvC,SAC9J5iB,EAAOmlB,GAAiBE,MAAO,GAE/B,CAAC,aAAc,aAAa3mB,QAAQymB,IAAoB,GAAKnlB,EAAOmlB,IAAoBnlB,EAAOmlB,GAAiBjZ,UAAYlM,EAAOmlB,GAAiBhpB,KACpJ6D,EAAOmlB,GAAiBE,MAAO,GAE7BF,KAAmBnlB,GAAU,YAAaolB,GAIT,iBAA5BplB,EAAOmlB,IAAmC,YAAanlB,EAAOmlB,KACrEnlB,EAAOmlB,GAAiBjZ,SAAU,GAEjClM,EAAOmlB,KAAkBnlB,EAAOmlB,GAAmB,CACpDjZ,SAAS,IAEbnO,EAAOmnB,EAAkB5tB,IATrByG,EAAOmnB,EAAkB5tB,IAfzByG,EAAOmnB,EAAkB5tB,EAyBjC,CACJ,CAGA,MAAMguB,GAAa,CACfxe,gBACAgE,SACAlL,YACA2lB,WAl4Da,CACb1U,cA/EJ,SAAuB9Q,EAAUkW,GAC7B,MAAMzW,EAAS/E,KACV+E,EAAOQ,OAAOuN,UACf/N,EAAOU,UAAUnH,MAAMysB,mBAAqB,GAAGzlB,MAC/CP,EAAOU,UAAUnH,MAAM0sB,gBAA+B,IAAb1lB,EAAiB,MAAQ,IAEtEP,EAAO8I,KAAK,gBAAiBvI,EAAUkW,EAC3C,EAyEIyB,gBAzCJ,SAAyBnB,EAAcU,QACd,IAAjBV,IACAA,GAAe,GAEnB,MAAM/W,EAAS/E,MACTuF,OACFA,GACAR,EACAQ,EAAOuN,UACPvN,EAAOsT,YACP9T,EAAOkR,mBAEXsG,EAAe,CACXxX,SACA+W,eACAU,YACAC,KAAM,UAEd,EAwBIS,cAtBJ,SAAuBpB,EAAcU,QACZ,IAAjBV,IACAA,GAAe,GAEnB,MAAM/W,EAAS/E,MACTuF,OACFA,GACAR,EACJA,EAAOkX,WAAY,EACf1W,EAAOuN,UACX/N,EAAOqR,cAAc,GACrBmG,EAAe,CACXxX,SACA+W,eACAU,YACAC,KAAM,QAEd,GAq4DIpJ,QACAlD,OACAyW,WAhpCa,CACbC,cAjCJ,SAAuBoE,GACnB,MAAMlmB,EAAS/E,KACf,IAAK+E,EAAOQ,OAAO+c,eAAiBvd,EAAOQ,OAAOkQ,eAAiB1Q,EAAOmmB,UAAYnmB,EAAOQ,OAAOuN,QAAS,OAC7G,MAAMpR,EAAyC,cAApCqD,EAAOQ,OAAOkd,kBAAoC1d,EAAOrD,GAAKqD,EAAOU,UAC5EV,EAAO6J,YACP7J,EAAO0b,qBAAsB,GAEjC/e,EAAGpD,MAAM6sB,OAAS,OAClBzpB,EAAGpD,MAAM6sB,OAASF,EAAS,WAAa,OACpClmB,EAAO6J,WACPnO,uBAAsB,KAClBsE,EAAO0b,qBAAsB,CAAK,GAG9C,EAoBI2K,gBAlBJ,WACI,MAAMrmB,EAAS/E,KACX+E,EAAOQ,OAAOkQ,eAAiB1Q,EAAOmmB,UAAYnmB,EAAOQ,OAAOuN,UAGhE/N,EAAO6J,YACP7J,EAAO0b,qBAAsB,GAEjC1b,EAA2C,cAApCA,EAAOQ,OAAOkd,kBAAoC,KAAO,aAAankB,MAAM6sB,OAAS,GACxFpmB,EAAO6J,WACPnO,uBAAsB,KAClBsE,EAAO0b,qBAAsB,CAAK,IAG9C,GAmpCIlU,OArZW,CACX8e,aArBJ,WACI,MAAMtmB,EAAS/E,MACTuF,OACFA,GACAR,EACJA,EAAO8c,aAAeA,EAAayJ,KAAKvmB,GACxCA,EAAO+f,YAAcA,EAAYwG,KAAKvmB,GACtCA,EAAOoiB,WAAaA,EAAWmE,KAAKvmB,GACpCA,EAAOokB,qBAAuBA,EAAqBmC,KAAKvmB,GACpDQ,EAAOuN,UACP/N,EAAOkkB,SAAWA,EAASqC,KAAKvmB,IAEpCA,EAAO8jB,QAAUA,EAAQyC,KAAKvmB,GAC9BA,EAAOmkB,OAASA,EAAOoC,KAAKvmB,GAC5BwH,EAAOxH,EAAQ,KACnB,EAOIwmB,aANJ,WAEIhf,EADevM,KACA,MACnB,GAuZIoT,YAlRc,CACdkV,cA7HJ,WACI,MAAMvjB,EAAS/E,MACToQ,UACFA,EAASwK,YACTA,EAAWrV,OACXA,EAAM7D,GACNA,GACAqD,EACEqO,EAAc7N,EAAO6N,YAC3B,IAAKA,GAAeA,GAAmD,IAApCrW,OAAOI,KAAKiW,GAAa9V,OAAc,OAG1E,MAAMkuB,EAAazmB,EAAO0mB,cAAcrY,EAAarO,EAAOQ,OAAO4kB,gBAAiBplB,EAAOrD,IAC3F,IAAK8pB,GAAczmB,EAAO2mB,oBAAsBF,EAAY,OAC5D,MACMG,GADuBH,KAAcpY,EAAcA,EAAYoY,QAAc/nB,IAClCsB,EAAO6mB,eAClDC,EAAclC,EAAc5kB,EAAQQ,GACpCumB,EAAanC,EAAc5kB,EAAQ4mB,GACnCI,EAAgBhnB,EAAOQ,OAAOqhB,WAC9BoF,EAAeL,EAAiB/E,WAChCqF,EAAa1mB,EAAOkM,QACtBoa,IAAgBC,GAChBpqB,EAAG8F,UAAU+G,OAAO,GAAGhJ,EAAOuQ,6BAA8B,GAAGvQ,EAAOuQ,qCACtE/Q,EAAOmnB,yBACCL,GAAeC,IACvBpqB,EAAG8F,UAAUC,IAAI,GAAGlC,EAAOuQ,+BACvB6V,EAAiBjc,KAAKsQ,MAAuC,WAA/B2L,EAAiBjc,KAAKsQ,OAAsB2L,EAAiBjc,KAAKsQ,MAA6B,WAArBza,EAAOmK,KAAKsQ,OACpHte,EAAG8F,UAAUC,IAAI,GAAGlC,EAAOuQ,qCAE/B/Q,EAAOmnB,wBAEPH,IAAkBC,EAClBjnB,EAAOqmB,mBACCW,GAAiBC,GACzBjnB,EAAO8hB,gBAIX,CAAC,aAAc,aAAc,aAAazpB,SAAQoL,IAC9C,QAAsC,IAA3BmjB,EAAiBnjB,GAAuB,OACnD,MAAM2jB,EAAmB5mB,EAAOiD,IAASjD,EAAOiD,GAAMiJ,QAChD2a,EAAkBT,EAAiBnjB,IAASmjB,EAAiBnjB,GAAMiJ,QACrE0a,IAAqBC,GACrBrnB,EAAOyD,GAAM6jB,WAEZF,GAAoBC,GACrBrnB,EAAOyD,GAAM8jB,QACjB,IAEJ,MAAMC,EAAmBZ,EAAiBnP,WAAamP,EAAiBnP,YAAcjX,EAAOiX,UACvFgQ,EAAcjnB,EAAO4K,OAASwb,EAAiBrc,gBAAkB/J,EAAO+J,eAAiBid,GACzFE,EAAUlnB,EAAO4K,KACnBoc,GAAoB3R,GACpB7V,EAAO2nB,kBAEXppB,EAAOyB,EAAOQ,OAAQomB,GACtB,MAAMgB,EAAY5nB,EAAOQ,OAAOkM,QAC1Bmb,EAAU7nB,EAAOQ,OAAO4K,KAC9BpT,OAAO8T,OAAO9L,EAAQ,CAClB0f,eAAgB1f,EAAOQ,OAAOkf,eAC9B1H,eAAgBhY,EAAOQ,OAAOwX,eAC9BC,eAAgBjY,EAAOQ,OAAOyX,iBAE9BiP,IAAeU,EACf5nB,EAAOsnB,WACCJ,GAAcU,GACtB5nB,EAAOunB,SAEXvnB,EAAO2mB,kBAAoBF,EAC3BzmB,EAAO8I,KAAK,oBAAqB8d,GAC7B/Q,IACI4R,GACAznB,EAAOqc,cACPrc,EAAOsa,WAAWjP,GAClBrL,EAAO+L,iBACC2b,GAAWG,GACnB7nB,EAAOsa,WAAWjP,GAClBrL,EAAO+L,gBACA2b,IAAYG,GACnB7nB,EAAOqc,eAGfrc,EAAO8I,KAAK,aAAc8d,EAC9B,EA2CIF,cAzCJ,SAAuBrY,EAAaiQ,EAAMwJ,GAItC,QAHa,IAATxJ,IACAA,EAAO,WAENjQ,GAAwB,cAATiQ,IAAyBwJ,EAAa,OAC1D,IAAIrB,GAAa,EACjB,MAAMzqB,EAASF,IACTisB,EAAyB,WAATzJ,EAAoBtiB,EAAOgsB,YAAcF,EAAYrc,aACrEwc,EAASjwB,OAAOI,KAAKiW,GAAa/Q,KAAI4qB,IACxC,GAAqB,iBAAVA,GAA6C,IAAvBA,EAAMhpB,QAAQ,KAAY,CACvD,MAAMipB,EAAWnqB,WAAWkqB,EAAME,OAAO,IAEzC,MAAO,CACHC,MAFUN,EAAgBI,EAG1BD,QAER,CACA,MAAO,CACHG,MAAOH,EACPA,QACH,IAELD,EAAOK,MAAK,CAAC/qB,EAAGgrB,IAAM3c,SAASrO,EAAE8qB,MAAO,IAAMzc,SAAS2c,EAAEF,MAAO,MAChE,IAAK,IAAIzpB,EAAI,EAAGA,EAAIqpB,EAAO1vB,OAAQqG,GAAK,EAAG,CACvC,MAAMspB,MACFA,EAAKG,MACLA,GACAJ,EAAOrpB,GACE,WAAT0f,EACItiB,EAAOP,WAAW,eAAe4sB,QAAYnmB,UAC7CukB,EAAayB,GAEVG,GAASP,EAAYtc,cAC5Bib,EAAayB,EAErB,CACA,OAAOzB,GAAc,KACzB,GAqRI9V,cA9KkB,CAClBA,cA9BJ,WACI,MAAM3Q,EAAS/E,MAEXkrB,SAAUqC,EAAShoB,OACnBA,GACAR,GACEiN,mBACFA,GACAzM,EACJ,GAAIyM,EAAoB,CACpB,MAAMwG,EAAiBzT,EAAOkK,OAAO3R,OAAS,EACxCkwB,EAAqBzoB,EAAO8M,WAAW2G,GAAkBzT,EAAO+M,gBAAgB0G,GAAuC,EAArBxG,EACxGjN,EAAOmmB,SAAWnmB,EAAOsE,KAAOmkB,CACpC,MACIzoB,EAAOmmB,SAAsC,IAA3BnmB,EAAO6M,SAAStU,QAER,IAA1BiI,EAAOwX,iBACPhY,EAAOgY,gBAAkBhY,EAAOmmB,WAEN,IAA1B3lB,EAAOyX,iBACPjY,EAAOiY,gBAAkBjY,EAAOmmB,UAEhCqC,GAAaA,IAAcxoB,EAAOmmB,WAClCnmB,EAAOkT,OAAQ,GAEfsV,IAAcxoB,EAAOmmB,UACrBnmB,EAAO8I,KAAK9I,EAAOmmB,SAAW,OAAS,SAE/C,GAgLIjqB,QAjNU,CACVwsB,WAhDJ,WACI,MAAM1oB,EAAS/E,MACT0tB,WACFA,EAAUnoB,OACVA,EAAM8L,IACNA,EAAG3P,GACHA,EAAE6I,OACFA,GACAxF,EAEE4oB,EAzBV,SAAwBC,EAASC,GAC7B,MAAMC,EAAgB,GAYtB,OAXAF,EAAQxwB,SAAQ2wB,IACQ,iBAATA,EACPhxB,OAAOI,KAAK4wB,GAAM3wB,SAAQswB,IAClBK,EAAKL,IACLI,EAAc9kB,KAAK6kB,EAASH,EAChC,IAEmB,iBAATK,GACdD,EAAc9kB,KAAK6kB,EAASE,EAChC,IAEGD,CACX,CAWqBE,CAAe,CAAC,cAAezoB,EAAOiX,UAAW,CAC9D,YAAazX,EAAOQ,OAAOsf,UAAYtf,EAAOsf,SAASpT,SACxD,CACCwc,WAAc1oB,EAAOsT,YACtB,CACCxH,IAAOA,GACR,CACC3B,KAAQnK,EAAOmK,MAAQnK,EAAOmK,KAAKC,KAAO,GAC3C,CACC,cAAepK,EAAOmK,MAAQnK,EAAOmK,KAAKC,KAAO,GAA0B,WAArBpK,EAAOmK,KAAKsQ,MACnE,CACCvV,QAAWF,EAAOE,SACnB,CACCD,IAAOD,EAAOC,KACf,CACC,WAAYjF,EAAOuN,SACpB,CACCob,SAAY3oB,EAAOuN,SAAWvN,EAAOsN,gBACtC,CACC,iBAAkBtN,EAAOoQ,sBACzBpQ,EAAOuQ,wBACX4X,EAAW1kB,QAAQ2kB,GACnBjsB,EAAG8F,UAAUC,OAAOimB,GACpB3oB,EAAOmnB,sBACX,EAeIiC,cAbJ,WACI,MACMzsB,GACFA,EAAEgsB,WACFA,GAHW1tB,KAKV0B,GAAoB,iBAAPA,IAClBA,EAAG8F,UAAU+G,UAAUmf,GANR1tB,KAORksB,uBACX,IAqNMkC,GAAmB,CAAC,EAC1B,MAAMzxB,GACF,WAAAG,GACI,IAAI4E,EACA6D,EACJ,IAAK,IAAI4H,EAAO3J,UAAUlG,OAAQ8P,EAAO,IAAI1F,MAAMyF,GAAOE,EAAO,EAAGA,EAAOF,EAAME,IAC7ED,EAAKC,GAAQ7J,UAAU6J,GAEP,IAAhBD,EAAK9P,QAAgB8P,EAAK,GAAGtQ,aAAwE,WAAzDC,OAAOoG,UAAUN,SAASO,KAAKgK,EAAK,IAAI/J,MAAM,GAAI,GAC9FkC,EAAS6H,EAAK,IAEb1L,EAAI6D,GAAU6H,EAEd7H,IAAQA,EAAS,CAAC,GACvBA,EAASjC,EAAO,CAAC,EAAGiC,GAChB7D,IAAO6D,EAAO7D,KAAI6D,EAAO7D,GAAKA,GAClC,MAAMpC,EAAWF,IACjB,GAAImG,EAAO7D,IAA2B,iBAAd6D,EAAO7D,IAAmBpC,EAASvB,iBAAiBwH,EAAO7D,IAAIpE,OAAS,EAAG,CAC/F,MAAM+wB,EAAU,GAQhB,OAPA/uB,EAASvB,iBAAiBwH,EAAO7D,IAAItE,SAAQyvB,IACzC,MAAMyB,EAAYhrB,EAAO,CAAC,EAAGiC,EAAQ,CACjC7D,GAAImrB,IAERwB,EAAQrlB,KAAK,IAAIrM,GAAO2xB,GAAW,IAGhCD,CACX,CAGA,MAAMtpB,EAAS/E,KACf+E,EAAOP,YAAa,EACpBO,EAAO0E,QAAUG,IACjB7E,EAAOwF,OAASL,EAAU,CACtBzK,UAAW8F,EAAO9F,YAEtBsF,EAAO4E,QAAU2B,IACjBvG,EAAO4H,gBAAkB,CAAC,EAC1B5H,EAAOyI,mBAAqB,GAC5BzI,EAAOwpB,QAAU,IAAIxpB,EAAOypB,aACxBjpB,EAAOgpB,SAAW7mB,MAAMC,QAAQpC,EAAOgpB,UACvCxpB,EAAOwpB,QAAQvlB,QAAQzD,EAAOgpB,SAElC,MAAM9D,EAAmB,CAAC,EAC1B1lB,EAAOwpB,QAAQnxB,SAAQqxB,IACnBA,EAAI,CACAlpB,SACAR,SACA2pB,aAAclE,GAAmBjlB,EAAQklB,GACzCne,GAAIvH,EAAOuH,GAAGgf,KAAKvmB,GACnBgI,KAAMhI,EAAOgI,KAAKue,KAAKvmB,GACvBkI,IAAKlI,EAAOkI,IAAIqe,KAAKvmB,GACrB8I,KAAM9I,EAAO8I,KAAKyd,KAAKvmB,IACzB,IAIN,MAAM4pB,EAAerrB,EAAO,CAAC,EAAGsmB,EAAUa,GAqG1C,OAlGA1lB,EAAOQ,OAASjC,EAAO,CAAC,EAAGqrB,EAAcP,GAAkB7oB,GAC3DR,EAAO6mB,eAAiBtoB,EAAO,CAAC,EAAGyB,EAAOQ,QAC1CR,EAAO6pB,aAAetrB,EAAO,CAAC,EAAGiC,GAG7BR,EAAOQ,QAAUR,EAAOQ,OAAO+G,IAC/BvP,OAAOI,KAAK4H,EAAOQ,OAAO+G,IAAIlP,SAAQyxB,IAClC9pB,EAAOuH,GAAGuiB,EAAW9pB,EAAOQ,OAAO+G,GAAGuiB,GAAW,IAGrD9pB,EAAOQ,QAAUR,EAAOQ,OAAOgI,OAC/BxI,EAAOwI,MAAMxI,EAAOQ,OAAOgI,OAI/BxQ,OAAO8T,OAAO9L,EAAQ,CAClB0M,QAAS1M,EAAOQ,OAAOkM,QACvB/P,KAEAgsB,WAAY,GAEZze,OAAQ,GACR4C,WAAY,GACZD,SAAU,GACVE,gBAAiB,GAEjBrB,aAAY,IAC2B,eAA5B1L,EAAOQ,OAAOiX,UAEzB9L,WAAU,IAC6B,aAA5B3L,EAAOQ,OAAOiX,UAGzB/M,YAAa,EACbW,UAAW,EAEX4H,aAAa,EACbC,OAAO,EAEP9S,UAAW,EACXyW,kBAAmB,EACnB3V,SAAU,EACV6oB,SAAU,EACV7S,WAAW,EACX,qBAAApF,GAGI,OAAO3Q,KAAK6oB,MAAM/uB,KAAKmF,UAAY,GAAK,IAAM,GAAK,EACvD,EAEA4X,eAAgBhY,EAAOQ,OAAOwX,eAC9BC,eAAgBjY,EAAOQ,OAAOyX,eAE9B8D,gBAAiB,CACb8B,eAAWnf,EACXof,aAASpf,EACTwgB,yBAAqBxgB,EACrB2gB,oBAAgB3gB,EAChBygB,iBAAazgB,EACb6X,sBAAkB7X,EAClBsd,oBAAgBtd,EAChB6gB,wBAAoB7gB,EAEpB8gB,kBAAmBxf,EAAOQ,OAAOgf,kBAEjCgD,cAAe,EACfyH,kBAAcvrB,EAEdwrB,WAAY,GACZtI,yBAAqBljB,EACrB0gB,iBAAa1gB,EACbue,UAAW,KACXE,QAAS,MAGbyB,YAAY,EAEZc,eAAgB1f,EAAOQ,OAAOkf,eAC9BpC,QAAS,CACLb,OAAQ,EACRwC,OAAQ,EACRH,SAAU,EACVC,SAAU,EACVjD,KAAM,GAGVqO,aAAc,GACdC,aAAc,IAElBpqB,EAAO8I,KAAK,WAGR9I,EAAOQ,OAAOskB,MACd9kB,EAAO8kB,OAKJ9kB,CACX,CACA,iBAAAkM,CAAkBme,GACd,OAAIpvB,KAAKyQ,eACE2e,EAGJ,CACHzkB,MAAS,SACT,aAAc,cACd,iBAAkB,eAClB,cAAe,aACf,eAAgB,gBAChB,eAAgB,cAChB,gBAAiB,iBACjB+H,YAAe,gBACjB0c,EACN,CACA,aAAAhQ,CAAcxY,GACV,MAAMsK,SACFA,EAAQ3L,OACRA,GACAvF,KAEEuY,EAAkB9P,EADT3B,EAAgBoK,EAAU,IAAI3L,EAAOsJ,4BACR,IAC5C,OAAOpG,EAAa7B,GAAW2R,CACnC,CACA,mBAAAjC,CAAoB5I,GAChB,OAAO1N,KAAKof,cAAcpf,KAAKiP,OAAO7N,QAAOwF,GAA6D,EAAlDA,EAAQ+T,aAAa,6BAAmCjN,IAAO,GAC3H,CACA,YAAAmS,GACI,MACM3O,SACFA,EAAQ3L,OACRA,GAHWvF,UAKRiP,OAASnI,EAAgBoK,EAAU,IAAI3L,EAAOsJ,2BACzD,CACA,MAAAyd,GACI,MAAMvnB,EAAS/E,KACX+E,EAAO0M,UACX1M,EAAO0M,SAAU,EACb1M,EAAOQ,OAAOqhB,YACd7hB,EAAO8hB,gBAEX9hB,EAAO8I,KAAK,UAChB,CACA,OAAAwe,GACI,MAAMtnB,EAAS/E,KACV+E,EAAO0M,UACZ1M,EAAO0M,SAAU,EACb1M,EAAOQ,OAAOqhB,YACd7hB,EAAOqmB,kBAEXrmB,EAAO8I,KAAK,WAChB,CACA,WAAAwhB,CAAYppB,EAAUT,GAClB,MAAMT,EAAS/E,KACfiG,EAAWC,KAAKE,IAAIF,KAAKC,IAAIF,EAAU,GAAI,GAC3C,MAAMG,EAAMrB,EAAOoS,eAEbrR,GADMf,EAAOgT,eACI3R,GAAOH,EAAWG,EACzCrB,EAAO8W,YAAY/V,OAA0B,IAAVN,EAAwB,EAAIA,GAC/DT,EAAOgV,oBACPhV,EAAO+T,qBACX,CACA,oBAAAoT,GACI,MAAMnnB,EAAS/E,KACf,IAAK+E,EAAOQ,OAAOglB,eAAiBxlB,EAAOrD,GAAI,OAC/C,MAAM4tB,EAAMvqB,EAAOrD,GAAG2M,UAAUlN,MAAM,KAAKC,QAAOiN,GACP,IAAhCA,EAAUpK,QAAQ,WAA+E,IAA5DoK,EAAUpK,QAAQc,EAAOQ,OAAOuQ,0BAEhF/Q,EAAO8I,KAAK,oBAAqByhB,EAAI9sB,KAAK,KAC9C,CACA,eAAA+sB,CAAgB3oB,GACZ,MAAM7B,EAAS/E,KACf,OAAI+E,EAAO6H,UAAkB,GACtBhG,EAAQyH,UAAUlN,MAAM,KAAKC,QAAOiN,GACM,IAAtCA,EAAUpK,QAAQ,iBAAyE,IAAhDoK,EAAUpK,QAAQc,EAAOQ,OAAOsJ,cACnFrM,KAAK,IACZ,CACA,iBAAAsX,GACI,MAAM/U,EAAS/E,KACf,IAAK+E,EAAOQ,OAAOglB,eAAiBxlB,EAAOrD,GAAI,OAC/C,MAAM8tB,EAAU,GAChBzqB,EAAOkK,OAAO7R,SAAQwJ,IAClB,MAAM8mB,EAAa3oB,EAAOwqB,gBAAgB3oB,GAC1C4oB,EAAQxmB,KAAK,CACTpC,UACA8mB,eAEJ3oB,EAAO8I,KAAK,cAAejH,EAAS8mB,EAAW,IAEnD3oB,EAAO8I,KAAK,gBAAiB2hB,EACjC,CACA,oBAAAjgB,CAAqBkgB,EAAMC,QACV,IAATD,IACAA,EAAO,gBAEG,IAAVC,IACAA,GAAQ,GAEZ,MACMnqB,OACFA,EAAM0J,OACNA,EAAM4C,WACNA,EAAUC,gBACVA,EACAzI,KAAM8H,EAAU1B,YAChBA,GAPWzP,KASf,IAAI2vB,EAAM,EACV,GAAoC,iBAAzBpqB,EAAO+J,cAA4B,OAAO/J,EAAO+J,cAC5D,GAAI/J,EAAOsN,eAAgB,CACvB,IACI+c,EADA5c,EAAY/D,EAAOQ,GAAevJ,KAAKsJ,KAAKP,EAAOQ,GAAasE,iBAAmB,EAEvF,IAAK,IAAIpQ,EAAI8L,EAAc,EAAG9L,EAAIsL,EAAO3R,OAAQqG,GAAK,EAC9CsL,EAAOtL,KAAOisB,IACd5c,GAAa9M,KAAKsJ,KAAKP,EAAOtL,GAAGoQ,iBACjC4b,GAAO,EACH3c,EAAY7B,IAAYye,GAAY,IAGhD,IAAK,IAAIjsB,EAAI8L,EAAc,EAAG9L,GAAK,EAAGA,GAAK,EACnCsL,EAAOtL,KAAOisB,IACd5c,GAAa/D,EAAOtL,GAAGoQ,gBACvB4b,GAAO,EACH3c,EAAY7B,IAAYye,GAAY,GAGpD,MAEI,GAAa,YAATH,EACA,IAAK,IAAI9rB,EAAI8L,EAAc,EAAG9L,EAAIsL,EAAO3R,OAAQqG,GAAK,EAAG,EACjC+rB,EAAQ7d,EAAWlO,GAAKmO,EAAgBnO,GAAKkO,EAAWpC,GAAe0B,EAAaU,EAAWlO,GAAKkO,EAAWpC,GAAe0B,KAE9Iwe,GAAO,EAEf,MAGA,IAAK,IAAIhsB,EAAI8L,EAAc,EAAG9L,GAAK,EAAGA,GAAK,EAAG,CACtBkO,EAAWpC,GAAeoC,EAAWlO,GAAKwN,IAE1Dwe,GAAO,EAEf,CAGR,OAAOA,CACX,CACA,MAAAtf,GACI,MAAMtL,EAAS/E,KACf,IAAK+E,GAAUA,EAAO6H,UAAW,OACjC,MAAMgF,SACFA,EAAQrM,OACRA,GACAR,EAcJ,SAASwW,IACL,MAAMsU,EAAiB9qB,EAAOqM,cAAmC,EAApBrM,EAAOI,UAAiBJ,EAAOI,UACtEgX,EAAejW,KAAKE,IAAIF,KAAKC,IAAI0pB,EAAgB9qB,EAAOgT,gBAAiBhT,EAAOoS,gBACtFpS,EAAOwW,aAAaY,GACpBpX,EAAOgV,oBACPhV,EAAO+T,qBACX,CACA,IAAIgX,EACJ,GApBIvqB,EAAO6N,aACPrO,EAAOujB,gBAEX,IAAIvjB,EAAOrD,GAAG3D,iBAAiB,qBAAqBX,SAAQsR,IACpDA,EAAQqhB,UACRthB,EAAqB1J,EAAQ2J,EACjC,IAEJ3J,EAAOuL,aACPvL,EAAO+L,eACP/L,EAAO6S,iBACP7S,EAAO+T,sBASHvT,EAAOsf,UAAYtf,EAAOsf,SAASpT,UAAYlM,EAAOuN,QACtDyI,IACIhW,EAAOsT,YACP9T,EAAOkR,uBAER,CACH,IAA8B,SAAzB1Q,EAAO+J,eAA4B/J,EAAO+J,cAAgB,IAAMvK,EAAOkT,QAAU1S,EAAOsN,eAAgB,CACzG,MAAM5D,EAASlK,EAAOyM,SAAWjM,EAAOiM,QAAQC,QAAU1M,EAAOyM,QAAQvC,OAASlK,EAAOkK,OACzF6gB,EAAa/qB,EAAO2X,QAAQzN,EAAO3R,OAAS,EAAG,GAAG,GAAO,EAC7D,MACIwyB,EAAa/qB,EAAO2X,QAAQ3X,EAAO0K,YAAa,GAAG,GAAO,GAEzDqgB,GACDvU,GAER,CACIhW,EAAOkQ,eAAiB7D,IAAa7M,EAAO6M,UAC5C7M,EAAO2Q,gBAEX3Q,EAAO8I,KAAK,SAChB,CACA,eAAA6e,CAAgBsD,EAAcC,QACP,IAAfA,IACAA,GAAa,GAEjB,MAAMlrB,EAAS/E,KACTkwB,EAAmBnrB,EAAOQ,OAAOiX,UAKvC,OAJKwT,IAEDA,EAAoC,eAArBE,EAAoC,WAAa,cAEhEF,IAAiBE,GAAqC,eAAjBF,GAAkD,aAAjBA,IAG1EjrB,EAAOrD,GAAG8F,UAAU+G,OAAO,GAAGxJ,EAAOQ,OAAOuQ,yBAAyBoa,KACrEnrB,EAAOrD,GAAG8F,UAAUC,IAAI,GAAG1C,EAAOQ,OAAOuQ,yBAAyBka,KAClEjrB,EAAOmnB,uBACPnnB,EAAOQ,OAAOiX,UAAYwT,EAC1BjrB,EAAOkK,OAAO7R,SAAQwJ,IACG,aAAjBopB,EACAppB,EAAQtI,MAAMqM,MAAQ,GAEtB/D,EAAQtI,MAAMuM,OAAS,EAC3B,IAEJ9F,EAAO8I,KAAK,mBACRoiB,GAAYlrB,EAAOsL,UAdZtL,CAgBf,CACA,uBAAAorB,CAAwB3T,GACpB,MAAMzX,EAAS/E,KACX+E,EAAOsM,KAAqB,QAAdmL,IAAwBzX,EAAOsM,KAAqB,QAAdmL,IACxDzX,EAAOsM,IAAoB,QAAdmL,EACbzX,EAAOqM,aAA2C,eAA5BrM,EAAOQ,OAAOiX,WAA8BzX,EAAOsM,IACrEtM,EAAOsM,KACPtM,EAAOrD,GAAG8F,UAAUC,IAAI,GAAG1C,EAAOQ,OAAOuQ,6BACzC/Q,EAAOrD,GAAGkE,IAAM,QAEhBb,EAAOrD,GAAG8F,UAAU+G,OAAO,GAAGxJ,EAAOQ,OAAOuQ,6BAC5C/Q,EAAOrD,GAAGkE,IAAM,OAEpBb,EAAOsL,SACX,CACA,KAAA+f,CAAMrpB,GACF,MAAMhC,EAAS/E,KACf,GAAI+E,EAAOsrB,QAAS,OAAO,EAG3B,IAAI3uB,EAAKqF,GAAWhC,EAAOQ,OAAO7D,GAIlC,GAHkB,iBAAPA,IACPA,EAAKpC,SAASxB,cAAc4D,KAE3BA,EACD,OAAO,EAEXA,EAAGqD,OAASA,EACRrD,EAAG4uB,YAAc5uB,EAAG4uB,WAAWzxB,MAAQ6C,EAAG4uB,WAAWzxB,KAAKhB,WAAakH,EAAOQ,OAAOukB,sBAAsByG,gBAC3GxrB,EAAO6J,WAAY,GAEvB,MAAM4hB,EAAqB,IAChB,KAAKzrB,EAAOQ,OAAO+kB,cAAgB,IAAIppB,OAAOC,MAAM,KAAKqB,KAAK,OAWzE,IAAIiD,EATe,MACf,GAAI/D,GAAMA,EAAGmF,YAAcnF,EAAGmF,WAAW/I,cAAe,CAGpD,OAFY4D,EAAGmF,WAAW/I,cAAc0yB,IAG5C,CACA,OAAO1pB,EAAgBpF,EAAI8uB,KAAsB,EAAE,EAGvCC,GAmBhB,OAlBKhrB,GAAaV,EAAOQ,OAAOykB,iBAC5BvkB,EAAYtH,EAAc,MAAO4G,EAAOQ,OAAO+kB,cAC/C5oB,EAAGie,OAAOla,GACVqB,EAAgBpF,EAAI,IAAIqD,EAAOQ,OAAOsJ,cAAczR,SAAQwJ,IACxDnB,EAAUka,OAAO/Y,EAAQ,KAGjC7J,OAAO8T,OAAO9L,EAAQ,CAClBrD,KACA+D,YACAyL,SAAUnM,EAAO6J,YAAclN,EAAG4uB,WAAWzxB,KAAK6xB,WAAahvB,EAAG4uB,WAAWzxB,KAAO4G,EACpFkrB,OAAQ5rB,EAAO6J,UAAYlN,EAAG4uB,WAAWzxB,KAAO6C,EAChD2uB,SAAS,EAEThf,IAA8B,QAAzB3P,EAAGkE,IAAI6F,eAA6D,QAAlClD,EAAa7G,EAAI,aACxD0P,aAA0C,eAA5BrM,EAAOQ,OAAOiX,YAAwD,QAAzB9a,EAAGkE,IAAI6F,eAA6D,QAAlClD,EAAa7G,EAAI,cAC9G4P,SAAiD,gBAAvC/I,EAAa9C,EAAW,cAE/B,CACX,CACA,IAAAokB,CAAKnoB,GACD,MAAMqD,EAAS/E,KACf,GAAI+E,EAAO6V,YAAa,OAAO7V,EAE/B,IAAgB,IADAA,EAAOqrB,MAAM1uB,GACN,OAAOqD,EAC9BA,EAAO8I,KAAK,cAGR9I,EAAOQ,OAAO6N,aACdrO,EAAOujB,gBAIXvjB,EAAO0oB,aAGP1oB,EAAOuL,aAGPvL,EAAO+L,eACH/L,EAAOQ,OAAOkQ,eACd1Q,EAAO2Q,gBAIP3Q,EAAOQ,OAAOqhB,YAAc7hB,EAAO0M,SACnC1M,EAAO8hB,gBAIP9hB,EAAOQ,OAAO4K,MAAQpL,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAC9D1M,EAAO2X,QAAQ3X,EAAOQ,OAAO+X,aAAevY,EAAOyM,QAAQiD,aAAc,EAAG1P,EAAOQ,OAAOsV,oBAAoB,GAAO,GAErH9V,EAAO2X,QAAQ3X,EAAOQ,OAAO+X,aAAc,EAAGvY,EAAOQ,OAAOsV,oBAAoB,GAAO,GAIvF9V,EAAOQ,OAAO4K,MACdpL,EAAOsa,aAIXta,EAAOsmB,eACP,MAAMuF,EAAe,IAAI7rB,EAAOrD,GAAG3D,iBAAiB,qBAsBpD,OArBIgH,EAAO6J,WACPgiB,EAAa5nB,QAAQjE,EAAO4rB,OAAO5yB,iBAAiB,qBAExD6yB,EAAaxzB,SAAQsR,IACbA,EAAQqhB,SACRthB,EAAqB1J,EAAQ2J,GAE7BA,EAAQjR,iBAAiB,QAAQ0L,IAC7BsF,EAAqB1J,EAAQoE,EAAElM,OAAO,GAE9C,IAEJkS,EAAQpK,GAGRA,EAAO6V,aAAc,EACrBzL,EAAQpK,GAGRA,EAAO8I,KAAK,QACZ9I,EAAO8I,KAAK,aACL9I,CACX,CACA,OAAA8rB,CAAQC,EAAgBC,QACG,IAAnBD,IACAA,GAAiB,QAED,IAAhBC,IACAA,GAAc,GAElB,MAAMhsB,EAAS/E,MACTuF,OACFA,EAAM7D,GACNA,EAAE+D,UACFA,EAASwJ,OACTA,GACAlK,EACJ,YAA6B,IAAlBA,EAAOQ,QAA0BR,EAAO6H,YAGnD7H,EAAO8I,KAAK,iBAGZ9I,EAAO6V,aAAc,EAGrB7V,EAAOwmB,eAGHhmB,EAAO4K,MACPpL,EAAOqc,cAIP2P,IACAhsB,EAAOopB,gBACHzsB,GAAoB,iBAAPA,GACbA,EAAGwN,gBAAgB,SAEnBzJ,GACAA,EAAUyJ,gBAAgB,SAE1BD,GAAUA,EAAO3R,QACjB2R,EAAO7R,SAAQwJ,IACXA,EAAQY,UAAU+G,OAAOhJ,EAAOkS,kBAAmBlS,EAAOmS,uBAAwBnS,EAAOoU,iBAAkBpU,EAAOqU,eAAgBrU,EAAOsU,gBACzIjT,EAAQsI,gBAAgB,SACxBtI,EAAQsI,gBAAgB,0BAA0B,KAI9DnK,EAAO8I,KAAK,WAGZ9Q,OAAOI,KAAK4H,EAAO4H,iBAAiBvP,SAAQyxB,IACxC9pB,EAAOkI,IAAI4hB,EAAU,KAEF,IAAnBiC,IACI/rB,EAAOrD,IAA2B,iBAAdqD,EAAOrD,KAC3BqD,EAAOrD,GAAGqD,OAAS,MAljInC,SAAqBlI,GACjB,MAAMm0B,EAASn0B,EACfE,OAAOI,KAAK6zB,GAAQ5zB,SAAQC,IACxB,IACI2zB,EAAO3zB,GAAO,IAClB,CAAE,MAAO8L,GAET,CACA,WACW6nB,EAAO3zB,EAClB,CAAE,MAAO8L,GAET,IAER,CAsiIY8nB,CAAYlsB,IAEhBA,EAAO6H,WAAY,GA5CR,IA8Cf,CACA,qBAAOskB,CAAeC,GAClB7tB,EAAO8qB,GAAkB+C,EAC7B,CACA,2BAAW/C,GACP,OAAOA,EACX,CACA,mBAAWxE,GACP,OAAOA,CACX,CACA,oBAAOwH,CAAc3C,GACZ9xB,GAAOwG,UAAUqrB,cAAa7xB,GAAOwG,UAAUqrB,YAAc,IAClE,MAAMD,EAAU5xB,GAAOwG,UAAUqrB,YACd,mBAARC,GAAsBF,EAAQtqB,QAAQwqB,GAAO,GACpDF,EAAQvlB,KAAKylB,EAErB,CACA,UAAO4C,CAAIC,GACP,OAAI5pB,MAAMC,QAAQ2pB,IACdA,EAAOl0B,SAAQm0B,GAAK50B,GAAOy0B,cAAcG,KAClC50B,KAEXA,GAAOy0B,cAAcE,GACd30B,GACX,EAw1BJ,SAAS60B,GAA0BzsB,EAAQ6mB,EAAgBrmB,EAAQksB,GAe/D,OAdI1sB,EAAOQ,OAAOykB,gBACdjtB,OAAOI,KAAKs0B,GAAYr0B,SAAQC,IAC5B,IAAKkI,EAAOlI,KAAwB,IAAhBkI,EAAOqlB,KAAe,CACtC,IAAI7jB,EAAUD,EAAgB/B,EAAOrD,GAAI,IAAI+vB,EAAWp0B,MAAQ,GAC3D0J,IACDA,EAAU5I,EAAc,MAAOszB,EAAWp0B,IAC1C0J,EAAQsH,UAAYojB,EAAWp0B,GAC/B0H,EAAOrD,GAAGie,OAAO5Y,IAErBxB,EAAOlI,GAAO0J,EACd6kB,EAAevuB,GAAO0J,CAC1B,KAGDxB,CACX,CAsMA,SAASmsB,GAAkBzwB,GAIvB,YAHgB,IAAZA,IACAA,EAAU,IAEP,IAAIA,EAAQC,OAAOqB,QAAQ,eAAgB,QAC7CA,QAAQ,KAAM,MACvB,CA2nGA,SAASovB,GAAY1iB,GACjB,MAAMlK,EAAS/E,MACTuF,OACFA,EAAM2L,SACNA,GACAnM,EACAQ,EAAO4K,MACPpL,EAAOqc,cAEX,MAAMwQ,EAAgBhrB,IAClB,GAAuB,iBAAZA,EAAsB,CAC7B,MAAMirB,EAAUvyB,SAASnB,cAAc,OACvC0zB,EAAQC,UAAYlrB,EACpBsK,EAASyO,OAAOkS,EAAQzzB,SAAS,IACjCyzB,EAAQC,UAAY,EACxB,MACI5gB,EAASyO,OAAO/Y,EACpB,EAEJ,GAAsB,iBAAXqI,GAAuB,WAAYA,EAC1C,IAAK,IAAItL,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EAChCsL,EAAOtL,IAAIiuB,EAAc3iB,EAAOtL,SAGxCiuB,EAAc3iB,GAElBlK,EAAO8a,eACHta,EAAO4K,MACPpL,EAAOsa,aAEN9Z,EAAOwsB,WAAYhtB,EAAO6J,WAC3B7J,EAAOsL,QAEf,CAEA,SAAS2hB,GAAa/iB,GAClB,MAAMlK,EAAS/E,MACTuF,OACFA,EAAMkK,YACNA,EAAWyB,SACXA,GACAnM,EACAQ,EAAO4K,MACPpL,EAAOqc,cAEX,IAAIpH,EAAiBvK,EAAc,EACnC,MAAMwiB,EAAiBrrB,IACnB,GAAuB,iBAAZA,EAAsB,CAC7B,MAAMirB,EAAUvyB,SAASnB,cAAc,OACvC0zB,EAAQC,UAAYlrB,EACpBsK,EAASyP,QAAQkR,EAAQzzB,SAAS,IAClCyzB,EAAQC,UAAY,EACxB,MACI5gB,EAASyP,QAAQ/Z,EACrB,EAEJ,GAAsB,iBAAXqI,GAAuB,WAAYA,EAAQ,CAClD,IAAK,IAAItL,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EAChCsL,EAAOtL,IAAIsuB,EAAehjB,EAAOtL,IAEzCqW,EAAiBvK,EAAcR,EAAO3R,MAC1C,MACI20B,EAAehjB,GAEnBlK,EAAO8a,eACHta,EAAO4K,MACPpL,EAAOsa,aAEN9Z,EAAOwsB,WAAYhtB,EAAO6J,WAC3B7J,EAAOsL,SAEXtL,EAAO2X,QAAQ1C,EAAgB,GAAG,EACtC,CAEA,SAASkY,GAASxkB,EAAOuB,GACrB,MAAMlK,EAAS/E,MACTuF,OACFA,EAAMkK,YACNA,EAAWyB,SACXA,GACAnM,EACJ,IAAIotB,EAAoB1iB,EACpBlK,EAAO4K,OACPgiB,GAAqBptB,EAAOoa,aAC5Bpa,EAAOqc,cACPrc,EAAO8a,gBAEX,MAAMuS,EAAartB,EAAOkK,OAAO3R,OACjC,GAAIoQ,GAAS,EAET,YADA3I,EAAOitB,aAAa/iB,GAGxB,GAAIvB,GAAS0kB,EAET,YADArtB,EAAO4sB,YAAY1iB,GAGvB,IAAI+K,EAAiBmY,EAAoBzkB,EAAQykB,EAAoB,EAAIA,EACzE,MAAME,EAAe,GACrB,IAAK,IAAI1uB,EAAIyuB,EAAa,EAAGzuB,GAAK+J,EAAO/J,GAAK,EAAG,CAC7C,MAAM2uB,EAAevtB,EAAOkK,OAAOtL,GACnC2uB,EAAa/jB,SACb8jB,EAAankB,QAAQokB,EACzB,CACA,GAAsB,iBAAXrjB,GAAuB,WAAYA,EAAQ,CAClD,IAAK,IAAItL,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EAChCsL,EAAOtL,IAAIuN,EAASyO,OAAO1Q,EAAOtL,IAE1CqW,EAAiBmY,EAAoBzkB,EAAQykB,EAAoBljB,EAAO3R,OAAS60B,CACrF,MACIjhB,EAASyO,OAAO1Q,GAEpB,IAAK,IAAItL,EAAI,EAAGA,EAAI0uB,EAAa/0B,OAAQqG,GAAK,EAC1CuN,EAASyO,OAAO0S,EAAa1uB,IAEjCoB,EAAO8a,eACHta,EAAO4K,MACPpL,EAAOsa,aAEN9Z,EAAOwsB,WAAYhtB,EAAO6J,WAC3B7J,EAAOsL,SAEP9K,EAAO4K,KACPpL,EAAO2X,QAAQ1C,EAAiBjV,EAAOoa,aAAc,GAAG,GAExDpa,EAAO2X,QAAQ1C,EAAgB,GAAG,EAE1C,CAEA,SAASuY,GAAYC,GACjB,MAAMztB,EAAS/E,MACTuF,OACFA,EAAMkK,YACNA,GACA1K,EACJ,IAAIotB,EAAoB1iB,EACpBlK,EAAO4K,OACPgiB,GAAqBptB,EAAOoa,aAC5Bpa,EAAOqc,eAEX,IACIqR,EADAzY,EAAiBmY,EAErB,GAA6B,iBAAlBK,GAA8B,WAAYA,EAAe,CAChE,IAAK,IAAI7uB,EAAI,EAAGA,EAAI6uB,EAAcl1B,OAAQqG,GAAK,EAC3C8uB,EAAgBD,EAAc7uB,GAC1BoB,EAAOkK,OAAOwjB,IAAgB1tB,EAAOkK,OAAOwjB,GAAelkB,SAC3DkkB,EAAgBzY,IAAgBA,GAAkB,GAE1DA,EAAiB9T,KAAKC,IAAI6T,EAAgB,EAC9C,MACIyY,EAAgBD,EACZztB,EAAOkK,OAAOwjB,IAAgB1tB,EAAOkK,OAAOwjB,GAAelkB,SAC3DkkB,EAAgBzY,IAAgBA,GAAkB,GACtDA,EAAiB9T,KAAKC,IAAI6T,EAAgB,GAE9CjV,EAAO8a,eACHta,EAAO4K,MACPpL,EAAOsa,aAEN9Z,EAAOwsB,WAAYhtB,EAAO6J,WAC3B7J,EAAOsL,SAEP9K,EAAO4K,KACPpL,EAAO2X,QAAQ1C,EAAiBjV,EAAOoa,aAAc,GAAG,GAExDpa,EAAO2X,QAAQ1C,EAAgB,GAAG,EAE1C,CAEA,SAAS0Y,KACL,MAAM3tB,EAAS/E,KACTwyB,EAAgB,GACtB,IAAK,IAAI7uB,EAAI,EAAGA,EAAIoB,EAAOkK,OAAO3R,OAAQqG,GAAK,EAC3C6uB,EAAcxpB,KAAKrF,GAEvBoB,EAAOwtB,YAAYC,EACvB,CAeA,SAASG,GAAWptB,GAChB,MAAM4O,OACFA,EAAMpP,OACNA,EAAMuH,GACNA,EAAEiP,aACFA,EAAYnF,cACZA,EAAawc,gBACbA,EAAeC,YACfA,EAAWC,gBACXA,EAAeC,gBACfA,GACAxtB,EA+BJ,IAAIytB,EA9BJ1mB,EAAG,cAAc,KACb,GAAIvH,EAAOQ,OAAO4O,SAAWA,EAAQ,OACrCpP,EAAO2oB,WAAW1kB,KAAK,GAAGjE,EAAOQ,OAAOuQ,yBAAyB3B,KAC7D0e,GAAeA,KACf9tB,EAAO2oB,WAAW1kB,KAAK,GAAGjE,EAAOQ,OAAOuQ,4BAE5C,MAAMmd,EAAwBL,EAAkBA,IAAoB,CAAC,EACrE71B,OAAO8T,OAAO9L,EAAOQ,OAAQ0tB,GAC7Bl2B,OAAO8T,OAAO9L,EAAO6mB,eAAgBqH,EAAsB,IAE/D3mB,EAAG,gBAAgB,KACXvH,EAAOQ,OAAO4O,SAAWA,GAC7BoH,GAAc,IAElBjP,EAAG,iBAAiB,CAAC4mB,EAAI5tB,KACjBP,EAAOQ,OAAO4O,SAAWA,GAC7BiC,EAAc9Q,EAAS,IAE3BgH,EAAG,iBAAiB,KAChB,GAAIvH,EAAOQ,OAAO4O,SAAWA,GACzB2e,EAAiB,CACjB,IAAKC,IAAoBA,IAAkBI,aAAc,OAEzDpuB,EAAOkK,OAAO7R,SAAQwJ,IAClBA,EAAQ7I,iBAAiB,gHAAgHX,SAAQg2B,GAAYA,EAAS7kB,UAAS,IAGnLukB,GACJ,KAGJxmB,EAAG,iBAAiB,KACZvH,EAAOQ,OAAO4O,SAAWA,IACxBpP,EAAOkK,OAAO3R,SACf01B,GAAyB,GAE7BvyB,uBAAsB,KACduyB,GAA0BjuB,EAAOkK,QAAUlK,EAAOkK,OAAO3R,SACzDie,IACAyX,GAAyB,EAC7B,IACF,GAEV,CAEA,SAASK,GAAaC,EAAc1sB,GAChC,MAAM2sB,EAAc5sB,EAAoBC,GAKxC,OAJI2sB,IAAgB3sB,IAChB2sB,EAAYj1B,MAAMk1B,mBAAqB,SACvCD,EAAYj1B,MAAM,+BAAiC,UAEhDi1B,CACX,CAEA,SAASE,GAA2B3uB,GAChC,IAAIC,OACAA,EAAMO,SACNA,EAAQouB,kBACRA,EAAiBC,UACjBA,GACA7uB,EACJ,MAAM2K,YACFA,GACA1K,EASJ,GAAIA,EAAOQ,OAAO8V,kBAAiC,IAAb/V,EAAgB,CAClD,IACIsuB,EADAC,GAAiB,EAGjBD,EADAD,EACsBD,EAEAA,EAAkBtyB,QAAOmyB,IAC3C,MAAM7xB,EAAK6xB,EAAY/rB,UAAU8G,SAAS,0BAfrC5M,KACb,IAAKA,EAAGqH,cAGJ,OADchE,EAAOkK,OAAO7N,QAAOwF,GAAWA,EAAQC,YAAcD,EAAQC,aAAenF,EAAG4uB,aAAY,GAG9G,OAAO5uB,EAAGqH,aAAa,EASuD+qB,CAASP,GAAeA,EAC9F,OAAOxuB,EAAOqa,cAAc1d,KAAQ+N,CAAW,IAGvDmkB,EAAoBx2B,SAAQsE,IACxBuH,EAAqBvH,GAAI,KACrB,GAAImyB,EAAgB,OACpB,IAAK9uB,GAAUA,EAAO6H,UAAW,OACjCinB,GAAiB,EACjB9uB,EAAOkX,WAAY,EACnB,MAAMqK,EAAM,IAAIvlB,OAAOhB,YAAY,gBAAiB,CAChDwmB,SAAS,EACTZ,YAAY,IAEhB5gB,EAAOU,UAAUihB,cAAcJ,EAAI,GACrC,GAEV,CACJ,CA0OA,SAASyN,GAAaC,EAAQptB,EAAS3B,GACnC,MAAMgvB,EAAc,sBAAsBhvB,EAAO,IAAIA,IAAS,KAAK+uB,EAAS,wBAAwBA,IAAW,KACzGE,EAAkBvtB,EAAoBC,GAC5C,IAAIwsB,EAAWc,EAAgBp2B,cAAc,IAAIm2B,EAAY9yB,MAAM,KAAKqB,KAAK,QAK7E,OAJK4wB,IACDA,EAAWj1B,EAAc,MAAO81B,EAAY9yB,MAAM,MAClD+yB,EAAgBvU,OAAOyT,IAEpBA,CACX,CA3sJAr2B,OAAOI,KAAK0tB,IAAYztB,SAAQ+2B,IAC5Bp3B,OAAOI,KAAK0tB,GAAWsJ,IAAiB/2B,SAAQg3B,IAC5Cz3B,GAAOwG,UAAUixB,GAAevJ,GAAWsJ,GAAgBC,EAAY,GACzE,IAENz3B,GAAO00B,IAAI,CAvtHX,SAAgBvsB,GACZ,IAAIC,OACAA,EAAMuH,GACNA,EAAEuB,KACFA,GACA/I,EACJ,MAAM/D,EAASF,IACf,IAAIkxB,EAAW,KACXsC,EAAiB,KACrB,MAAMC,EAAgB,KACbvvB,IAAUA,EAAO6H,WAAc7H,EAAO6V,cAC3C/M,EAAK,gBACLA,EAAK,UAAS,EAsCZ0mB,EAA2B,KACxBxvB,IAAUA,EAAO6H,WAAc7H,EAAO6V,aAC3C/M,EAAK,oBAAoB,EAE7BvB,EAAG,QAAQ,KACHvH,EAAOQ,OAAOwkB,qBAAmD,IAA1BhpB,EAAOyzB,eAxC7CzvB,IAAUA,EAAO6H,WAAc7H,EAAO6V,cAC3CmX,EAAW,IAAIyC,gBAAe5G,IAC1ByG,EAAiBtzB,EAAON,uBAAsB,KAC1C,MAAMkK,MACFA,EAAKE,OACLA,GACA9F,EACJ,IAAI0vB,EAAW9pB,EACXwL,EAAYtL,EAChB+iB,EAAQxwB,SAAQs3B,IACZ,IAAIC,eACAA,EAAcC,YACdA,EAAW33B,OACXA,GACAy3B,EACAz3B,GAAUA,IAAW8H,EAAOrD,KAChC+yB,EAAWG,EAAcA,EAAYjqB,OAASgqB,EAAe,IAAMA,GAAgBE,WACnF1e,EAAYye,EAAcA,EAAY/pB,QAAU8pB,EAAe,IAAMA,GAAgBG,UAAS,IAE9FL,IAAa9pB,GAASwL,IAActL,GACpCypB,GACJ,GACF,IAENvC,EAASgD,QAAQhwB,EAAOrD,MAoBxBX,EAAOtD,iBAAiB,SAAU62B,GAClCvzB,EAAOtD,iBAAiB,oBAAqB82B,GAAyB,IAE1EjoB,EAAG,WAAW,KApBN+nB,GACAtzB,EAAOJ,qBAAqB0zB,GAE5BtC,GAAYA,EAASiD,WAAajwB,EAAOrD,KACzCqwB,EAASiD,UAAUjwB,EAAOrD,IAC1BqwB,EAAW,MAiBfhxB,EAAOrD,oBAAoB,SAAU42B,GACrCvzB,EAAOrD,oBAAoB,oBAAqB62B,EAAyB,GAEjF,EAEA,SAAkBzvB,GACd,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,EAAEuB,KACFA,GACA/I,EACJ,MAAMmwB,EAAY,GACZl0B,EAASF,IACTq0B,EAAS,SAAUj4B,EAAQk4B,QACb,IAAZA,IACAA,EAAU,CAAC,GAEf,MACMpD,EAAW,IADIhxB,EAAOq0B,kBAAoBr0B,EAAOs0B,yBACrBC,IAI9B,GAAIvwB,EAAO0b,oBAAqB,OAChC,GAAyB,IAArB6U,EAAUh4B,OAEV,YADAuQ,EAAK,iBAAkBynB,EAAU,IAGrC,MAAMC,EAAiB,WACnB1nB,EAAK,iBAAkBynB,EAAU,GACrC,EACIv0B,EAAON,sBACPM,EAAON,sBAAsB80B,GAE7Bx0B,EAAOT,WAAWi1B,EAAgB,EACtC,IAEJxD,EAASgD,QAAQ93B,EAAQ,CACrBu4B,gBAA0C,IAAvBL,EAAQK,YAAoCL,EAAQK,WACvEC,eAAwC,IAAtBN,EAAQM,WAAmCN,EAAQM,UACrEC,mBAAgD,IAA1BP,EAAQO,eAAuCP,EAAQO,gBAEjFT,EAAUjsB,KAAK+oB,EACnB,EAyBArD,EAAa,CACTqD,UAAU,EACV4D,gBAAgB,EAChBC,sBAAsB,IAE1BtpB,EAAG,QA7BU,KACT,GAAKvH,EAAOQ,OAAOwsB,SAAnB,CACA,GAAIhtB,EAAOQ,OAAOowB,eAAgB,CAC9B,MAAME,EAAmBjtB,EAAe7D,EAAO4rB,QAC/C,IAAK,IAAIhtB,EAAI,EAAGA,EAAIkyB,EAAiBv4B,OAAQqG,GAAK,EAC9CuxB,EAAOW,EAAiBlyB,GAEhC,CAEAuxB,EAAOnwB,EAAO4rB,OAAQ,CAClB8E,UAAW1wB,EAAOQ,OAAOqwB,uBAI7BV,EAAOnwB,EAAOU,UAAW,CACrB+vB,YAAY,GAdmB,CAejC,IAcNlpB,EAAG,WAZa,KACZ2oB,EAAU73B,SAAQ20B,IACdA,EAAS+D,YAAY,IAEzBb,EAAUtnB,OAAO,EAAGsnB,EAAU33B,OAAO,GAS7C,IA6vRA,MAAMixB,GAAU,CA/qKhB,SAAiBzpB,GACb,IAkBIixB,GAlBAhxB,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,EAAEuB,KACFA,GACA/I,EACJ4pB,EAAa,CACTld,QAAS,CACLC,SAAS,EACTxC,OAAQ,GACR+mB,OAAO,EACPC,YAAa,KACbC,eAAgB,KAChBC,sBAAsB,EACtBC,gBAAiB,EACjBC,eAAgB,KAIxB,MAAM/2B,EAAWF,IACjB2F,EAAOyM,QAAU,CACbwkB,MAAO,CAAC,EACRlmB,UAAMrM,EACNF,QAAIE,EACJwL,OAAQ,GACRqnB,OAAQ,EACRzkB,WAAY,IAEhB,MAAMggB,EAAUvyB,EAASnB,cAAc,OACvC,SAAS83B,EAAY5iB,EAAO3F,GACxB,MAAMnI,EAASR,EAAOQ,OAAOiM,QAC7B,GAAIjM,EAAOywB,OAASjxB,EAAOyM,QAAQwkB,MAAMtoB,GACrC,OAAO3I,EAAOyM,QAAQwkB,MAAMtoB,GAGhC,IAAI9G,EAmBJ,OAlBIrB,EAAO0wB,aACPrvB,EAAUrB,EAAO0wB,YAAY7yB,KAAK2B,EAAQsO,EAAO3F,GAC1B,iBAAZ9G,IACPirB,EAAQC,UAAYlrB,EACpBA,EAAUirB,EAAQzzB,SAAS,KAG/BwI,EADO7B,EAAO6J,UACJzQ,EAAc,gBAEdA,EAAc,MAAO4G,EAAOQ,OAAOsJ,YAEjDjI,EAAQrI,aAAa,0BAA2BmP,GAC3CnI,EAAO0wB,cACRrvB,EAAQkrB,UAAYze,GAEpB9N,EAAOywB,QACPjxB,EAAOyM,QAAQwkB,MAAMtoB,GAAS9G,GAE3BA,CACX,CACA,SAASyJ,EAAOkmB,EAAOC,GACnB,MAAMlnB,cACFA,EAAa2E,eACbA,EAAcpB,eACdA,EACA1C,KAAMiW,EAAM9I,aACZA,GACAvY,EAAOQ,OACX,GAAIixB,IAAepQ,GAAU9I,EAAe,EACxC,OAEJ,MAAM8Y,gBACFA,EAAeC,eACfA,GACAtxB,EAAOQ,OAAOiM,SAEd1B,KAAM2mB,EACNlzB,GAAImzB,EAAUznB,OACdA,EACA4C,WAAY8kB,EACZL,OAAQM,GACR7xB,EAAOyM,QACNzM,EAAOQ,OAAOuN,SACf/N,EAAOgV,oBAEX,MAAMtK,EAAc1K,EAAO0K,aAAe,EAC1C,IAAIonB,EAEAniB,EACAD,EAFqBoiB,EAArB9xB,EAAOqM,aAA2B,QAA0BrM,EAAO0L,eAAiB,OAAS,MAG7FoC,GACA6B,EAAcxO,KAAK4N,MAAMxE,EAAgB,GAAK2E,EAAiBoiB,EAC/D5hB,EAAevO,KAAK4N,MAAMxE,EAAgB,GAAK2E,EAAiBmiB,IAEhE1hB,EAAcpF,GAAiB2E,EAAiB,GAAKoiB,EACrD5hB,GAAgB2R,EAAS9W,EAAgB2E,GAAkBmiB,GAE/D,IAAItmB,EAAOL,EAAcgF,EACrBlR,EAAKkM,EAAciF,EAClB0R,IACDtW,EAAO5J,KAAKC,IAAI2J,EAAM,GACtBvM,EAAK2C,KAAKE,IAAI7C,EAAI0L,EAAO3R,OAAS,IAEtC,IAAIg5B,GAAUvxB,EAAO8M,WAAW/B,IAAS,IAAM/K,EAAO8M,WAAW,IAAM,GAgBvE,SAASilB,IACL/xB,EAAO+L,eACP/L,EAAO6S,iBACP7S,EAAO+T,sBACPjL,EAAK,gBACT,CACA,GArBIuY,GAAU3W,GAAegF,GACzB3E,GAAQ2E,EACH5B,IAAgByjB,GAAUvxB,EAAO8M,WAAW,KAC1CuU,GAAU3W,EAAcgF,IAC/B3E,GAAQ2E,EACJ5B,IAAgByjB,GAAUvxB,EAAO8M,WAAW,KAEpD9U,OAAO8T,OAAO9L,EAAOyM,QAAS,CAC1B1B,OACAvM,KACA+yB,SACAzkB,WAAY9M,EAAO8M,WACnB4C,eACAC,gBAQA+hB,IAAiB3mB,GAAQ4mB,IAAenzB,IAAOgzB,EAQ/C,OAPIxxB,EAAO8M,aAAe8kB,GAAsBL,IAAWM,GACvD7xB,EAAOkK,OAAO7R,SAAQwJ,IAClBA,EAAQtI,MAAMu4B,GAAiBP,EAASpwB,KAAK8N,IAAIjP,EAAO8R,yBAA5B,IAAwD,IAG5F9R,EAAO6S,sBACP/J,EAAK,iBAGT,GAAI9I,EAAOQ,OAAOiM,QAAQ0kB,eAkBtB,OAjBAnxB,EAAOQ,OAAOiM,QAAQ0kB,eAAe9yB,KAAK2B,EAAQ,CAC9CuxB,SACAxmB,OACAvM,KACA0L,OAAQ,WACJ,MAAM8nB,EAAiB,GACvB,IAAK,IAAIpzB,EAAImM,EAAMnM,GAAKJ,EAAII,GAAK,EAC7BozB,EAAe/tB,KAAKiG,EAAOtL,IAE/B,OAAOozB,CACX,CANQ,UAQRhyB,EAAOQ,OAAOiM,QAAQ2kB,qBACtBW,IAEAjpB,EAAK,kBAIb,MAAMmpB,EAAiB,GACjBC,EAAgB,GAChB7X,EAAgB1R,IAClB,IAAIkH,EAAalH,EAOjB,OANIA,EAAQ,EACRkH,EAAa3F,EAAO3R,OAASoQ,EACtBkH,GAAc3F,EAAO3R,SAE5BsX,GAA0B3F,EAAO3R,QAE9BsX,CAAU,EAErB,GAAI2hB,EACAxxB,EAAOkK,OAAO7N,QAAOM,GAAMA,EAAGuF,QAAQ,IAAIlC,EAAOQ,OAAOsJ,8BAA6BzR,SAAQwJ,IACzFA,EAAQ2H,QAAQ,SAGpB,IAAK,IAAI5K,EAAI8yB,EAAc9yB,GAAK+yB,EAAY/yB,GAAK,EAC7C,GAAIA,EAAImM,GAAQnM,EAAIJ,EAAI,CACpB,MAAMqR,EAAawK,EAAczb,GACjCoB,EAAOkK,OAAO7N,QAAOM,GAAMA,EAAGuF,QAAQ,IAAIlC,EAAOQ,OAAOsJ,uCAAuC+F,8CAAuDA,SAAiBxX,SAAQwJ,IAC3KA,EAAQ2H,QAAQ,GAExB,CAGR,MAAM2oB,EAAW9Q,GAAUnX,EAAO3R,OAAS,EACrC65B,EAAS/Q,EAAyB,EAAhBnX,EAAO3R,OAAa2R,EAAO3R,OACnD,IAAK,IAAIqG,EAAIuzB,EAAUvzB,EAAIwzB,EAAQxzB,GAAK,EACpC,GAAIA,GAAKmM,GAAQnM,GAAKJ,EAAI,CACtB,MAAMqR,EAAawK,EAAczb,QACP,IAAf+yB,GAA8BH,EACrCU,EAAcjuB,KAAK4L,IAEfjR,EAAI+yB,GAAYO,EAAcjuB,KAAK4L,GACnCjR,EAAI8yB,GAAcO,EAAehuB,KAAK4L,GAElD,CAKJ,GAHAqiB,EAAc75B,SAAQsQ,IAClB3I,EAAOmM,SAASyO,OAAOsW,EAAYhnB,EAAOvB,GAAQA,GAAO,IAEzD0Y,EACA,IAAK,IAAIziB,EAAIqzB,EAAe15B,OAAS,EAAGqG,GAAK,EAAGA,GAAK,EAAG,CACpD,MAAM+J,EAAQspB,EAAerzB,GAC7BoB,EAAOmM,SAASyP,QAAQsV,EAAYhnB,EAAOvB,GAAQA,GACvD,MAEAspB,EAAe3J,MAAK,CAAC/qB,EAAGgrB,IAAMA,EAAIhrB,IAClC00B,EAAe55B,SAAQsQ,IACnB3I,EAAOmM,SAASyP,QAAQsV,EAAYhnB,EAAOvB,GAAQA,GAAO,IAGlE5G,EAAgB/B,EAAOmM,SAAU,+BAA+B9T,SAAQwJ,IACpEA,EAAQtI,MAAMu4B,GAAiBP,EAASpwB,KAAK8N,IAAIjP,EAAO8R,yBAA5B,IAAwD,IAExFigB,GACJ,CAuFAxqB,EAAG,cAAc,KACb,IAAKvH,EAAOQ,OAAOiM,QAAQC,QAAS,OACpC,IAAI2lB,EACJ,QAAkD,IAAvCryB,EAAO6pB,aAAapd,QAAQvC,OAAwB,CAC3D,MAAMA,EAAS,IAAIlK,EAAOmM,SAAS9S,UAAUgD,QAAOM,GAAMA,EAAGuF,QAAQ,IAAIlC,EAAOQ,OAAOsJ,8BACnFI,GAAUA,EAAO3R,SACjByH,EAAOyM,QAAQvC,OAAS,IAAIA,GAC5BmoB,GAAoB,EACpBnoB,EAAO7R,SAAQ,CAACwJ,EAASgO,KACrBhO,EAAQrI,aAAa,0BAA2BqW,GAChD7P,EAAOyM,QAAQwkB,MAAMphB,GAAchO,EACnCA,EAAQ2H,QAAQ,IAG5B,CACK6oB,IACDryB,EAAOyM,QAAQvC,OAASlK,EAAOQ,OAAOiM,QAAQvC,QAElDlK,EAAO2oB,WAAW1kB,KAAK,GAAGjE,EAAOQ,OAAOuQ,iCACxC/Q,EAAOQ,OAAOoQ,qBAAsB,EACpC5Q,EAAO6mB,eAAejW,qBAAsB,EAC5CtF,GAAO,GAAO,EAAK,IAEvB/D,EAAG,gBAAgB,KACVvH,EAAOQ,OAAOiM,QAAQC,UACvB1M,EAAOQ,OAAOuN,UAAY/N,EAAOqY,mBACjC7c,aAAaw1B,GACbA,EAAiBz1B,YAAW,KACxB+P,GAAQ,GACT,MAEHA,IACJ,IAEJ/D,EAAG,sBAAsB,KAChBvH,EAAOQ,OAAOiM,QAAQC,SACvB1M,EAAOQ,OAAOuN,SACdrO,EAAeM,EAAOU,UAAW,wBAAyB,GAAGV,EAAOyN,gBACxE,IAEJzV,OAAO8T,OAAO9L,EAAOyM,QAAS,CAC1BmgB,YA/HJ,SAAqB1iB,GACjB,GAAsB,iBAAXA,GAAuB,WAAYA,EAC1C,IAAK,IAAItL,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EAChCsL,EAAOtL,IAAIoB,EAAOyM,QAAQvC,OAAOjG,KAAKiG,EAAOtL,SAGrDoB,EAAOyM,QAAQvC,OAAOjG,KAAKiG,GAE/BoB,GAAO,EACX,EAuHI2hB,aAtHJ,SAAsB/iB,GAClB,MAAMQ,EAAc1K,EAAO0K,YAC3B,IAAIuK,EAAiBvK,EAAc,EAC/B4nB,EAAoB,EACxB,GAAI3vB,MAAMC,QAAQsH,GAAS,CACvB,IAAK,IAAItL,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EAChCsL,EAAOtL,IAAIoB,EAAOyM,QAAQvC,OAAOf,QAAQe,EAAOtL,IAExDqW,EAAiBvK,EAAcR,EAAO3R,OACtC+5B,EAAoBpoB,EAAO3R,MAC/B,MACIyH,EAAOyM,QAAQvC,OAAOf,QAAQe,GAElC,GAAIlK,EAAOQ,OAAOiM,QAAQwkB,MAAO,CAC7B,MAAMA,EAAQjxB,EAAOyM,QAAQwkB,MACvBsB,EAAW,CAAC,EAClBv6B,OAAOI,KAAK64B,GAAO54B,SAAQm6B,IACvB,MAAMC,EAAWxB,EAAMuB,GACjBE,EAAgBD,EAAS7c,aAAa,2BACxC8c,GACAD,EAASj5B,aAAa,0BAA2BoS,SAAS8mB,EAAe,IAAMJ,GAEnFC,EAAS3mB,SAAS4mB,EAAa,IAAMF,GAAqBG,CAAQ,IAEtEzyB,EAAOyM,QAAQwkB,MAAQsB,CAC3B,CACAjnB,GAAO,GACPtL,EAAO2X,QAAQ1C,EAAgB,EACnC,EA2FIuY,YA1FJ,SAAqBC,GACjB,GAAI,MAAOA,EAAyD,OACpE,IAAI/iB,EAAc1K,EAAO0K,YACzB,GAAI/H,MAAMC,QAAQ6qB,GACd,IAAK,IAAI7uB,EAAI6uB,EAAcl1B,OAAS,EAAGqG,GAAK,EAAGA,GAAK,EAC5CoB,EAAOQ,OAAOiM,QAAQwkB,eACfjxB,EAAOyM,QAAQwkB,MAAMxD,EAAc7uB,IAE1C5G,OAAOI,KAAK4H,EAAOyM,QAAQwkB,OAAO54B,SAAQC,IAClCA,EAAMm1B,IACNztB,EAAOyM,QAAQwkB,MAAM34B,EAAM,GAAK0H,EAAOyM,QAAQwkB,MAAM34B,GACrD0H,EAAOyM,QAAQwkB,MAAM34B,EAAM,GAAGkB,aAAa,0BAA2BlB,EAAM,UACrE0H,EAAOyM,QAAQwkB,MAAM34B,GAChC,KAGR0H,EAAOyM,QAAQvC,OAAOtB,OAAO6kB,EAAc7uB,GAAI,GAC3C6uB,EAAc7uB,GAAK8L,IAAaA,GAAe,GACnDA,EAAcvJ,KAAKC,IAAIsJ,EAAa,QAGpC1K,EAAOQ,OAAOiM,QAAQwkB,eACfjxB,EAAOyM,QAAQwkB,MAAMxD,GAE5Bz1B,OAAOI,KAAK4H,EAAOyM,QAAQwkB,OAAO54B,SAAQC,IAClCA,EAAMm1B,IACNztB,EAAOyM,QAAQwkB,MAAM34B,EAAM,GAAK0H,EAAOyM,QAAQwkB,MAAM34B,GACrD0H,EAAOyM,QAAQwkB,MAAM34B,EAAM,GAAGkB,aAAa,0BAA2BlB,EAAM,UACrE0H,EAAOyM,QAAQwkB,MAAM34B,GAChC,KAGR0H,EAAOyM,QAAQvC,OAAOtB,OAAO6kB,EAAe,GACxCA,EAAgB/iB,IAAaA,GAAe,GAChDA,EAAcvJ,KAAKC,IAAIsJ,EAAa,GAExCY,GAAO,GACPtL,EAAO2X,QAAQjN,EAAa,EAChC,EAqDIijB,gBApDJ,WACI3tB,EAAOyM,QAAQvC,OAAS,GACpBlK,EAAOQ,OAAOiM,QAAQwkB,QACtBjxB,EAAOyM,QAAQwkB,MAAQ,CAAC,GAE5B3lB,GAAO,GACPtL,EAAO2X,QAAQ,EAAG,EACtB,EA8CIrM,UAER,EAGA,SAAkBvL,GACd,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,EAAEuB,KACFA,GACA/I,EACJ,MAAMxF,EAAWF,IACX2B,EAASF,IAWf,SAAS62B,EAAO5qB,GACZ,IAAK/H,EAAO0M,QAAS,OACrB,MACIL,aAAcC,GACdtM,EACJ,IAAIoE,EAAI2D,EACJ3D,EAAE2Y,gBAAe3Y,EAAIA,EAAE2Y,eAC3B,MAAM6V,EAAKxuB,EAAEyuB,SAAWzuB,EAAE0uB,SACpBC,EAAa/yB,EAAOQ,OAAOwyB,SAASD,WACpCE,EAAWF,GAAqB,KAAPH,EACzBM,EAAaH,GAAqB,KAAPH,EAC3BO,EAAqB,KAAPP,EACdQ,EAAsB,KAAPR,EACfS,EAAmB,KAAPT,EACZU,EAAqB,KAAPV,EAEpB,IAAK5yB,EAAOgY,iBAAmBhY,EAAO0L,gBAAkB0nB,GAAgBpzB,EAAO2L,cAAgB2nB,GAAeJ,GAC1G,OAAO,EAEX,IAAKlzB,EAAOiY,iBAAmBjY,EAAO0L,gBAAkBynB,GAAenzB,EAAO2L,cAAgB0nB,GAAaJ,GACvG,OAAO,EAEX,KAAI7uB,EAAEmvB,UAAYnvB,EAAEovB,QAAUpvB,EAAEqvB,SAAWrvB,EAAEsvB,SAGzCn5B,EAAS3B,eAAiB2B,EAAS3B,cAAcE,WAA+D,UAAlDyB,EAAS3B,cAAcE,SAAS4N,eAA+E,aAAlDnM,EAAS3B,cAAcE,SAAS4N,gBAA/J,CAGA,GAAI1G,EAAOQ,OAAOwyB,SAASW,iBAAmBV,GAAYC,GAAcC,GAAeC,GAAgBC,GAAaC,GAAc,CAC9H,IAAIM,GAAS,EAEb,GAAI/vB,EAAe7D,EAAOrD,GAAI,IAAIqD,EAAOQ,OAAOsJ,4BAA4BvR,OAAS,GAAgF,IAA3EsL,EAAe7D,EAAOrD,GAAI,IAAIqD,EAAOQ,OAAOoU,oBAAoBrc,OACtJ,OAEJ,MAAMoE,EAAKqD,EAAOrD,GACZk3B,EAAcl3B,EAAG6O,YACjBsoB,EAAen3B,EAAG8O,aAClBsoB,EAAc/3B,EAAO4gB,WACrBoX,EAAeh4B,EAAOgsB,YACtBiM,EAAepxB,EAAclG,GAC/B2P,IAAK2nB,EAAa1wB,MAAQ5G,EAAGyG,YACjC,MAAM8wB,EAAc,CAAC,CAACD,EAAa1wB,KAAM0wB,EAAa3wB,KAAM,CAAC2wB,EAAa1wB,KAAOswB,EAAaI,EAAa3wB,KAAM,CAAC2wB,EAAa1wB,KAAM0wB,EAAa3wB,IAAMwwB,GAAe,CAACG,EAAa1wB,KAAOswB,EAAaI,EAAa3wB,IAAMwwB,IAC5N,IAAK,IAAIl1B,EAAI,EAAGA,EAAIs1B,EAAY37B,OAAQqG,GAAK,EAAG,CAC5C,MAAMspB,EAAQgM,EAAYt1B,GAC1B,GAAIspB,EAAM,IAAM,GAAKA,EAAM,IAAM6L,GAAe7L,EAAM,IAAM,GAAKA,EAAM,IAAM8L,EAAc,CACvF,GAAiB,IAAb9L,EAAM,IAAyB,IAAbA,EAAM,GAAU,SACtC0L,GAAS,CACb,CACJ,CACA,IAAKA,EAAQ,MACjB,CACI5zB,EAAO0L,iBACHunB,GAAYC,GAAcC,GAAeC,KACrChvB,EAAEyY,eAAgBzY,EAAEyY,iBAAsBzY,EAAE+vB,aAAc,KAE7DjB,GAAcE,KAAkB9mB,IAAQ2mB,GAAYE,IAAgB7mB,IAAKtM,EAAOgZ,cAChFia,GAAYE,KAAiB7mB,IAAQ4mB,GAAcE,IAAiB9mB,IAAKtM,EAAOsZ,eAEjF2Z,GAAYC,GAAcG,GAAaC,KACnClvB,EAAEyY,eAAgBzY,EAAEyY,iBAAsBzY,EAAE+vB,aAAc,IAE9DjB,GAAcI,IAAatzB,EAAOgZ,aAClCia,GAAYI,IAAWrzB,EAAOsZ,aAEtCxQ,EAAK,WAAY8pB,EArCjB,CAuCJ,CACA,SAASrL,IACDvnB,EAAOgzB,SAAStmB,UACpBnS,EAAS7B,iBAAiB,UAAWi6B,GACrC3yB,EAAOgzB,SAAStmB,SAAU,EAC9B,CACA,SAAS4a,IACAtnB,EAAOgzB,SAAStmB,UACrBnS,EAAS5B,oBAAoB,UAAWg6B,GACxC3yB,EAAOgzB,SAAStmB,SAAU,EAC9B,CAtFA1M,EAAOgzB,SAAW,CACdtmB,SAAS,GAEbid,EAAa,CACTqJ,SAAU,CACNtmB,SAAS,EACTinB,gBAAgB,EAChBZ,YAAY,KAgFpBxrB,EAAG,QAAQ,KACHvH,EAAOQ,OAAOwyB,SAAStmB,SACvB6a,GACJ,IAEJhgB,EAAG,WAAW,KACNvH,EAAOgzB,SAAStmB,SAChB4a,GACJ,IAEJtvB,OAAO8T,OAAO9L,EAAOgzB,SAAU,CAC3BzL,SACAD,WAER,EAGA,SAAoBvnB,GAChB,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,EAAEuB,KACFA,GACA/I,EACJ,MAAM/D,EAASF,IAiBf,IAAIs4B,EAhBJzK,EAAa,CACT0K,WAAY,CACR3nB,SAAS,EACT4nB,gBAAgB,EAChBC,QAAQ,EACRC,aAAa,EACbC,YAAa,EACbC,aAAc,YACdC,eAAgB,KAChBC,cAAe,KACfC,kBAAmB,0BAG3B70B,EAAOq0B,WAAa,CAChB3nB,SAAS,GAGb,IACIooB,EADAC,EAAiBt4B,IAErB,MAAMu4B,EAAoB,GAqE1B,SAASC,IACAj1B,EAAO0M,UACZ1M,EAAOk1B,cAAe,EAC1B,CACA,SAASC,IACAn1B,EAAO0M,UACZ1M,EAAOk1B,cAAe,EAC1B,CACA,SAASE,EAAcC,GACnB,QAAIr1B,EAAOQ,OAAO6zB,WAAWM,gBAAkBU,EAASC,MAAQt1B,EAAOQ,OAAO6zB,WAAWM,oBAIrF30B,EAAOQ,OAAO6zB,WAAWO,eAAiBn4B,IAAQs4B,EAAiB/0B,EAAOQ,OAAO6zB,WAAWO,iBAQ5FS,EAASC,OAAS,GAAK74B,IAAQs4B,EAAiB,KAgBhDM,EAAS5d,UAAY,EACfzX,EAAOkT,QAASlT,EAAOQ,OAAO4K,MAAUpL,EAAOkX,YACjDlX,EAAOgZ,YACPlQ,EAAK,SAAUusB,EAASE,MAEnBv1B,EAAOiT,cAAejT,EAAOQ,OAAO4K,MAAUpL,EAAOkX,YAC9DlX,EAAOsZ,YACPxQ,EAAK,SAAUusB,EAASE,MAG5BR,GAAiB,IAAI/4B,EAAOX,MAAO4F,WAE5B,IACX,CAcA,SAAS0xB,EAAO5qB,GACZ,IAAI3D,EAAI2D,EACJia,GAAsB,EAC1B,IAAKhiB,EAAO0M,QAAS,OAGrB,GAAI3E,EAAM7P,OAAO0R,QAAQ,IAAI5J,EAAOQ,OAAO6zB,WAAWQ,qBAAsB,OAC5E,MAAMr0B,EAASR,EAAOQ,OAAO6zB,WACzBr0B,EAAOQ,OAAOuN,SACd3J,EAAEyY,iBAEN,IAAIY,EAAWzd,EAAOrD,GACwB,cAA1CqD,EAAOQ,OAAO6zB,WAAWK,eACzBjX,EAAWljB,SAASxB,cAAciH,EAAOQ,OAAO6zB,WAAWK,eAE/D,MAAMc,EAAyB/X,GAAYA,EAASlU,SAASnF,EAAElM,QAC/D,IAAK8H,EAAOk1B,eAAiBM,IAA2Bh1B,EAAO8zB,eAAgB,OAAO,EAClFlwB,EAAE2Y,gBAAe3Y,EAAIA,EAAE2Y,eAC3B,IAAIuY,EAAQ,EACZ,MAAMG,EAAYz1B,EAAOqM,cAAgB,EAAI,EACvCtD,EAxJV,SAAmB3E,GAKf,IAAIsxB,EAAK,EACLC,EAAK,EACLC,EAAK,EACLC,EAAK,EAqDT,MAlDI,WAAYzxB,IACZuxB,EAAKvxB,EAAEqd,QAEP,eAAgBrd,IAChBuxB,GAAMvxB,EAAE0xB,WAAa,KAErB,gBAAiB1xB,IACjBuxB,GAAMvxB,EAAE2xB,YAAc,KAEtB,gBAAiB3xB,IACjBsxB,GAAMtxB,EAAE4xB,YAAc,KAItB,SAAU5xB,GAAKA,EAAExH,OAASwH,EAAE6xB,kBAC5BP,EAAKC,EACLA,EAAK,GAETC,EA3BmB,GA2BdF,EACLG,EA5BmB,GA4BdF,EACD,WAAYvxB,IACZyxB,EAAKzxB,EAAE8xB,QAEP,WAAY9xB,IACZwxB,EAAKxxB,EAAE+xB,QAEP/xB,EAAEmvB,WAAaqC,IAEfA,EAAKC,EACLA,EAAK,IAEJD,GAAMC,IAAOzxB,EAAEgyB,YACI,IAAhBhyB,EAAEgyB,WAEFR,GA1CY,GA2CZC,GA3CY,KA8CZD,GA7CY,IA8CZC,GA9CY,MAmDhBD,IAAOF,IACPA,EAAKE,EAAK,GAAK,EAAI,GAEnBC,IAAOF,IACPA,EAAKE,EAAK,GAAK,EAAI,GAEhB,CACHQ,MAAOX,EACPY,MAAOX,EACPY,OAAQX,EACRY,OAAQX,EAEhB,CAqFiBtc,CAAUnV,GACvB,GAAI5D,EAAOg0B,YACP,GAAIx0B,EAAO0L,eAAgB,CACvB,KAAIvK,KAAK8N,IAAIlG,EAAKwtB,QAAUp1B,KAAK8N,IAAIlG,EAAKytB,SAA+C,OAAO,EAA7ClB,GAASvsB,EAAKwtB,OAASd,CAC9E,KAAO,MAAIt0B,KAAK8N,IAAIlG,EAAKytB,QAAUr1B,KAAK8N,IAAIlG,EAAKwtB,SAAmC,OAAO,EAAjCjB,GAASvsB,EAAKytB,MAAuB,MAE/FlB,EAAQn0B,KAAK8N,IAAIlG,EAAKwtB,QAAUp1B,KAAK8N,IAAIlG,EAAKytB,SAAWztB,EAAKwtB,OAASd,GAAa1sB,EAAKytB,OAE7F,GAAc,IAAVlB,EAAa,OAAO,EACpB90B,EAAO+zB,SAAQe,GAASA,GAG5B,IAAImB,EAAYz2B,EAAOtD,eAAiB44B,EAAQ90B,EAAOi0B,YAavD,GAZIgC,GAAaz2B,EAAOoS,iBAAgBqkB,EAAYz2B,EAAOoS,gBACvDqkB,GAAaz2B,EAAOgT,iBAAgByjB,EAAYz2B,EAAOgT,gBAS3DgP,IAAsBhiB,EAAOQ,OAAO4K,QAAgBqrB,IAAcz2B,EAAOoS,gBAAkBqkB,IAAcz2B,EAAOgT,gBAC5GgP,GAAuBhiB,EAAOQ,OAAOsgB,QAAQ1c,EAAE2c,kBAC9C/gB,EAAOQ,OAAOsf,UAAa9f,EAAOQ,OAAOsf,SAASpT,QAoChD,CAOH,MAAM2oB,EAAW,CACbh1B,KAAM5D,IACN64B,MAAOn0B,KAAK8N,IAAIqmB,GAChB7d,UAAWtW,KAAKu1B,KAAKpB,IAEnBqB,EAAoB7B,GAAuBO,EAASh1B,KAAOy0B,EAAoBz0B,KAAO,KAAOg1B,EAASC,OAASR,EAAoBQ,OAASD,EAAS5d,YAAcqd,EAAoBrd,UAC7L,IAAKkf,EAAmB,CACpB7B,OAAsBp2B,EACtB,IAAIk4B,EAAW52B,EAAOtD,eAAiB44B,EAAQ90B,EAAOi0B,YACtD,MAAMrhB,EAAepT,EAAOiT,YACtBI,EAASrT,EAAOkT,MAiBtB,GAhBI0jB,GAAY52B,EAAOoS,iBAAgBwkB,EAAW52B,EAAOoS,gBACrDwkB,GAAY52B,EAAOgT,iBAAgB4jB,EAAW52B,EAAOgT,gBACzDhT,EAAOqR,cAAc,GACrBrR,EAAOwW,aAAaogB,GACpB52B,EAAO6S,iBACP7S,EAAOgV,oBACPhV,EAAO+T,wBACFX,GAAgBpT,EAAOiT,cAAgBI,GAAUrT,EAAOkT,QACzDlT,EAAO+T,sBAEP/T,EAAOQ,OAAO4K,MACdpL,EAAO8Y,QAAQ,CACXrB,UAAW4d,EAAS5d,UAAY,EAAI,OAAS,OAC7CsD,cAAc,IAGlB/a,EAAOQ,OAAOsf,SAAS+W,OAAQ,CAY/Br7B,aAAa44B,GACbA,OAAU11B,EACNs2B,EAAkBz8B,QAAU,IAC5By8B,EAAkB/Y,QAGtB,MAAM6a,EAAY9B,EAAkBz8B,OAASy8B,EAAkBA,EAAkBz8B,OAAS,QAAKmG,EACzFq4B,EAAa/B,EAAkB,GAErC,GADAA,EAAkB/wB,KAAKoxB,GACnByB,IAAczB,EAASC,MAAQwB,EAAUxB,OAASD,EAAS5d,YAAcqf,EAAUrf,WAEnFud,EAAkBpsB,OAAO,QACtB,GAAIosB,EAAkBz8B,QAAU,IAAM88B,EAASh1B,KAAO02B,EAAW12B,KAAO,KAAO02B,EAAWzB,MAAQD,EAASC,OAAS,GAAKD,EAASC,OAAS,EAAG,CAOjJ,MAAM0B,EAAkB1B,EAAQ,EAAI,GAAM,GAC1CR,EAAsBO,EACtBL,EAAkBpsB,OAAO,GACzBwrB,EAAU73B,GAAS,KACfyD,EAAO+Z,eAAe/Z,EAAOQ,OAAOC,OAAO,OAAM/B,EAAWs4B,EAAgB,GAC7E,EACP,CAEK5C,IAIDA,EAAU73B,GAAS,KAEfu4B,EAAsBO,EACtBL,EAAkBpsB,OAAO,GACzB5I,EAAO+Z,eAAe/Z,EAAOQ,OAAOC,OAAO,OAAM/B,EAHzB,GAGoD,GAC7E,KAEX,CAQA,GALKi4B,GAAmB7tB,EAAK,SAAU1E,GAGnCpE,EAAOQ,OAAOijB,UAAYzjB,EAAOQ,OAAOy2B,8BAA8Bj3B,EAAOyjB,SAASyT,OAEtF12B,EAAO8zB,iBAAmBsC,IAAa52B,EAAOoS,gBAAkBwkB,IAAa52B,EAAOgT,gBACpF,OAAO,CAEf,CACJ,KApIgE,CAE5D,MAAMqiB,EAAW,CACbh1B,KAAM5D,IACN64B,MAAOn0B,KAAK8N,IAAIqmB,GAChB7d,UAAWtW,KAAKu1B,KAAKpB,GACrBC,IAAKxtB,GAILitB,EAAkBz8B,QAAU,GAC5By8B,EAAkB/Y,QAGtB,MAAM6a,EAAY9B,EAAkBz8B,OAASy8B,EAAkBA,EAAkBz8B,OAAS,QAAKmG,EAmB/F,GAlBAs2B,EAAkB/wB,KAAKoxB,GAQnByB,GACIzB,EAAS5d,YAAcqf,EAAUrf,WAAa4d,EAASC,MAAQwB,EAAUxB,OAASD,EAASh1B,KAAOy2B,EAAUz2B,KAAO,MACnH+0B,EAAcC,GAGlBD,EAAcC,GAtF1B,SAAuBA,GACnB,MAAM70B,EAASR,EAAOQ,OAAO6zB,WAC7B,GAAIgB,EAAS5d,UAAY,GACrB,GAAIzX,EAAOkT,QAAUlT,EAAOQ,OAAO4K,MAAQ5K,EAAO8zB,eAE9C,OAAO,OAER,GAAIt0B,EAAOiT,cAAgBjT,EAAOQ,OAAO4K,MAAQ5K,EAAO8zB,eAE3D,OAAO,EAEX,OAAO,CACX,CA+EY6C,CAAc9B,GACd,OAAO,CAEf,CAkGA,OADIjxB,EAAEyY,eAAgBzY,EAAEyY,iBAAsBzY,EAAE+vB,aAAc,GACvD,CACX,CACA,SAAS3sB,EAAOM,GACZ,IAAI2V,EAAWzd,EAAOrD,GACwB,cAA1CqD,EAAOQ,OAAO6zB,WAAWK,eACzBjX,EAAWljB,SAASxB,cAAciH,EAAOQ,OAAO6zB,WAAWK,eAE/DjX,EAAS3V,GAAQ,aAAcmtB,GAC/BxX,EAAS3V,GAAQ,aAAcqtB,GAC/B1X,EAAS3V,GAAQ,QAAS6qB,EAC9B,CACA,SAASpL,IACL,OAAIvnB,EAAOQ,OAAOuN,SACd/N,EAAOU,UAAU/H,oBAAoB,QAASg6B,IACvC,IAEP3yB,EAAOq0B,WAAW3nB,UACtBlF,EAAO,oBACPxH,EAAOq0B,WAAW3nB,SAAU,GACrB,EACX,CACA,SAAS4a,IACL,OAAItnB,EAAOQ,OAAOuN,SACd/N,EAAOU,UAAUhI,iBAAiBqP,MAAO4qB,IAClC,KAEN3yB,EAAOq0B,WAAW3nB,UACvBlF,EAAO,uBACPxH,EAAOq0B,WAAW3nB,SAAU,GACrB,EACX,CACAnF,EAAG,QAAQ,MACFvH,EAAOQ,OAAO6zB,WAAW3nB,SAAW1M,EAAOQ,OAAOuN,SACnDuZ,IAEAtnB,EAAOQ,OAAO6zB,WAAW3nB,SAAS6a,GAAQ,IAElDhgB,EAAG,WAAW,KACNvH,EAAOQ,OAAOuN,SACdwZ,IAEAvnB,EAAOq0B,WAAW3nB,SAAS4a,GAAS,IAE5CtvB,OAAO8T,OAAO9L,EAAOq0B,WAAY,CAC7B9M,SACAD,WAER,EAoBA,SAAoBvnB,GAChB,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,EAAEuB,KACFA,GACA/I,EAgBJ,SAASq3B,EAAMz6B,GACX,IAAI06B,EACJ,OAAI16B,GAAoB,iBAAPA,GAAmBqD,EAAO6J,YACvCwtB,EAAMr3B,EAAOrD,GAAG5D,cAAc4D,GAC1B06B,GAAYA,GAEhB16B,IACkB,iBAAPA,IAAiB06B,EAAM,IAAI98B,SAASvB,iBAAiB2D,KAC5DqD,EAAOQ,OAAO6kB,mBAAmC,iBAAP1oB,GAAmB06B,GAAOA,EAAI9+B,OAAS,GAA+C,IAA1CyH,EAAOrD,GAAG3D,iBAAiB2D,GAAIpE,OACrH8+B,EAAMr3B,EAAOrD,GAAG5D,cAAc4D,GACvB06B,GAAsB,IAAfA,EAAI9+B,SAClB8+B,EAAMA,EAAI,KAGd16B,IAAO06B,EAAY16B,EAEhB06B,EACX,CACA,SAASC,EAAS36B,EAAI46B,GAClB,MAAM/2B,EAASR,EAAOQ,OAAO2iB,YAC7BxmB,EAAK8H,EAAkB9H,IACpBtE,SAAQm/B,IACHA,IACAA,EAAM/0B,UAAU80B,EAAW,MAAQ,aAAa/2B,EAAOi3B,cAAcr7B,MAAM,MACrD,WAAlBo7B,EAAME,UAAsBF,EAAMD,SAAWA,GAC7Cv3B,EAAOQ,OAAOkQ,eAAiB1Q,EAAO0M,SACtC8qB,EAAM/0B,UAAUzC,EAAOmmB,SAAW,MAAQ,UAAU3lB,EAAOm3B,WAEnE,GAER,CACA,SAASrsB,IAEL,MAAM8X,OACFA,EAAMC,OACNA,GACArjB,EAAOmjB,WACX,GAAInjB,EAAOQ,OAAO4K,KAGd,OAFAksB,EAASjU,GAAQ,QACjBiU,EAASlU,GAAQ,GAGrBkU,EAASjU,EAAQrjB,EAAOiT,cAAgBjT,EAAOQ,OAAO2K,QACtDmsB,EAASlU,EAAQpjB,EAAOkT,QAAUlT,EAAOQ,OAAO2K,OACpD,CACA,SAASysB,EAAYxzB,GACjBA,EAAEyY,mBACE7c,EAAOiT,aAAgBjT,EAAOQ,OAAO4K,MAASpL,EAAOQ,OAAO2K,UAChEnL,EAAOsZ,YACPxQ,EAAK,kBACT,CACA,SAAS+uB,EAAYzzB,GACjBA,EAAEyY,mBACE7c,EAAOkT,OAAUlT,EAAOQ,OAAO4K,MAASpL,EAAOQ,OAAO2K,UAC1DnL,EAAOgZ,YACPlQ,EAAK,kBACT,CACA,SAASgc,IACL,MAAMtkB,EAASR,EAAOQ,OAAO2iB,WAK7B,GAJAnjB,EAAOQ,OAAO2iB,WAAasJ,GAA0BzsB,EAAQA,EAAO6mB,eAAe1D,WAAYnjB,EAAOQ,OAAO2iB,WAAY,CACrHC,OAAQ,qBACRC,OAAQ,wBAEN7iB,EAAO4iB,SAAU5iB,EAAO6iB,OAAS,OACvC,IAAID,EAASgU,EAAM52B,EAAO4iB,QACtBC,EAAS+T,EAAM52B,EAAO6iB,QAC1BrrB,OAAO8T,OAAO9L,EAAOmjB,WAAY,CAC7BC,SACAC,WAEJD,EAAS3e,EAAkB2e,GAC3BC,EAAS5e,EAAkB4e,GAC3B,MAAMyU,EAAa,CAACn7B,EAAIkE,KAChBlE,GACAA,EAAGjE,iBAAiB,QAAiB,SAARmI,EAAiBg3B,EAAcD,IAE3D53B,EAAO0M,SAAW/P,GACnBA,EAAG8F,UAAUC,OAAOlC,EAAOm3B,UAAUv7B,MAAM,KAC/C,EAEJgnB,EAAO/qB,SAAQsE,GAAMm7B,EAAWn7B,EAAI,UACpC0mB,EAAOhrB,SAAQsE,GAAMm7B,EAAWn7B,EAAI,SACxC,CACA,SAASmvB,IACL,IAAI1I,OACAA,EAAMC,OACNA,GACArjB,EAAOmjB,WACXC,EAAS3e,EAAkB2e,GAC3BC,EAAS5e,EAAkB4e,GAC3B,MAAM0U,EAAgB,CAACp7B,EAAIkE,KACvBlE,EAAGhE,oBAAoB,QAAiB,SAARkI,EAAiBg3B,EAAcD,GAC/Dj7B,EAAG8F,UAAU+G,UAAUxJ,EAAOQ,OAAO2iB,WAAWsU,cAAcr7B,MAAM,KAAK,EAE7EgnB,EAAO/qB,SAAQsE,GAAMo7B,EAAcp7B,EAAI,UACvC0mB,EAAOhrB,SAAQsE,GAAMo7B,EAAcp7B,EAAI,SAC3C,CA/GAgtB,EAAa,CACTxG,WAAY,CACRC,OAAQ,KACRC,OAAQ,KACR2U,aAAa,EACbP,cAAe,yBACfQ,YAAa,uBACbN,UAAW,qBACXO,wBAAyB,gCAGjCl4B,EAAOmjB,WAAa,CAChBC,OAAQ,KACRC,OAAQ,MAmGZ9b,EAAG,QAAQ,MACkC,IAArCvH,EAAOQ,OAAO2iB,WAAWzW,QAEzB4a,KAEAxC,IACAxZ,IACJ,IAEJ/D,EAAG,+BAA+B,KAC9B+D,GAAQ,IAEZ/D,EAAG,WAAW,KACVukB,GAAS,IAEbvkB,EAAG,kBAAkB,KACjB,IAAI6b,OACAA,EAAMC,OACNA,GACArjB,EAAOmjB,WACXC,EAAS3e,EAAkB2e,GAC3BC,EAAS5e,EAAkB4e,GACvBrjB,EAAO0M,QACPpB,IAGJ,IAAI8X,KAAWC,GAAQhnB,QAAOM,KAAQA,IAAItE,SAAQsE,GAAMA,EAAG8F,UAAUC,IAAI1C,EAAOQ,OAAO2iB,WAAWwU,YAAW,IAEjHpwB,EAAG,SAAS,CAAC4mB,EAAI/pB,KACb,IAAIgf,OACAA,EAAMC,OACNA,GACArjB,EAAOmjB,WACXC,EAAS3e,EAAkB2e,GAC3BC,EAAS5e,EAAkB4e,GAC3B,MAAM5F,EAAWrZ,EAAElM,OACnB,IAAIigC,EAAiB9U,EAAOzc,SAAS6W,IAAa2F,EAAOxc,SAAS6W,GAClE,GAAIzd,EAAO6J,YAAcsuB,EAAgB,CACrC,MAAMniB,EAAO5R,EAAE4R,MAAQ5R,EAAE8Z,cAAgB9Z,EAAE8Z,eACvClI,IACAmiB,EAAiBniB,EAAKoiB,MAAKniB,GAAUmN,EAAOxc,SAASqP,IAAWoN,EAAOzc,SAASqP,KAExF,CACA,GAAIjW,EAAOQ,OAAO2iB,WAAW6U,cAAgBG,EAAgB,CACzD,GAAIn4B,EAAOq4B,YAAcr4B,EAAOQ,OAAO63B,YAAcr4B,EAAOQ,OAAO63B,WAAWC,YAAct4B,EAAOq4B,WAAW17B,KAAO8gB,GAAYzd,EAAOq4B,WAAW17B,GAAG4M,SAASkU,IAAY,OAC3K,IAAI8a,EACAnV,EAAO7qB,OACPggC,EAAWnV,EAAO,GAAG3gB,UAAU8G,SAASvJ,EAAOQ,OAAO2iB,WAAW8U,aAC1D5U,EAAO9qB,SACdggC,EAAWlV,EAAO,GAAG5gB,UAAU8G,SAASvJ,EAAOQ,OAAO2iB,WAAW8U,cAGjEnvB,GADa,IAAbyvB,EACK,iBAEA,kBAET,IAAInV,KAAWC,GAAQhnB,QAAOM,KAAQA,IAAItE,SAAQsE,GAAMA,EAAG8F,UAAU+1B,OAAOx4B,EAAOQ,OAAO2iB,WAAW8U,cACzG,KAEJ,MAKM3Q,EAAU,KACZtnB,EAAOrD,GAAG8F,UAAUC,OAAO1C,EAAOQ,OAAO2iB,WAAW+U,wBAAwB97B,MAAM,MAClF0vB,GAAS,EAEb9zB,OAAO8T,OAAO9L,EAAOmjB,WAAY,CAC7BoE,OAVW,KACXvnB,EAAOrD,GAAG8F,UAAU+G,UAAUxJ,EAAOQ,OAAO2iB,WAAW+U,wBAAwB97B,MAAM,MACrF0oB,IACAxZ,GAAQ,EAQRgc,UACAhc,SACAwZ,OACAgH,WAER,EAUA,SAAoB/rB,GAChB,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,EAAEuB,KACFA,GACA/I,EACJ,MAAM04B,EAAM,oBAqCZ,IAAIC,EApCJ/O,EAAa,CACT0O,WAAY,CACR17B,GAAI,KACJg8B,cAAe,OACfL,WAAW,EACXN,aAAa,EACbY,aAAc,KACdC,kBAAmB,KACnBC,eAAgB,KAChBC,aAAc,KACdC,qBAAqB,EACrBhc,KAAM,UAENic,gBAAgB,EAChBC,mBAAoB,EACpBC,sBAAuBC,GAAUA,EACjCC,oBAAqBD,GAAUA,EAC/BE,YAAa,GAAGb,WAChBc,kBAAmB,GAAGd,kBACtBe,cAAe,GAAGf,KAClBgB,aAAc,GAAGhB,YACjBiB,WAAY,GAAGjB,UACfR,YAAa,GAAGQ,WAChBkB,qBAAsB,GAAGlB,qBACzBmB,yBAA0B,GAAGnB,yBAC7BoB,eAAgB,GAAGpB,cACnBd,UAAW,GAAGc,SACdqB,gBAAiB,GAAGrB,eACpBsB,cAAe,GAAGtB,aAClBuB,wBAAyB,GAAGvB,gBAGpCz4B,EAAOq4B,WAAa,CAChB17B,GAAI,KACJs9B,QAAS,IAGb,IAAIC,EAAqB,EACzB,SAASC,IACL,OAAQn6B,EAAOQ,OAAO63B,WAAW17B,KAAOqD,EAAOq4B,WAAW17B,IAAMgG,MAAMC,QAAQ5C,EAAOq4B,WAAW17B,KAAuC,IAAhCqD,EAAOq4B,WAAW17B,GAAGpE,MAChI,CACA,SAAS6hC,EAAeC,EAAUzD,GAC9B,MAAM2C,kBACFA,GACAv5B,EAAOQ,OAAO63B,WACbgC,IACLA,EAAWA,GAAyB,SAAbzD,EAAsB,WAAa,QAAtC,qBAEhByD,EAAS53B,UAAUC,IAAI,GAAG62B,KAAqB3C,MAC/CyD,EAAWA,GAAyB,SAAbzD,EAAsB,WAAa,QAAtC,oBAEhByD,EAAS53B,UAAUC,IAAI,GAAG62B,KAAqB3C,KAAYA,KAGvE,CACA,SAAS0D,EAAcl2B,GACnB,MAAMi2B,EAAWj2B,EAAElM,OAAO0R,QAAQ+iB,GAAkB3sB,EAAOQ,OAAO63B,WAAWiB,cAC7E,IAAKe,EACD,OAEJj2B,EAAEyY,iBACF,MAAMlU,EAAQjF,EAAa22B,GAAYr6B,EAAOQ,OAAO0O,eACrD,GAAIlP,EAAOQ,OAAO4K,KAAM,CACpB,GAAIpL,EAAOqL,YAAc1C,EAAO,OAChC3I,EAAOyY,YAAY9P,EACvB,MACI3I,EAAO2X,QAAQhP,EAEvB,CACA,SAAS2C,IAEL,MAAMgB,EAAMtM,EAAOsM,IACb9L,EAASR,EAAOQ,OAAO63B,WAC7B,GAAI8B,IAAwB,OAC5B,IAGIp5B,EACAmU,EAJAvY,EAAKqD,EAAOq4B,WAAW17B,GAC3BA,EAAK8H,EAAkB9H,GAIvB,MAAMiQ,EAAe5M,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAAU1M,EAAOyM,QAAQvC,OAAO3R,OAASyH,EAAOkK,OAAO3R,OAC9GgiC,EAAQv6B,EAAOQ,OAAO4K,KAAOjK,KAAKsJ,KAAKmC,EAAe5M,EAAOQ,OAAO0O,gBAAkBlP,EAAO6M,SAAStU,OAY5G,GAXIyH,EAAOQ,OAAO4K,MACd8J,EAAgBlV,EAAOmV,mBAAqB,EAC5CpU,EAAUf,EAAOQ,OAAO0O,eAAiB,EAAI/N,KAAK4N,MAAM/O,EAAOqL,UAAYrL,EAAOQ,OAAO0O,gBAAkBlP,EAAOqL,gBAC/E,IAArBrL,EAAOsQ,WACrBvP,EAAUf,EAAOsQ,UACjB4E,EAAgBlV,EAAOoV,oBAEvBF,EAAgBlV,EAAOkV,eAAiB,EACxCnU,EAAUf,EAAO0K,aAAe,GAGhB,YAAhBlK,EAAOwc,MAAsBhd,EAAOq4B,WAAW4B,SAAWj6B,EAAOq4B,WAAW4B,QAAQ1hC,OAAS,EAAG,CAChG,MAAM0hC,EAAUj6B,EAAOq4B,WAAW4B,QAClC,IAAIO,EACA3gB,EACA4gB,EAsBJ,GArBIj6B,EAAOy4B,iBACPP,EAAar0B,EAAiB41B,EAAQ,GAAIj6B,EAAO0L,eAAiB,QAAU,UAAU,GACtF/O,EAAGtE,SAAQm/B,IACPA,EAAMj+B,MAAMyG,EAAO0L,eAAiB,QAAU,UAAegtB,GAAcl4B,EAAO04B,mBAAqB,GAA7C,IAAmD,IAE7G14B,EAAO04B,mBAAqB,QAAuBx6B,IAAlBwW,IACjCglB,GAAsBn5B,GAAWmU,GAAiB,GAC9CglB,EAAqB15B,EAAO04B,mBAAqB,EACjDgB,EAAqB15B,EAAO04B,mBAAqB,EAC1CgB,EAAqB,IAC5BA,EAAqB,IAG7BM,EAAar5B,KAAKC,IAAIL,EAAUm5B,EAAoB,GACpDrgB,EAAY2gB,GAAcr5B,KAAKE,IAAI44B,EAAQ1hC,OAAQiI,EAAO04B,oBAAsB,GAChFuB,GAAY5gB,EAAY2gB,GAAc,GAE1CP,EAAQ5hC,SAAQgiC,IACZ,MAAMK,EAAkB,IAAI,CAAC,GAAI,QAAS,aAAc,QAAS,aAAc,SAASp9B,KAAI2xB,GAAU,GAAGzuB,EAAO+4B,oBAAoBtK,OAAW3xB,KAAIq9B,GAAkB,iBAANA,GAAkBA,EAAE/zB,SAAS,KAAO+zB,EAAEv+B,MAAM,KAAOu+B,IAAGC,OACrNP,EAAS53B,UAAU+G,UAAUkxB,EAAgB,IAE7C/9B,EAAGpE,OAAS,EACZ0hC,EAAQ5hC,SAAQwiC,IACZ,MAAMC,EAAcp3B,EAAam3B,GAC7BC,IAAgB/5B,EAChB85B,EAAOp4B,UAAUC,OAAOlC,EAAO+4B,kBAAkBn9B,MAAM,MAChD4D,EAAO6J,WACdgxB,EAAOrhC,aAAa,OAAQ,UAE5BgH,EAAOy4B,iBACH6B,GAAeN,GAAcM,GAAejhB,GAC5CghB,EAAOp4B,UAAUC,OAAO,GAAGlC,EAAO+4B,yBAAyBn9B,MAAM,MAEjE0+B,IAAgBN,GAChBJ,EAAeS,EAAQ,QAEvBC,IAAgBjhB,GAChBugB,EAAeS,EAAQ,QAE/B,QAED,CACH,MAAMA,EAASZ,EAAQl5B,GASvB,GARI85B,GACAA,EAAOp4B,UAAUC,OAAOlC,EAAO+4B,kBAAkBn9B,MAAM,MAEvD4D,EAAO6J,WACPowB,EAAQ5hC,SAAQ,CAACgiC,EAAUS,KACvBT,EAAS7gC,aAAa,OAAQshC,IAAgB/5B,EAAU,gBAAkB,SAAS,IAGvFP,EAAOy4B,eAAgB,CACvB,MAAM8B,EAAuBd,EAAQO,GAC/BQ,EAAsBf,EAAQpgB,GACpC,IAAK,IAAIjb,EAAI47B,EAAY57B,GAAKib,EAAWjb,GAAK,EACtCq7B,EAAQr7B,IACRq7B,EAAQr7B,GAAG6D,UAAUC,OAAO,GAAGlC,EAAO+4B,yBAAyBn9B,MAAM,MAG7Eg+B,EAAeW,EAAsB,QACrCX,EAAeY,EAAqB,OACxC,CACJ,CACA,GAAIx6B,EAAOy4B,eAAgB,CACvB,MAAMgC,EAAuB95B,KAAKE,IAAI44B,EAAQ1hC,OAAQiI,EAAO04B,mBAAqB,GAC5EgC,GAAiBxC,EAAauC,EAAuBvC,GAAc,EAAI+B,EAAW/B,EAClF5G,EAAaxlB,EAAM,QAAU,OACnC2tB,EAAQ5hC,SAAQwiC,IACZA,EAAOthC,MAAMyG,EAAO0L,eAAiBomB,EAAa,OAAS,GAAGoJ,KAAiB,GAEvF,CACJ,CACAv+B,EAAGtE,SAAQ,CAACm/B,EAAO2D,KASf,GARoB,aAAhB36B,EAAOwc,OACPwa,EAAMx+B,iBAAiB2zB,GAAkBnsB,EAAOi5B,eAAephC,SAAQ+iC,IACnEA,EAAWC,YAAc76B,EAAO24B,sBAAsBp4B,EAAU,EAAE,IAEtEy2B,EAAMx+B,iBAAiB2zB,GAAkBnsB,EAAOk5B,aAAarhC,SAAQijC,IACjEA,EAAQD,YAAc76B,EAAO64B,oBAAoBkB,EAAM,KAG3C,gBAAhB/5B,EAAOwc,KAAwB,CAC/B,IAAIue,EAEAA,EADA/6B,EAAOw4B,oBACgBh5B,EAAO0L,eAAiB,WAAa,aAErC1L,EAAO0L,eAAiB,aAAe,WAElE,MAAM8vB,GAASz6B,EAAU,GAAKw5B,EAC9B,IAAIkB,EAAS,EACTC,EAAS,EACgB,eAAzBH,EACAE,EAASD,EAETE,EAASF,EAEbhE,EAAMx+B,iBAAiB2zB,GAAkBnsB,EAAOm5B,uBAAuBthC,SAAQsjC,IAC3EA,EAAWpiC,MAAM6D,UAAY,6BAA6Bq+B,aAAkBC,KAC5EC,EAAWpiC,MAAMysB,mBAAqB,GAAGhmB,EAAOQ,OAAOC,SAAS,GAExE,CACoB,WAAhBD,EAAOwc,MAAqBxc,EAAOu4B,cACnCvB,EAAMzK,UAAYvsB,EAAOu4B,aAAa/4B,EAAQe,EAAU,EAAGw5B,GACxC,IAAfY,GAAkBryB,EAAK,mBAAoB0uB,KAE5B,IAAf2D,GAAkBryB,EAAK,mBAAoB0uB,GAC/C1uB,EAAK,mBAAoB0uB,IAEzBx3B,EAAOQ,OAAOkQ,eAAiB1Q,EAAO0M,SACtC8qB,EAAM/0B,UAAUzC,EAAOmmB,SAAW,MAAQ,UAAU3lB,EAAOm3B,UAC/D,GAER,CACA,SAASiE,IAEL,MAAMp7B,EAASR,EAAOQ,OAAO63B,WAC7B,GAAI8B,IAAwB,OAC5B,MAAMvtB,EAAe5M,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAAU1M,EAAOyM,QAAQvC,OAAO3R,OAASyH,EAAO2K,MAAQ3K,EAAOQ,OAAOmK,KAAKC,KAAO,EAAI5K,EAAOkK,OAAO3R,OAAS4I,KAAKsJ,KAAKzK,EAAOQ,OAAOmK,KAAKC,MAAQ5K,EAAOkK,OAAO3R,OAC7N,IAAIoE,EAAKqD,EAAOq4B,WAAW17B,GAC3BA,EAAK8H,EAAkB9H,GACvB,IAAIk/B,EAAiB,GACrB,GAAoB,YAAhBr7B,EAAOwc,KAAoB,CAC3B,IAAI8e,EAAkB97B,EAAOQ,OAAO4K,KAAOjK,KAAKsJ,KAAKmC,EAAe5M,EAAOQ,OAAO0O,gBAAkBlP,EAAO6M,SAAStU,OAChHyH,EAAOQ,OAAOsf,UAAY9f,EAAOQ,OAAOsf,SAASpT,SAAWovB,EAAkBlvB,IAC9EkvB,EAAkBlvB,GAEtB,IAAK,IAAIhO,EAAI,EAAGA,EAAIk9B,EAAiBl9B,GAAK,EAClC4B,EAAOo4B,aACPiD,GAAkBr7B,EAAOo4B,aAAav6B,KAAK2B,EAAQpB,EAAG4B,EAAO84B,aAG7DuC,GAAkB,IAAIr7B,EAAOm4B,iBAAiB34B,EAAO6J,UAAY,gBAAkB,aAAarJ,EAAO84B,kBAAkB94B,EAAOm4B,gBAG5I,CACoB,aAAhBn4B,EAAOwc,OAEH6e,EADAr7B,EAAOs4B,eACUt4B,EAAOs4B,eAAez6B,KAAK2B,EAAQQ,EAAOi5B,aAAcj5B,EAAOk5B,YAE/D,gBAAgBl5B,EAAOi5B,wCAAkDj5B,EAAOk5B,uBAGrF,gBAAhBl5B,EAAOwc,OAEH6e,EADAr7B,EAAOq4B,kBACUr4B,EAAOq4B,kBAAkBx6B,KAAK2B,EAAQQ,EAAOm5B,sBAE7C,gBAAgBn5B,EAAOm5B,iCAGhD35B,EAAOq4B,WAAW4B,QAAU,GAC5Bt9B,EAAGtE,SAAQm/B,IACa,WAAhBh3B,EAAOwc,OACPwa,EAAMzK,UAAY8O,GAAkB,IAEpB,YAAhBr7B,EAAOwc,MACPhd,EAAOq4B,WAAW4B,QAAQh2B,QAAQuzB,EAAMx+B,iBAAiB2zB,GAAkBnsB,EAAO84B,cACtF,IAEgB,WAAhB94B,EAAOwc,MACPlU,EAAK,mBAAoBnM,EAAG,GAEpC,CACA,SAASmoB,IACL9kB,EAAOQ,OAAO63B,WAAa5L,GAA0BzsB,EAAQA,EAAO6mB,eAAewR,WAAYr4B,EAAOQ,OAAO63B,WAAY,CACrH17B,GAAI,sBAER,MAAM6D,EAASR,EAAOQ,OAAO63B,WAC7B,IAAK73B,EAAO7D,GAAI,OAChB,IAAIA,EACqB,iBAAd6D,EAAO7D,IAAmBqD,EAAO6J,YACxClN,EAAKqD,EAAOrD,GAAG5D,cAAcyH,EAAO7D,KAEnCA,GAA2B,iBAAd6D,EAAO7D,KACrBA,EAAK,IAAIpC,SAASvB,iBAAiBwH,EAAO7D,MAEzCA,IACDA,EAAK6D,EAAO7D,IAEXA,GAAoB,IAAdA,EAAGpE,SACVyH,EAAOQ,OAAO6kB,mBAA0C,iBAAd7kB,EAAO7D,IAAmBgG,MAAMC,QAAQjG,IAAOA,EAAGpE,OAAS,IACrGoE,EAAK,IAAIqD,EAAOrD,GAAG3D,iBAAiBwH,EAAO7D,KAEvCA,EAAGpE,OAAS,IACZoE,EAAKA,EAAGN,QAAOm7B,GACP3zB,EAAe2zB,EAAO,WAAW,KAAOx3B,EAAOrD,KAEpD,KAGPgG,MAAMC,QAAQjG,IAAqB,IAAdA,EAAGpE,SAAcoE,EAAKA,EAAG,IAClD3E,OAAO8T,OAAO9L,EAAOq4B,WAAY,CAC7B17B,OAEJA,EAAK8H,EAAkB9H,GACvBA,EAAGtE,SAAQm/B,IACa,YAAhBh3B,EAAOwc,MAAsBxc,EAAO83B,WACpCd,EAAM/0B,UAAUC,QAAQlC,EAAOq5B,gBAAkB,IAAIz9B,MAAM,MAE/Do7B,EAAM/0B,UAAUC,IAAIlC,EAAOg5B,cAAgBh5B,EAAOwc,MAClDwa,EAAM/0B,UAAUC,IAAI1C,EAAO0L,eAAiBlL,EAAOs5B,gBAAkBt5B,EAAOu5B,eACxD,YAAhBv5B,EAAOwc,MAAsBxc,EAAOy4B,iBACpCzB,EAAM/0B,UAAUC,IAAI,GAAGlC,EAAOg5B,gBAAgBh5B,EAAOwc,gBACrDkd,EAAqB,EACjB15B,EAAO04B,mBAAqB,IAC5B14B,EAAO04B,mBAAqB,IAGhB,gBAAhB14B,EAAOwc,MAA0Bxc,EAAOw4B,qBACxCxB,EAAM/0B,UAAUC,IAAIlC,EAAOo5B,0BAE3Bp5B,EAAO83B,WACPd,EAAM9+B,iBAAiB,QAAS4hC,GAE/Bt6B,EAAO0M,SACR8qB,EAAM/0B,UAAUC,IAAIlC,EAAOm3B,UAC/B,IAER,CACA,SAAS7L,IACL,MAAMtrB,EAASR,EAAOQ,OAAO63B,WAC7B,GAAI8B,IAAwB,OAC5B,IAAIx9B,EAAKqD,EAAOq4B,WAAW17B,GACvBA,IACAA,EAAK8H,EAAkB9H,GACvBA,EAAGtE,SAAQm/B,IACPA,EAAM/0B,UAAU+G,OAAOhJ,EAAOy3B,aAC9BT,EAAM/0B,UAAU+G,OAAOhJ,EAAOg5B,cAAgBh5B,EAAOwc,MACrDwa,EAAM/0B,UAAU+G,OAAOxJ,EAAO0L,eAAiBlL,EAAOs5B,gBAAkBt5B,EAAOu5B,eAC3Ev5B,EAAO83B,YACPd,EAAM/0B,UAAU+G,WAAWhJ,EAAOq5B,gBAAkB,IAAIz9B,MAAM,MAC9Do7B,EAAM7+B,oBAAoB,QAAS2hC,GACvC,KAGJt6B,EAAOq4B,WAAW4B,SAASj6B,EAAOq4B,WAAW4B,QAAQ5hC,SAAQm/B,GAASA,EAAM/0B,UAAU+G,UAAUhJ,EAAO+4B,kBAAkBn9B,MAAM,OACvI,CACAmL,EAAG,mBAAmB,KAClB,IAAKvH,EAAOq4B,aAAer4B,EAAOq4B,WAAW17B,GAAI,OACjD,MAAM6D,EAASR,EAAOQ,OAAO63B,WAC7B,IAAI17B,GACAA,GACAqD,EAAOq4B,WACX17B,EAAK8H,EAAkB9H,GACvBA,EAAGtE,SAAQm/B,IACPA,EAAM/0B,UAAU+G,OAAOhJ,EAAOs5B,gBAAiBt5B,EAAOu5B,eACtDvC,EAAM/0B,UAAUC,IAAI1C,EAAO0L,eAAiBlL,EAAOs5B,gBAAkBt5B,EAAOu5B,cAAc,GAC5F,IAENxyB,EAAG,QAAQ,MACkC,IAArCvH,EAAOQ,OAAO63B,WAAW3rB,QAEzB4a,KAEAxC,IACA8W,IACAtwB,IACJ,IAEJ/D,EAAG,qBAAqB,UACY,IAArBvH,EAAOsQ,WACdhF,GACJ,IAEJ/D,EAAG,mBAAmB,KAClB+D,GAAQ,IAEZ/D,EAAG,wBAAwB,KACvBq0B,IACAtwB,GAAQ,IAEZ/D,EAAG,WAAW,KACVukB,GAAS,IAEbvkB,EAAG,kBAAkB,KACjB,IAAI5K,GACAA,GACAqD,EAAOq4B,WACP17B,IACAA,EAAK8H,EAAkB9H,GACvBA,EAAGtE,SAAQm/B,GAASA,EAAM/0B,UAAUzC,EAAO0M,QAAU,SAAW,OAAO1M,EAAOQ,OAAO63B,WAAWV,aACpG,IAEJpwB,EAAG,eAAe,KACd+D,GAAQ,IAEZ/D,EAAG,SAAS,CAAC4mB,EAAI/pB,KACb,MAAMqZ,EAAWrZ,EAAElM,OACbyE,EAAK8H,EAAkBzE,EAAOq4B,WAAW17B,IAC/C,GAAIqD,EAAOQ,OAAO63B,WAAW17B,IAAMqD,EAAOQ,OAAO63B,WAAWL,aAAer7B,GAAMA,EAAGpE,OAAS,IAAMklB,EAAShb,UAAU8G,SAASvJ,EAAOQ,OAAO63B,WAAWiB,aAAc,CAClK,GAAIt5B,EAAOmjB,aAAenjB,EAAOmjB,WAAWC,QAAU3F,IAAazd,EAAOmjB,WAAWC,QAAUpjB,EAAOmjB,WAAWE,QAAU5F,IAAazd,EAAOmjB,WAAWE,QAAS,OACnK,MAAMkV,EAAW57B,EAAG,GAAG8F,UAAU8G,SAASvJ,EAAOQ,OAAO63B,WAAWJ,aAE/DnvB,GADa,IAAbyvB,EACK,iBAEA,kBAET57B,EAAGtE,SAAQm/B,GAASA,EAAM/0B,UAAU+1B,OAAOx4B,EAAOQ,OAAO63B,WAAWJ,cACxE,KAEJ,MAaM3Q,EAAU,KACZtnB,EAAOrD,GAAG8F,UAAUC,IAAI1C,EAAOQ,OAAO63B,WAAW2B,yBACjD,IAAIr9B,GACAA,GACAqD,EAAOq4B,WACP17B,IACAA,EAAK8H,EAAkB9H,GACvBA,EAAGtE,SAAQm/B,GAASA,EAAM/0B,UAAUC,IAAI1C,EAAOQ,OAAO63B,WAAW2B,4BAErElO,GAAS,EAEb9zB,OAAO8T,OAAO9L,EAAOq4B,WAAY,CAC7B9Q,OAzBW,KACXvnB,EAAOrD,GAAG8F,UAAU+G,OAAOxJ,EAAOQ,OAAO63B,WAAW2B,yBACpD,IAAIr9B,GACAA,GACAqD,EAAOq4B,WACP17B,IACAA,EAAK8H,EAAkB9H,GACvBA,EAAGtE,SAAQm/B,GAASA,EAAM/0B,UAAU+G,OAAOxJ,EAAOQ,OAAO63B,WAAW2B,4BAExElV,IACA8W,IACAtwB,GAAQ,EAeRgc,UACAsU,SACAtwB,SACAwZ,OACAgH,WAER,EAEA,SAAmB/rB,GACf,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,EAAEuB,KACFA,GACA/I,EACJ,MAAMxF,EAAWF,IACjB,IAGI0hC,EACAC,EACAC,EACAC,EANAre,GAAY,EACZuW,EAAU,KACV+H,EAAc,KAuBlB,SAAS3lB,IACL,IAAKxW,EAAOQ,OAAO47B,UAAUz/B,KAAOqD,EAAOo8B,UAAUz/B,GAAI,OACzD,MAAMy/B,UACFA,EACA/vB,aAAcC,GACdtM,GACEq8B,OACFA,EAAM1/B,GACNA,GACAy/B,EACE57B,EAASR,EAAOQ,OAAO47B,UACvBl7B,EAAWlB,EAAOQ,OAAO4K,KAAOpL,EAAOmT,aAAenT,EAAOkB,SACnE,IAAIo7B,EAAUN,EACVO,GAAUN,EAAYD,GAAY96B,EAClCoL,GACAiwB,GAAUA,EACNA,EAAS,GACTD,EAAUN,EAAWO,EACrBA,EAAS,IACDA,EAASP,EAAWC,IAC5BK,EAAUL,EAAYM,IAEnBA,EAAS,GAChBD,EAAUN,EAAWO,EACrBA,EAAS,GACFA,EAASP,EAAWC,IAC3BK,EAAUL,EAAYM,GAEtBv8B,EAAO0L,gBACP2wB,EAAO9iC,MAAM6D,UAAY,eAAem/B,aACxCF,EAAO9iC,MAAMqM,MAAQ,GAAG02B,QAExBD,EAAO9iC,MAAM6D,UAAY,oBAAoBm/B,UAC7CF,EAAO9iC,MAAMuM,OAAS,GAAGw2B,OAEzB97B,EAAOg8B,OACPhhC,aAAa44B,GACbz3B,EAAGpD,MAAMkjC,QAAU,EACnBrI,EAAU74B,YAAW,KACjBoB,EAAGpD,MAAMkjC,QAAU,EACnB9/B,EAAGpD,MAAMysB,mBAAqB,OAAO,GACtC,KAEX,CAKA,SAASza,IACL,IAAKvL,EAAOQ,OAAO47B,UAAUz/B,KAAOqD,EAAOo8B,UAAUz/B,GAAI,OACzD,MAAMy/B,UACFA,GACAp8B,GACEq8B,OACFA,EAAM1/B,GACNA,GACAy/B,EACJC,EAAO9iC,MAAMqM,MAAQ,GACrBy2B,EAAO9iC,MAAMuM,OAAS,GACtBm2B,EAAYj8B,EAAO0L,eAAiB/O,EAAG6H,YAAc7H,EAAG8U,aACxDyqB,EAAUl8B,EAAOsE,MAAQtE,EAAOyN,YAAczN,EAAOQ,OAAOyM,oBAAsBjN,EAAOQ,OAAOsN,eAAiB9N,EAAO6M,SAAS,GAAK,IAElImvB,EADqC,SAArCh8B,EAAOQ,OAAO47B,UAAUJ,SACbC,EAAYC,EAEZtwB,SAAS5L,EAAOQ,OAAO47B,UAAUJ,SAAU,IAEtDh8B,EAAO0L,eACP2wB,EAAO9iC,MAAMqM,MAAQ,GAAGo2B,MAExBK,EAAO9iC,MAAMuM,OAAS,GAAGk2B,MAGzBr/B,EAAGpD,MAAMmjC,QADTR,GAAW,EACQ,OAEA,GAEnBl8B,EAAOQ,OAAO47B,UAAUI,OACxB7/B,EAAGpD,MAAMkjC,QAAU,GAEnBz8B,EAAOQ,OAAOkQ,eAAiB1Q,EAAO0M,SACtC0vB,EAAUz/B,GAAG8F,UAAUzC,EAAOmmB,SAAW,MAAQ,UAAUnmB,EAAOQ,OAAO47B,UAAUzE,UAE3F,CACA,SAASgF,EAAmBv4B,GACxB,OAAOpE,EAAO0L,eAAiBtH,EAAEw4B,QAAUx4B,EAAEy4B,OACjD,CACA,SAASC,EAAgB14B,GACrB,MAAMg4B,UACFA,EACA/vB,aAAcC,GACdtM,GACErD,GACFA,GACAy/B,EACJ,IAAIW,EACJA,GAAiBJ,EAAmBv4B,GAAKvB,EAAclG,GAAIqD,EAAO0L,eAAiB,OAAS,QAA2B,OAAjBqwB,EAAwBA,EAAeC,EAAW,KAAOC,EAAYD,GAC3Ke,EAAgB57B,KAAKC,IAAID,KAAKE,IAAI07B,EAAe,GAAI,GACjDzwB,IACAywB,EAAgB,EAAIA,GAExB,MAAMnG,EAAW52B,EAAOoS,gBAAkBpS,EAAOgT,eAAiBhT,EAAOoS,gBAAkB2qB,EAC3F/8B,EAAO6S,eAAe+jB,GACtB52B,EAAOwW,aAAaogB,GACpB52B,EAAOgV,oBACPhV,EAAO+T,qBACX,CACA,SAASipB,EAAY54B,GACjB,MAAM5D,EAASR,EAAOQ,OAAO47B,WACvBA,UACFA,EAAS17B,UACTA,GACAV,GACErD,GACFA,EAAE0/B,OACFA,GACAD,EACJve,GAAY,EACZke,EAAe33B,EAAElM,SAAWmkC,EAASM,EAAmBv4B,GAAKA,EAAElM,OAAO6K,wBAAwB/C,EAAO0L,eAAiB,OAAS,OAAS,KACxItH,EAAEyY,iBACFzY,EAAE2c,kBACFrgB,EAAUnH,MAAMysB,mBAAqB,QACrCqW,EAAO9iC,MAAMysB,mBAAqB,QAClC8W,EAAgB14B,GAChB5I,aAAa2gC,GACbx/B,EAAGpD,MAAMysB,mBAAqB,MAC1BxlB,EAAOg8B,OACP7/B,EAAGpD,MAAMkjC,QAAU,GAEnBz8B,EAAOQ,OAAOuN,UACd/N,EAAOU,UAAUnH,MAAM,oBAAsB,QAEjDuP,EAAK,qBAAsB1E,EAC/B,CACA,SAAS64B,EAAW74B,GAChB,MAAMg4B,UACFA,EAAS17B,UACTA,GACAV,GACErD,GACFA,EAAE0/B,OACFA,GACAD,EACCve,IACDzZ,EAAEyY,gBAAkBzY,EAAEwc,WAAYxc,EAAEyY,iBAAsBzY,EAAE+vB,aAAc,EAC9E2I,EAAgB14B,GAChB1D,EAAUnH,MAAMysB,mBAAqB,MACrCrpB,EAAGpD,MAAMysB,mBAAqB,MAC9BqW,EAAO9iC,MAAMysB,mBAAqB,MAClCld,EAAK,oBAAqB1E,GAC9B,CACA,SAAS84B,EAAU94B,GACf,MAAM5D,EAASR,EAAOQ,OAAO47B,WACvBA,UACFA,EAAS17B,UACTA,GACAV,GACErD,GACFA,GACAy/B,EACCve,IACLA,GAAY,EACR7d,EAAOQ,OAAOuN,UACd/N,EAAOU,UAAUnH,MAAM,oBAAsB,GAC7CmH,EAAUnH,MAAMysB,mBAAqB,IAErCxlB,EAAOg8B,OACPhhC,aAAa2gC,GACbA,EAAc5/B,GAAS,KACnBI,EAAGpD,MAAMkjC,QAAU,EACnB9/B,EAAGpD,MAAMysB,mBAAqB,OAAO,GACtC,MAEPld,EAAK,mBAAoB1E,GACrB5D,EAAO28B,eACPn9B,EAAO+Z,iBAEf,CACA,SAASvS,EAAOM,GACZ,MAAMs0B,UACFA,EAAS57B,OACTA,GACAR,EACErD,EAAKy/B,EAAUz/B,GACrB,IAAKA,EAAI,OACT,MAAMzE,EAASyE,EACTygC,IAAiB58B,EAAO8kB,kBAAmB,CAC7CZ,SAAS,EACTH,SAAS,GAEP8Y,IAAkB78B,EAAO8kB,kBAAmB,CAC9CZ,SAAS,EACTH,SAAS,GAEb,IAAKrsB,EAAQ,OACb,MAAMolC,EAAyB,OAAXx1B,EAAkB,mBAAqB,sBAC3D5P,EAAOolC,GAAa,cAAeN,EAAaI,GAChD7iC,EAAS+iC,GAAa,cAAeL,EAAYG,GACjD7iC,EAAS+iC,GAAa,YAAaJ,EAAWG,EAClD,CASA,SAASvY,IACL,MAAMsX,UACFA,EACAz/B,GAAI4gC,GACJv9B,EACJA,EAAOQ,OAAO47B,UAAY3P,GAA0BzsB,EAAQA,EAAO6mB,eAAeuV,UAAWp8B,EAAOQ,OAAO47B,UAAW,CAClHz/B,GAAI,qBAER,MAAM6D,EAASR,EAAOQ,OAAO47B,UAC7B,IAAK57B,EAAO7D,GAAI,OAChB,IAAIA,EAeA0/B,EAXJ,GAHyB,iBAAd77B,EAAO7D,IAAmBqD,EAAO6J,YACxClN,EAAKqD,EAAOrD,GAAG5D,cAAcyH,EAAO7D,KAEnCA,GAA2B,iBAAd6D,EAAO7D,GAGbA,IACRA,EAAK6D,EAAO7D,SAFZ,GADAA,EAAKpC,EAASvB,iBAAiBwH,EAAO7D,KACjCA,EAAGpE,OAAQ,OAIhByH,EAAOQ,OAAO6kB,mBAA0C,iBAAd7kB,EAAO7D,IAAmBA,EAAGpE,OAAS,GAAqD,IAAhDglC,EAASvkC,iBAAiBwH,EAAO7D,IAAIpE,SAC1HoE,EAAK4gC,EAASxkC,cAAcyH,EAAO7D,KAEnCA,EAAGpE,OAAS,IAAGoE,EAAKA,EAAG,IAC3BA,EAAG8F,UAAUC,IAAI1C,EAAO0L,eAAiBlL,EAAOs5B,gBAAkBt5B,EAAOu5B,eAErEp9B,IACA0/B,EAAS1/B,EAAG5D,cAAc4zB,GAAkB3sB,EAAOQ,OAAO47B,UAAUoB,YAC/DnB,IACDA,EAASjjC,EAAc,MAAO4G,EAAOQ,OAAO47B,UAAUoB,WACtD7gC,EAAGie,OAAOyhB,KAGlBrkC,OAAO8T,OAAOswB,EAAW,CACrBz/B,KACA0/B,WAEA77B,EAAOi9B,WA5CNz9B,EAAOQ,OAAO47B,UAAUz/B,IAAOqD,EAAOo8B,UAAUz/B,IACrD6K,EAAO,MA8CH7K,GACAA,EAAG8F,UAAUzC,EAAO0M,QAAU,SAAW,UAAUzQ,EAAgB+D,EAAOQ,OAAO47B,UAAUzE,WAEnG,CACA,SAAS7L,IACL,MAAMtrB,EAASR,EAAOQ,OAAO47B,UACvBz/B,EAAKqD,EAAOo8B,UAAUz/B,GACxBA,GACAA,EAAG8F,UAAU+G,UAAUvN,EAAgB+D,EAAO0L,eAAiBlL,EAAOs5B,gBAAkBt5B,EAAOu5B,gBAnD9F/5B,EAAOQ,OAAO47B,UAAUz/B,IAAOqD,EAAOo8B,UAAUz/B,IACrD6K,EAAO,MAqDX,CApRAmiB,EAAa,CACTyS,UAAW,CACPz/B,GAAI,KACJq/B,SAAU,OACVQ,MAAM,EACNiB,WAAW,EACXN,eAAe,EACfxF,UAAW,wBACX6F,UAAW,wBACXE,uBAAwB,4BACxB5D,gBAAiB,8BACjBC,cAAe,+BAGvB/5B,EAAOo8B,UAAY,CACfz/B,GAAI,KACJ0/B,OAAQ,MAqQZ90B,EAAG,mBAAmB,KAClB,IAAKvH,EAAOo8B,YAAcp8B,EAAOo8B,UAAUz/B,GAAI,OAC/C,MAAM6D,EAASR,EAAOQ,OAAO47B,UAC7B,IAAIz/B,GACAA,GACAqD,EAAOo8B,UACXz/B,EAAK8H,EAAkB9H,GACvBA,EAAGtE,SAAQm/B,IACPA,EAAM/0B,UAAU+G,OAAOhJ,EAAOs5B,gBAAiBt5B,EAAOu5B,eACtDvC,EAAM/0B,UAAUC,IAAI1C,EAAO0L,eAAiBlL,EAAOs5B,gBAAkBt5B,EAAOu5B,cAAc,GAC5F,IAENxyB,EAAG,QAAQ,MACiC,IAApCvH,EAAOQ,OAAO47B,UAAU1vB,QAExB4a,KAEAxC,IACAvZ,IACAiL,IACJ,IAEJjP,EAAG,4DAA4D,KAC3DgE,GAAY,IAEhBhE,EAAG,gBAAgB,KACfiP,GAAc,IAElBjP,EAAG,iBAAiB,CAAC4mB,EAAI5tB,MAnPzB,SAAuBA,GACdP,EAAOQ,OAAO47B,UAAUz/B,IAAOqD,EAAOo8B,UAAUz/B,KACrDqD,EAAOo8B,UAAUC,OAAO9iC,MAAMysB,mBAAqB,GAAGzlB,MAC1D,CAiPI8Q,CAAc9Q,EAAS,IAE3BgH,EAAG,kBAAkB,KACjB,MAAM5K,GACFA,GACAqD,EAAOo8B,UACPz/B,GACAA,EAAG8F,UAAUzC,EAAO0M,QAAU,SAAW,UAAUzQ,EAAgB+D,EAAOQ,OAAO47B,UAAUzE,WAC/F,IAEJpwB,EAAG,WAAW,KACVukB,GAAS,IAEb,MASMxE,EAAU,KACZtnB,EAAOrD,GAAG8F,UAAUC,OAAOzG,EAAgB+D,EAAOQ,OAAO47B,UAAUsB,yBAC/D19B,EAAOo8B,UAAUz/B,IACjBqD,EAAOo8B,UAAUz/B,GAAG8F,UAAUC,OAAOzG,EAAgB+D,EAAOQ,OAAO47B,UAAUsB,yBAEjF5R,GAAS,EAEb9zB,OAAO8T,OAAO9L,EAAOo8B,UAAW,CAC5B7U,OAjBW,KACXvnB,EAAOrD,GAAG8F,UAAU+G,UAAUvN,EAAgB+D,EAAOQ,OAAO47B,UAAUsB,yBAClE19B,EAAOo8B,UAAUz/B,IACjBqD,EAAOo8B,UAAUz/B,GAAG8F,UAAU+G,UAAUvN,EAAgB+D,EAAOQ,OAAO47B,UAAUsB,yBAEpF5Y,IACAvZ,IACAiL,GAAc,EAWd8Q,UACA/b,aACAiL,eACAsO,OACAgH,WAER,EAEA,SAAkB/rB,GACd,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EACJ4pB,EAAa,CACTgU,SAAU,CACNjxB,SAAS,KAGjB,MAAMkxB,EAAmB,2IACnBC,EAAe,CAAClhC,EAAIuE,KACtB,MAAMoL,IACFA,GACAtM,EACEy1B,EAAYnpB,GAAO,EAAI,EACvBwxB,EAAInhC,EAAGiZ,aAAa,yBAA2B,IACrD,IAAIe,EAAIha,EAAGiZ,aAAa,0BACpBgB,EAAIja,EAAGiZ,aAAa,0BACxB,MAAM4lB,EAAQ7+B,EAAGiZ,aAAa,8BACxB6mB,EAAU9/B,EAAGiZ,aAAa,gCAC1BmoB,EAASphC,EAAGiZ,aAAa,+BAqB/B,GApBIe,GAAKC,GACLD,EAAIA,GAAK,IACTC,EAAIA,GAAK,KACF5W,EAAO0L,gBACdiL,EAAImnB,EACJlnB,EAAI,MAEJA,EAAIknB,EACJnnB,EAAI,KAGJA,EADAA,EAAEzX,QAAQ,MAAQ,EACX0M,SAAS+K,EAAG,IAAMzV,EAAWu0B,EAAhC,IAEG9e,EAAIzV,EAAWu0B,EAAlB,KAGJ7e,EADAA,EAAE1X,QAAQ,MAAQ,EACX0M,SAASgL,EAAG,IAAM1V,EAArB,IAEG0V,EAAI1V,EAAP,KAEJ,MAAOu7B,EAA6C,CACpD,MAAMuB,EAAiBvB,GAAWA,EAAU,IAAM,EAAIt7B,KAAK8N,IAAI/N,IAC/DvE,EAAGpD,MAAMkjC,QAAUuB,CACvB,CACA,IAAI5gC,EAAY,eAAeuZ,MAAMC,UACrC,GAAI,MAAO4kB,EAAyC,CAEhDp+B,GAAa,UADQo+B,GAASA,EAAQ,IAAM,EAAIr6B,KAAK8N,IAAI/N,MAE7D,CACA,GAAI68B,SAAiBA,EAA2C,CAE5D3gC,GAAa,WADS2gC,EAAS78B,GAAY,OAE/C,CACAvE,EAAGpD,MAAM6D,UAAYA,CAAS,EAE5BoZ,EAAe,KACjB,MAAM7Z,GACFA,EAAEuN,OACFA,EAAMhJ,SACNA,EAAQ2L,SACRA,EAAQhD,UACRA,GACA7J,EACEi+B,EAAWl8B,EAAgBpF,EAAIihC,GACjC59B,EAAO6J,WACPo0B,EAASh6B,QAAQlC,EAAgB/B,EAAO4rB,OAAQgS,IAEpDK,EAAS5lC,SAAQm/B,IACbqG,EAAarG,EAAOt2B,EAAS,IAEjCgJ,EAAO7R,SAAQ,CAACwJ,EAASgO,KACrB,IAAIsC,EAAgBtQ,EAAQX,SACxBlB,EAAOQ,OAAO0O,eAAiB,GAAqC,SAAhClP,EAAOQ,OAAO+J,gBAClD4H,GAAiBhR,KAAKsJ,KAAKoF,EAAa,GAAK3O,GAAY2L,EAAStU,OAAS,IAE/E4Z,EAAgBhR,KAAKE,IAAIF,KAAKC,IAAI+Q,GAAgB,GAAI,GACtDtQ,EAAQ7I,iBAAiB,GAAG4kC,oCAAmDvlC,SAAQm/B,IACnFqG,EAAarG,EAAOrlB,EAAc,GACpC,GACJ,EAoBN5K,EAAG,cAAc,KACRvH,EAAOQ,OAAOm9B,SAASjxB,UAC5B1M,EAAOQ,OAAOoQ,qBAAsB,EACpC5Q,EAAO6mB,eAAejW,qBAAsB,EAAI,IAEpDrJ,EAAG,QAAQ,KACFvH,EAAOQ,OAAOm9B,SAASjxB,SAC5B8J,GAAc,IAElBjP,EAAG,gBAAgB,KACVvH,EAAOQ,OAAOm9B,SAASjxB,SAC5B8J,GAAc,IAElBjP,EAAG,iBAAiB,CAAC22B,EAAS39B,KACrBP,EAAOQ,OAAOm9B,SAASjxB,SAhCV,SAAUnM,QACX,IAAbA,IACAA,EAAWP,EAAOQ,OAAOC,OAE7B,MAAM9D,GACFA,EAAEivB,OACFA,GACA5rB,EACEi+B,EAAW,IAAIthC,EAAG3D,iBAAiB4kC,IACrC59B,EAAO6J,WACPo0B,EAASh6B,QAAQ2nB,EAAO5yB,iBAAiB4kC,IAE7CK,EAAS5lC,SAAQ8lC,IACb,IAAIC,EAAmBxyB,SAASuyB,EAAWvoB,aAAa,iCAAkC,KAAOrV,EAChF,IAAbA,IAAgB69B,EAAmB,GACvCD,EAAW5kC,MAAMysB,mBAAqB,GAAGoY,KAAoB,GAErE,CAgBI/sB,CAAc9Q,EAAS,GAE/B,EAEA,SAAcR,GACV,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,EAAEuB,KACFA,GACA/I,EACJ,MAAM/D,EAASF,IACf6tB,EAAa,CACT0U,KAAM,CACF3xB,SAAS,EACT4xB,qBAAqB,EACrBC,SAAU,EACVpW,SAAU,EACVqQ,QAAQ,EACRgG,eAAgB,wBAChBC,iBAAkB,yBAG1Bz+B,EAAOq+B,KAAO,CACV3xB,SAAS,GAEb,IAEIgyB,EACAC,EAHAC,EAAe,EACfC,GAAY,EAGhB,MAAMC,EAAU,GACVC,EAAU,CACZC,QAAS,EACTC,QAAS,EACTp9B,aAASnD,EACTwgC,gBAAYxgC,EACZygC,iBAAazgC,EACbiL,aAASjL,EACT0gC,iBAAa1gC,EACb6/B,SAAU,GAERc,EAAQ,CACVxhB,eAAWnf,EACXof,aAASpf,EACTogB,cAAUpgB,EACVqgB,cAAUrgB,EACV4gC,UAAM5gC,EACN6gC,UAAM7gC,EACN8gC,UAAM9gC,EACN+gC,UAAM/gC,EACNkH,WAAOlH,EACPoH,YAAQpH,EACR+d,YAAQ/d,EACRugB,YAAQvgB,EACRghC,aAAc,CAAC,EACfC,eAAgB,CAAC,GAEf5V,EAAW,CACbpT,OAAGjY,EACHkY,OAAGlY,EACHkhC,mBAAelhC,EACfmhC,mBAAenhC,EACfohC,cAAUphC,GAEd,IAsJIqhC,EAtJAvE,EAAQ,EAcZ,SAASwE,IACL,GAAIlB,EAAQvmC,OAAS,EAAG,OAAO,EAC/B,MAAM0nC,EAAKnB,EAAQ,GAAGzhB,MAChB6iB,EAAKpB,EAAQ,GAAG9f,MAChBmhB,EAAKrB,EAAQ,GAAGzhB,MAChB+iB,EAAKtB,EAAQ,GAAG9f,MAEtB,OADiB7d,KAAKqf,MAAM2f,EAAKF,IAAO,GAAKG,EAAKF,IAAO,EAE7D,CACA,SAASG,IACL,MAAM7/B,EAASR,EAAOQ,OAAO69B,KACvBE,EAAWQ,EAAQK,YAAYxpB,aAAa,qBAAuBpV,EAAO+9B,SAChF,GAAI/9B,EAAO89B,qBAAuBS,EAAQp1B,SAAWo1B,EAAQp1B,QAAQ22B,aAAc,CAC/E,MAAMC,EAAgBxB,EAAQp1B,QAAQ22B,aAAevB,EAAQp1B,QAAQnF,YACrE,OAAOrD,KAAKE,IAAIk/B,EAAehC,EACnC,CACA,OAAOA,CACX,CAYA,SAASiC,EAAiBp8B,GACtB,MAAM+V,EAHCna,EAAO6J,UAAY,eAAiB,IAAI7J,EAAOQ,OAAOsJ,aAI7D,QAAI1F,EAAElM,OAAOgK,QAAQiY,IACjBna,EAAOkK,OAAO7N,QAAOwF,GAAWA,EAAQ0H,SAASnF,EAAElM,UAASK,OAAS,CAE7E,CASA,SAASkoC,EAAer8B,GAIpB,GAHsB,UAAlBA,EAAEoZ,aACFshB,EAAQl2B,OAAO,EAAGk2B,EAAQvmC,SAEzBioC,EAAiBp8B,GAAI,OAC1B,MAAM5D,EAASR,EAAOQ,OAAO69B,KAI7B,GAHAK,GAAqB,EACrBC,GAAmB,EACnBG,EAAQ76B,KAAKG,KACT06B,EAAQvmC,OAAS,GAArB,CAKA,GAFAmmC,GAAqB,EACrBK,EAAQ2B,WAAaV,KAChBjB,EAAQl9B,QAAS,CAClBk9B,EAAQl9B,QAAUuC,EAAElM,OAAO0R,QAAQ,IAAI5J,EAAOQ,OAAOsJ,4BAChDi1B,EAAQl9B,UAASk9B,EAAQl9B,QAAU7B,EAAOkK,OAAOlK,EAAO0K,cAC7D,IAAIf,EAAUo1B,EAAQl9B,QAAQ9I,cAAc,IAAIyH,EAAOg+B,kBAUvD,GATI70B,IACAA,EAAUA,EAAQ3Q,iBAAiB,kDAAkD,IAEzF+lC,EAAQp1B,QAAUA,EAEdo1B,EAAQK,YADRz1B,EACsB9F,EAAek7B,EAAQp1B,QAAS,IAAInJ,EAAOg+B,kBAAkB,QAE7D9/B,GAErBqgC,EAAQK,YAET,YADAL,EAAQp1B,aAAUjL,GAGtBqgC,EAAQR,SAAW8B,GACvB,CACA,GAAItB,EAAQp1B,QAAS,CACjB,MAAOq1B,EAASC,GA3DxB,WACI,GAAIH,EAAQvmC,OAAS,EAAG,MAAO,CAC3Boe,EAAG,KACHC,EAAG,MAEP,MAAM9T,EAAMi8B,EAAQp1B,QAAQ5G,wBAC5B,MAAO,EAAE+7B,EAAQ,GAAGzhB,OAASyhB,EAAQ,GAAGzhB,MAAQyhB,EAAQ,GAAGzhB,OAAS,EAAIva,EAAI6T,EAAI3a,EAAOqH,SAAWu7B,GAAeE,EAAQ,GAAG9f,OAAS8f,EAAQ,GAAG9f,MAAQ8f,EAAQ,GAAG9f,OAAS,EAAIlc,EAAI8T,EAAI5a,EAAOmH,SAAWy7B,EAC9M,CAoDmC+B,GAC3B5B,EAAQC,QAAUA,EAClBD,EAAQE,QAAUA,EAClBF,EAAQp1B,QAAQpQ,MAAMysB,mBAAqB,KAC/C,CACA6Y,GAAY,CA5BZ,CA6BJ,CACA,SAAS+B,EAAgBx8B,GACrB,IAAKo8B,EAAiBp8B,GAAI,OAC1B,MAAM5D,EAASR,EAAOQ,OAAO69B,KACvBA,EAAOr+B,EAAOq+B,KACdwC,EAAe/B,EAAQgC,WAAUC,GAAYA,EAAS9jB,YAAc7Y,EAAE6Y,YACxE4jB,GAAgB,IAAG/B,EAAQ+B,GAAgBz8B,GAC3C06B,EAAQvmC,OAAS,IAGrBomC,GAAmB,EACnBI,EAAQiC,UAAYhB,IACfjB,EAAQp1B,UAGb00B,EAAK7C,MAAQuD,EAAQiC,UAAYjC,EAAQ2B,WAAa9B,EAClDP,EAAK7C,MAAQuD,EAAQR,WACrBF,EAAK7C,MAAQuD,EAAQR,SAAW,GAAKF,EAAK7C,MAAQuD,EAAQR,SAAW,IAAM,IAE3EF,EAAK7C,MAAQh7B,EAAO2nB,WACpBkW,EAAK7C,MAAQh7B,EAAO2nB,SAAW,GAAK3nB,EAAO2nB,SAAWkW,EAAK7C,MAAQ,IAAM,IAE7EuD,EAAQp1B,QAAQpQ,MAAM6D,UAAY,4BAA4BihC,EAAK7C,UACvE,CACA,SAASyF,EAAa78B,GAClB,IAAKo8B,EAAiBp8B,GAAI,OAC1B,GAAsB,UAAlBA,EAAEoZ,aAAsC,eAAXpZ,EAAE4Y,KAAuB,OAC1D,MAAMxc,EAASR,EAAOQ,OAAO69B,KACvBA,EAAOr+B,EAAOq+B,KACdwC,EAAe/B,EAAQgC,WAAUC,GAAYA,EAAS9jB,YAAc7Y,EAAE6Y,YACxE4jB,GAAgB,GAAG/B,EAAQl2B,OAAOi4B,EAAc,GAC/CnC,GAAuBC,IAG5BD,GAAqB,EACrBC,GAAmB,EACdI,EAAQp1B,UACb00B,EAAK7C,MAAQr6B,KAAKC,IAAID,KAAKE,IAAIg9B,EAAK7C,MAAOuD,EAAQR,UAAW/9B,EAAO2nB,UACrE4W,EAAQp1B,QAAQpQ,MAAMysB,mBAAqB,GAAGhmB,EAAOQ,OAAOC,UAC5Ds+B,EAAQp1B,QAAQpQ,MAAM6D,UAAY,4BAA4BihC,EAAK7C,SACnEoD,EAAeP,EAAK7C,MACpBqD,GAAY,EACRR,EAAK7C,MAAQ,GAAKuD,EAAQl9B,QAC1Bk9B,EAAQl9B,QAAQY,UAAUC,IAAI,GAAGlC,EAAOi+B,oBACjCJ,EAAK7C,OAAS,GAAKuD,EAAQl9B,SAClCk9B,EAAQl9B,QAAQY,UAAU+G,OAAO,GAAGhJ,EAAOi+B,oBAE5B,IAAfJ,EAAK7C,QACLuD,EAAQC,QAAU,EAClBD,EAAQE,QAAU,EAClBF,EAAQl9B,aAAUnD,IAE1B,CAEA,SAASghB,IACL1f,EAAO+b,gBAAgB4E,iCAAkC,CAC7D,CAkBA,SAASZ,EAAY3b,GACjB,IAAKo8B,EAAiBp8B,KA3H1B,SAAkCA,GAC9B,MAAMnC,EAAW,IAAIjC,EAAOQ,OAAO69B,KAAKG,iBACxC,QAAIp6B,EAAElM,OAAOgK,QAAQD,IACjB,IAAIjC,EAAO4rB,OAAO5yB,iBAAiBiJ,IAAW5F,QAAOyrB,GAAeA,EAAYve,SAASnF,EAAElM,UAASK,OAAS,CAErH,CAsHiC2oC,CAAyB98B,GAClD,OAEJ,MAAMi6B,EAAOr+B,EAAOq+B,KACpB,IAAKU,EAAQp1B,QACT,OAEJ,IAAK01B,EAAMxhB,YAAckhB,EAAQl9B,QAC7B,OAECw9B,EAAMvhB,UACPuhB,EAAMz5B,MAAQm5B,EAAQp1B,QAAQnF,aAAeu6B,EAAQp1B,QAAQ6B,YAC7D6zB,EAAMv5B,OAASi5B,EAAQp1B,QAAQ8H,cAAgBstB,EAAQp1B,QAAQ8B,aAC/D4zB,EAAM5iB,OAAS/f,EAAaqiC,EAAQK,YAAa,MAAQ,EACzDC,EAAMpgB,OAASviB,EAAaqiC,EAAQK,YAAa,MAAQ,EACzDL,EAAQG,WAAaH,EAAQl9B,QAAQ2C,YACrCu6B,EAAQI,YAAcJ,EAAQl9B,QAAQ4P,aACtCstB,EAAQK,YAAY7lC,MAAMysB,mBAAqB,OAGnD,MAAMmb,EAAc9B,EAAMz5B,MAAQy4B,EAAK7C,MACjC4F,EAAe/B,EAAMv5B,OAASu4B,EAAK7C,MACzC6D,EAAMC,KAAOn+B,KAAKE,IAAI09B,EAAQG,WAAa,EAAIiC,EAAc,EAAG,GAChE9B,EAAMG,MAAQH,EAAMC,KACpBD,EAAME,KAAOp+B,KAAKE,IAAI09B,EAAQI,YAAc,EAAIiC,EAAe,EAAG,GAClE/B,EAAMI,MAAQJ,EAAME,KACpBF,EAAMM,eAAehpB,EAAImoB,EAAQvmC,OAAS,EAAIumC,EAAQ,GAAGzhB,MAAQjZ,EAAEiZ,MACnEgiB,EAAMM,eAAe/oB,EAAIkoB,EAAQvmC,OAAS,EAAIumC,EAAQ,GAAG9f,MAAQ5a,EAAE4a,MAKnE,GAJoB7d,KAAKC,IAAID,KAAK8N,IAAIowB,EAAMM,eAAehpB,EAAI0oB,EAAMK,aAAa/oB,GAAIxV,KAAK8N,IAAIowB,EAAMM,eAAe/oB,EAAIyoB,EAAMK,aAAa9oB,IACzH,IACd5W,EAAO4e,YAAa,IAEnBygB,EAAMvhB,UAAY+gB,EAAW,CAC9B,GAAI7+B,EAAO0L,iBAAmBvK,KAAK4N,MAAMswB,EAAMC,QAAUn+B,KAAK4N,MAAMswB,EAAM5iB,SAAW4iB,EAAMM,eAAehpB,EAAI0oB,EAAMK,aAAa/oB,GAAKxV,KAAK4N,MAAMswB,EAAMG,QAAUr+B,KAAK4N,MAAMswB,EAAM5iB,SAAW4iB,EAAMM,eAAehpB,EAAI0oB,EAAMK,aAAa/oB,GAGrO,OAFA0oB,EAAMxhB,WAAY,OAClB6B,IAGJ,IAAK1f,EAAO0L,iBAAmBvK,KAAK4N,MAAMswB,EAAME,QAAUp+B,KAAK4N,MAAMswB,EAAMpgB,SAAWogB,EAAMM,eAAe/oB,EAAIyoB,EAAMK,aAAa9oB,GAAKzV,KAAK4N,MAAMswB,EAAMI,QAAUt+B,KAAK4N,MAAMswB,EAAMpgB,SAAWogB,EAAMM,eAAe/oB,EAAIyoB,EAAMK,aAAa9oB,GAGtO,OAFAyoB,EAAMxhB,WAAY,OAClB6B,GAGR,CACItb,EAAEwc,YACFxc,EAAEyY,iBAENzY,EAAE2c,kBAhEFvlB,aAAaukC,GACb//B,EAAO+b,gBAAgB4E,iCAAkC,EACzDof,EAAwBxkC,YAAW,KAC/BmkB,GAAgB,IA+DpB2f,EAAMvhB,SAAU,EAChB,MAAMujB,GAAchD,EAAK7C,MAAQoD,IAAiBG,EAAQR,SAAWv+B,EAAOQ,OAAO69B,KAAKlW,WAClF6W,QACFA,EAAOC,QACPA,GACAF,EACJM,EAAMvgB,SAAWugB,EAAMM,eAAehpB,EAAI0oB,EAAMK,aAAa/oB,EAAI0oB,EAAM5iB,OAAS4kB,GAAchC,EAAMz5B,MAAkB,EAAVo5B,GAC5GK,EAAMtgB,SAAWsgB,EAAMM,eAAe/oB,EAAIyoB,EAAMK,aAAa9oB,EAAIyoB,EAAMpgB,OAASoiB,GAAchC,EAAMv5B,OAAmB,EAAVm5B,GACzGI,EAAMvgB,SAAWugB,EAAMC,OACvBD,EAAMvgB,SAAWugB,EAAMC,KAAO,GAAKD,EAAMC,KAAOD,EAAMvgB,SAAW,IAAM,IAEvEugB,EAAMvgB,SAAWugB,EAAMG,OACvBH,EAAMvgB,SAAWugB,EAAMG,KAAO,GAAKH,EAAMvgB,SAAWugB,EAAMG,KAAO,IAAM,IAEvEH,EAAMtgB,SAAWsgB,EAAME,OACvBF,EAAMtgB,SAAWsgB,EAAME,KAAO,GAAKF,EAAME,KAAOF,EAAMtgB,SAAW,IAAM,IAEvEsgB,EAAMtgB,SAAWsgB,EAAMI,OACvBJ,EAAMtgB,SAAWsgB,EAAMI,KAAO,GAAKJ,EAAMtgB,SAAWsgB,EAAMI,KAAO,IAAM,IAItE1V,EAAS6V,gBAAe7V,EAAS6V,cAAgBP,EAAMM,eAAehpB,GACtEoT,EAAS8V,gBAAe9V,EAAS8V,cAAgBR,EAAMM,eAAe/oB,GACtEmT,EAAS+V,WAAU/V,EAAS+V,SAAWzkC,KAAKoB,OACjDstB,EAASpT,GAAK0oB,EAAMM,eAAehpB,EAAIoT,EAAS6V,gBAAkBvkC,KAAKoB,MAAQstB,EAAS+V,UAAY,EACpG/V,EAASnT,GAAKyoB,EAAMM,eAAe/oB,EAAImT,EAAS8V,gBAAkBxkC,KAAKoB,MAAQstB,EAAS+V,UAAY,EAChG3+B,KAAK8N,IAAIowB,EAAMM,eAAehpB,EAAIoT,EAAS6V,eAAiB,IAAG7V,EAASpT,EAAI,GAC5ExV,KAAK8N,IAAIowB,EAAMM,eAAe/oB,EAAImT,EAAS8V,eAAiB,IAAG9V,EAASnT,EAAI,GAChFmT,EAAS6V,cAAgBP,EAAMM,eAAehpB,EAC9CoT,EAAS8V,cAAgBR,EAAMM,eAAe/oB,EAC9CmT,EAAS+V,SAAWzkC,KAAKoB,MACzBsiC,EAAQK,YAAY7lC,MAAM6D,UAAY,eAAeiiC,EAAMvgB,eAAeugB,EAAMtgB,eACpF,CAoCA,SAASuiB,IACL,MAAMjD,EAAOr+B,EAAOq+B,KAChBU,EAAQl9B,SAAW7B,EAAO0K,cAAgB1K,EAAOkK,OAAOhL,QAAQ6/B,EAAQl9B,WACpEk9B,EAAQp1B,UACRo1B,EAAQp1B,QAAQpQ,MAAM6D,UAAY,+BAElC2hC,EAAQK,cACRL,EAAQK,YAAY7lC,MAAM6D,UAAY,sBAE1C2hC,EAAQl9B,QAAQY,UAAU+G,OAAO,GAAGxJ,EAAOQ,OAAO69B,KAAKI,oBACvDJ,EAAK7C,MAAQ,EACboD,EAAe,EACfG,EAAQl9B,aAAUnD,EAClBqgC,EAAQp1B,aAAUjL,EAClBqgC,EAAQK,iBAAc1gC,EACtBqgC,EAAQC,QAAU,EAClBD,EAAQE,QAAU,EAE1B,CACA,SAASsC,EAAOn9B,GACZ,MAAMi6B,EAAOr+B,EAAOq+B,KACd79B,EAASR,EAAOQ,OAAO69B,KAC7B,IAAKU,EAAQl9B,QAAS,CACduC,GAAKA,EAAElM,SACP6mC,EAAQl9B,QAAUuC,EAAElM,OAAO0R,QAAQ,IAAI5J,EAAOQ,OAAOsJ,6BAEpDi1B,EAAQl9B,UACL7B,EAAOQ,OAAOiM,SAAWzM,EAAOQ,OAAOiM,QAAQC,SAAW1M,EAAOyM,QACjEsyB,EAAQl9B,QAAUE,EAAgB/B,EAAOmM,SAAU,IAAInM,EAAOQ,OAAOoU,oBAAoB,GAEzFmqB,EAAQl9B,QAAU7B,EAAOkK,OAAOlK,EAAO0K,cAG/C,IAAIf,EAAUo1B,EAAQl9B,QAAQ9I,cAAc,IAAIyH,EAAOg+B,kBACnD70B,IACAA,EAAUA,EAAQ3Q,iBAAiB,kDAAkD,IAEzF+lC,EAAQp1B,QAAUA,EAEdo1B,EAAQK,YADRz1B,EACsB9F,EAAek7B,EAAQp1B,QAAS,IAAInJ,EAAOg+B,kBAAkB,QAE7D9/B,CAE9B,CACA,IAAKqgC,EAAQp1B,UAAYo1B,EAAQK,YAAa,OAM9C,IAAIoC,EACAC,EACAC,EACAC,EACArhB,EACAC,EACAqhB,EACAC,EACAC,EACAC,EACAZ,EACAC,EACAY,EACAC,EACAC,EACAC,EACAjD,EACAC,EAtBAn/B,EAAOQ,OAAOuN,UACd/N,EAAOU,UAAUnH,MAAMoI,SAAW,SAClC3B,EAAOU,UAAUnH,MAAM+qB,YAAc,QAEzCya,EAAQl9B,QAAQY,UAAUC,IAAI,GAAGlC,EAAOi+B,yBAmBJ,IAAzBY,EAAMK,aAAa/oB,GAAqBvS,GAC/Co9B,EAASp9B,EAAEiZ,MACXokB,EAASr9B,EAAE4a,QAEXwiB,EAASnC,EAAMK,aAAa/oB,EAC5B8qB,EAASpC,EAAMK,aAAa9oB,GAEhC,MAAMwrB,EAA8B,iBAANh+B,EAAiBA,EAAI,KAC9B,IAAjBw6B,GAAsBwD,IACtBZ,OAAS9iC,EACT+iC,OAAS/iC,GAEb,MAAM6/B,EAAW8B,IACjBhC,EAAK7C,MAAQ4G,GAAkB7D,EAC/BK,EAAewD,GAAkB7D,GAC7Bn6B,GAAwB,IAAjBw6B,GAAsBwD,GA8B7BR,EAAa,EACbC,EAAa,IA9Bb3C,EAAaH,EAAQl9B,QAAQ2C,YAC7B26B,EAAcJ,EAAQl9B,QAAQ4P,aAC9BiwB,EAAU7+B,EAAck8B,EAAQl9B,SAAS0B,KAAOvH,EAAOqH,QACvDs+B,EAAU9+B,EAAck8B,EAAQl9B,SAASyB,IAAMtH,EAAOmH,QACtDmd,EAAQohB,EAAUxC,EAAa,EAAIsC,EACnCjhB,EAAQohB,EAAUxC,EAAc,EAAIsC,EACpCK,EAAa/C,EAAQp1B,QAAQnF,aAAeu6B,EAAQp1B,QAAQ6B,YAC5Du2B,EAAchD,EAAQp1B,QAAQ8H,cAAgBstB,EAAQp1B,QAAQ8B,aAC9D01B,EAAcW,EAAazD,EAAK7C,MAChC4F,EAAeW,EAAc1D,EAAK7C,MAClCwG,EAAgB7gC,KAAKE,IAAI69B,EAAa,EAAIiC,EAAc,EAAG,GAC3Dc,EAAgB9gC,KAAKE,IAAI89B,EAAc,EAAIiC,EAAe,EAAG,GAC7Dc,GAAiBF,EACjBG,GAAiBF,EACjBL,EAAathB,EAAQ+d,EAAK7C,MAC1BqG,EAAathB,EAAQ8d,EAAK7C,MACtBoG,EAAaI,IACbJ,EAAaI,GAEbJ,EAAaM,IACbN,EAAaM,GAEbL,EAAaI,IACbJ,EAAaI,GAEbJ,EAAaM,IACbN,EAAaM,IAMjBC,GAAiC,IAAf/D,EAAK7C,QACvBuD,EAAQC,QAAU,EAClBD,EAAQE,QAAU,GAEtBF,EAAQK,YAAY7lC,MAAMysB,mBAAqB,QAC/C+Y,EAAQK,YAAY7lC,MAAM6D,UAAY,eAAewkC,QAAiBC,SACtE9C,EAAQp1B,QAAQpQ,MAAMysB,mBAAqB,QAC3C+Y,EAAQp1B,QAAQpQ,MAAM6D,UAAY,4BAA4BihC,EAAK7C,QACvE,CACA,SAAS6G,IACL,MAAMhE,EAAOr+B,EAAOq+B,KACd79B,EAASR,EAAOQ,OAAO69B,KAC7B,IAAKU,EAAQl9B,QAAS,CACd7B,EAAOQ,OAAOiM,SAAWzM,EAAOQ,OAAOiM,QAAQC,SAAW1M,EAAOyM,QACjEsyB,EAAQl9B,QAAUE,EAAgB/B,EAAOmM,SAAU,IAAInM,EAAOQ,OAAOoU,oBAAoB,GAEzFmqB,EAAQl9B,QAAU7B,EAAOkK,OAAOlK,EAAO0K,aAE3C,IAAIf,EAAUo1B,EAAQl9B,QAAQ9I,cAAc,IAAIyH,EAAOg+B,kBACnD70B,IACAA,EAAUA,EAAQ3Q,iBAAiB,kDAAkD,IAEzF+lC,EAAQp1B,QAAUA,EAEdo1B,EAAQK,YADRz1B,EACsB9F,EAAek7B,EAAQp1B,QAAS,IAAInJ,EAAOg+B,kBAAkB,QAE7D9/B,CAE9B,CACKqgC,EAAQp1B,SAAYo1B,EAAQK,cAC7Bp/B,EAAOQ,OAAOuN,UACd/N,EAAOU,UAAUnH,MAAMoI,SAAW,GAClC3B,EAAOU,UAAUnH,MAAM+qB,YAAc,IAEzC+Z,EAAK7C,MAAQ,EACboD,EAAe,EACfG,EAAQK,YAAY7lC,MAAMysB,mBAAqB,QAC/C+Y,EAAQK,YAAY7lC,MAAM6D,UAAY,qBACtC2hC,EAAQp1B,QAAQpQ,MAAMysB,mBAAqB,QAC3C+Y,EAAQp1B,QAAQpQ,MAAM6D,UAAY,8BAClC2hC,EAAQl9B,QAAQY,UAAU+G,OAAO,GAAGhJ,EAAOi+B,oBAC3CM,EAAQl9B,aAAUnD,EAClBqgC,EAAQC,QAAU,EAClBD,EAAQE,QAAU,EACtB,CAGA,SAASqD,EAAWl+B,GAChB,MAAMi6B,EAAOr+B,EAAOq+B,KAChBA,EAAK7C,OAAwB,IAAf6C,EAAK7C,MAEnB6G,IAGAd,EAAOn9B,EAEf,CACA,SAASm+B,IASL,MAAO,CACHlF,kBAToBr9B,EAAOQ,OAAO8kB,kBAAmB,CACrDZ,SAAS,EACTH,SAAS,GAQTie,2BAN8BxiC,EAAOQ,OAAO8kB,kBAAmB,CAC/DZ,SAAS,EACTH,SAAS,GAMjB,CAGA,SAASgD,IACL,MAAM8W,EAAOr+B,EAAOq+B,KACpB,GAAIA,EAAK3xB,QAAS,OAClB2xB,EAAK3xB,SAAU,EACf,MAAM2wB,gBACFA,EAAemF,0BACfA,GACAD,IAGJviC,EAAOU,UAAUhI,iBAAiB,cAAe+nC,EAAgBpD,GACjEr9B,EAAOU,UAAUhI,iBAAiB,cAAekoC,EAAiB4B,GAClE,CAAC,YAAa,gBAAiB,cAAcnqC,SAAQyxB,IACjD9pB,EAAOU,UAAUhI,iBAAiBoxB,EAAWmX,EAAc5D,EAAgB,IAI/Er9B,EAAOU,UAAUhI,iBAAiB,cAAeqnB,EAAayiB,EAClE,CACA,SAASlb,IACL,MAAM+W,EAAOr+B,EAAOq+B,KACpB,IAAKA,EAAK3xB,QAAS,OACnB2xB,EAAK3xB,SAAU,EACf,MAAM2wB,gBACFA,EAAemF,0BACfA,GACAD,IAGJviC,EAAOU,UAAU/H,oBAAoB,cAAe8nC,EAAgBpD,GACpEr9B,EAAOU,UAAU/H,oBAAoB,cAAeioC,EAAiB4B,GACrE,CAAC,YAAa,gBAAiB,cAAcnqC,SAAQyxB,IACjD9pB,EAAOU,UAAU/H,oBAAoBmxB,EAAWmX,EAAc5D,EAAgB,IAIlFr9B,EAAOU,UAAU/H,oBAAoB,cAAeonB,EAAayiB,EACrE,CAngBAxqC,OAAOyqC,eAAeziC,EAAOq+B,KAAM,QAAS,CACxCqE,IAAG,IACQlH,EAEX,GAAAmH,CAAIta,GACA,GAAImT,IAAUnT,EAAO,CACjB,MAAM1e,EAAUo1B,EAAQp1B,QAClB9H,EAAUk9B,EAAQl9B,QACxBiH,EAAK,aAAcuf,EAAO1e,EAAS9H,EACvC,CACA25B,EAAQnT,CACZ,IAyfJ9gB,EAAG,QAAQ,KACHvH,EAAOQ,OAAO69B,KAAK3xB,SACnB6a,GACJ,IAEJhgB,EAAG,WAAW,KACV+f,GAAS,IAEb/f,EAAG,cAAc,CAAC4mB,EAAI/pB,KACbpE,EAAOq+B,KAAK3xB,SA7WrB,SAAsBtI,GAClB,MAAMoB,EAASxF,EAAOwF,OACtB,IAAKu5B,EAAQp1B,QAAS,OACtB,GAAI01B,EAAMxhB,UAAW,OACjBrY,EAAOE,SAAWtB,EAAEwc,YAAYxc,EAAEyY,iBACtCwiB,EAAMxhB,WAAY,EAClB,MAAM9V,EAAQ+2B,EAAQvmC,OAAS,EAAIumC,EAAQ,GAAK16B,EAChDi7B,EAAMK,aAAa/oB,EAAI5O,EAAMsV,MAC7BgiB,EAAMK,aAAa9oB,EAAI7O,EAAMiX,KACjC,CAqWIlC,CAAa1Y,EAAE,IAEnBmD,EAAG,YAAY,CAAC4mB,EAAI/pB,KACXpE,EAAOq+B,KAAK3xB,SAnRrB,WACI,MAAM2xB,EAAOr+B,EAAOq+B,KACpB,IAAKU,EAAQp1B,QAAS,OACtB,IAAK01B,EAAMxhB,YAAcwhB,EAAMvhB,QAG3B,OAFAuhB,EAAMxhB,WAAY,OAClBwhB,EAAMvhB,SAAU,GAGpBuhB,EAAMxhB,WAAY,EAClBwhB,EAAMvhB,SAAU,EAChB,IAAI8kB,EAAoB,IACpBC,EAAoB,IACxB,MAAMC,EAAoB/Y,EAASpT,EAAIisB,EACjCG,EAAe1D,EAAMvgB,SAAWgkB,EAChCE,EAAoBjZ,EAASnT,EAAIisB,EACjCI,EAAe5D,EAAMtgB,SAAWikB,EAGnB,IAAfjZ,EAASpT,IAASisB,EAAoBzhC,KAAK8N,KAAK8zB,EAAe1D,EAAMvgB,UAAYiL,EAASpT,IAC3E,IAAfoT,EAASnT,IAASisB,EAAoB1hC,KAAK8N,KAAKg0B,EAAe5D,EAAMtgB,UAAYgL,EAASnT,IAC9F,MAAMssB,EAAmB/hC,KAAKC,IAAIwhC,EAAmBC,GACrDxD,EAAMvgB,SAAWikB,EACjB1D,EAAMtgB,SAAWkkB,EAEjB,MAAM9B,EAAc9B,EAAMz5B,MAAQy4B,EAAK7C,MACjC4F,EAAe/B,EAAMv5B,OAASu4B,EAAK7C,MACzC6D,EAAMC,KAAOn+B,KAAKE,IAAI09B,EAAQG,WAAa,EAAIiC,EAAc,EAAG,GAChE9B,EAAMG,MAAQH,EAAMC,KACpBD,EAAME,KAAOp+B,KAAKE,IAAI09B,EAAQI,YAAc,EAAIiC,EAAe,EAAG,GAClE/B,EAAMI,MAAQJ,EAAME,KACpBF,EAAMvgB,SAAW3d,KAAKC,IAAID,KAAKE,IAAIg+B,EAAMvgB,SAAUugB,EAAMG,MAAOH,EAAMC,MACtED,EAAMtgB,SAAW5d,KAAKC,IAAID,KAAKE,IAAIg+B,EAAMtgB,SAAUsgB,EAAMI,MAAOJ,EAAME,MACtER,EAAQK,YAAY7lC,MAAMysB,mBAAqB,GAAGkd,MAClDnE,EAAQK,YAAY7lC,MAAM6D,UAAY,eAAeiiC,EAAMvgB,eAAeugB,EAAMtgB,eACpF,CAkPIqD,EAAY,IAEhB7a,EAAG,aAAa,CAAC4mB,EAAI/pB,MACZpE,EAAOkX,WAAalX,EAAOQ,OAAO69B,KAAK3xB,SAAW1M,EAAOq+B,KAAK3xB,SAAW1M,EAAOQ,OAAO69B,KAAK7F,QAC7F8J,EAAWl+B,EACf,IAEJmD,EAAG,iBAAiB,KACZvH,EAAOq+B,KAAK3xB,SAAW1M,EAAOQ,OAAO69B,KAAK3xB,SAC1C40B,GACJ,IAEJ/5B,EAAG,eAAe,KACVvH,EAAOq+B,KAAK3xB,SAAW1M,EAAOQ,OAAO69B,KAAK3xB,SAAW1M,EAAOQ,OAAOuN,SACnEuzB,GACJ,IAEJtpC,OAAO8T,OAAO9L,EAAOq+B,KAAM,CACvB9W,SACAD,UACA6b,GAAI5B,EACJ6B,IAAKf,EACL7J,OAAQ8J,GAEhB,EAGA,SAAoBviC,GAChB,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EAYJ,SAASsjC,EAAa1sB,EAAGC,GACrB,MAAM0sB,EAAe,WACjB,IAAIC,EACAC,EACAC,EACJ,MAAO,CAACC,EAAOlqB,KAGX,IAFAgqB,GAAY,EACZD,EAAWG,EAAMnrC,OACVgrC,EAAWC,EAAW,GACzBC,EAAQF,EAAWC,GAAY,EAC3BE,EAAMD,IAAUjqB,EAChBgqB,EAAWC,EAEXF,EAAWE,EAGnB,OAAOF,CAAQ,CAEvB,CAjBqB,GAwBrB,IAAII,EACAC,EAYJ,OAnBA3oC,KAAK0b,EAAIA,EACT1b,KAAK2b,EAAIA,EACT3b,KAAK4e,UAAYlD,EAAEpe,OAAS,EAM5B0C,KAAK4oC,YAAc,SAAqB1D,GACpC,OAAKA,GAGLyD,EAAKN,EAAaroC,KAAK0b,EAAGwpB,GAC1BwD,EAAKC,EAAK,GAIFzD,EAAKllC,KAAK0b,EAAEgtB,KAAQ1oC,KAAK2b,EAAEgtB,GAAM3oC,KAAK2b,EAAE+sB,KAAQ1oC,KAAK0b,EAAEitB,GAAM3oC,KAAK0b,EAAEgtB,IAAO1oC,KAAK2b,EAAE+sB,IAR1E,CASpB,EACO1oC,IACX,CA8EA,SAAS6oC,IACA9jC,EAAOkc,WAAWC,SACnBnc,EAAOkc,WAAW6nB,SAClB/jC,EAAOkc,WAAW6nB,YAASrlC,SACpBsB,EAAOkc,WAAW6nB,OAEjC,CAtIApa,EAAa,CACTzN,WAAY,CACRC,aAASzd,EACTslC,SAAS,EACTC,GAAI,WAIZjkC,EAAOkc,WAAa,CAChBC,aAASzd,GA8Hb6I,EAAG,cAAc,KACb,GAAsB,oBAAXvL,SAEqC,iBAArCgE,EAAOQ,OAAO0b,WAAWC,SAAwBnc,EAAOQ,OAAO0b,WAAWC,mBAAmBpd,aAFxG,CAGI,MAAMmlC,EAAiB3pC,SAASxB,cAAciH,EAAOQ,OAAO0b,WAAWC,SACvE,GAAI+nB,GAAkBA,EAAelkC,OACjCA,EAAOkc,WAAWC,QAAU+nB,EAAelkC,YACxC,GAAIkkC,EAAgB,CACvB,MAAMC,EAAqB//B,IACvBpE,EAAOkc,WAAWC,QAAU/X,EAAEqd,OAAO,GACrCzhB,EAAOsL,SACP44B,EAAevrC,oBAAoB,OAAQwrC,EAAmB,EAElED,EAAexrC,iBAAiB,OAAQyrC,EAC5C,CAEJ,MACAnkC,EAAOkc,WAAWC,QAAUnc,EAAOQ,OAAO0b,WAAWC,OAAO,IAEhE5U,EAAG,UAAU,KACTu8B,GAAc,IAElBv8B,EAAG,UAAU,KACTu8B,GAAc,IAElBv8B,EAAG,kBAAkB,KACjBu8B,GAAc,IAElBv8B,EAAG,gBAAgB,CAAC4mB,EAAI/tB,EAAWqW,KAC1BzW,EAAOkc,WAAWC,UAAWnc,EAAOkc,WAAWC,QAAQtU,WAC5D7H,EAAOkc,WAAW1F,aAAapW,EAAWqW,EAAa,IAE3DlP,EAAG,iBAAiB,CAAC4mB,EAAI5tB,EAAUkW,KAC1BzW,EAAOkc,WAAWC,UAAWnc,EAAOkc,WAAWC,QAAQtU,WAC5D7H,EAAOkc,WAAW7K,cAAc9Q,EAAUkW,EAAa,IAE3Dze,OAAO8T,OAAO9L,EAAOkc,WAAY,CAC7B1F,aAtHJ,SAAsB4tB,EAAI3tB,GACtB,MAAM4tB,EAAarkC,EAAOkc,WAAWC,QACrC,IAAIrJ,EACAwxB,EACJ,MAAM1sC,EAASoI,EAAOjI,YACtB,SAASwsC,EAAuBjoC,GAC5B,GAAIA,EAAEuL,UAAW,OAMjB,MAAMzH,EAAYJ,EAAOqM,cAAgBrM,EAAOI,UAAYJ,EAAOI,UAC/B,UAAhCJ,EAAOQ,OAAO0b,WAAW+nB,MAhBrC,SAAgC3nC,GAC5B0D,EAAOkc,WAAW6nB,OAAS/jC,EAAOQ,OAAO4K,KAAO,IAAIi4B,EAAarjC,EAAO8M,WAAYxQ,EAAEwQ,YAAc,IAAIu2B,EAAarjC,EAAO6M,SAAUvQ,EAAEuQ,SAC5I,CAeY23B,CAAuBloC,GAGvBgoC,GAAuBtkC,EAAOkc,WAAW6nB,OAAOF,aAAazjC,IAE5DkkC,GAAuD,cAAhCtkC,EAAOQ,OAAO0b,WAAW+nB,KACjDnxB,GAAcxW,EAAE0W,eAAiB1W,EAAE8V,iBAAmBpS,EAAOgT,eAAiBhT,EAAOoS,iBACjFpL,OAAO6E,MAAMiH,IAAgB9L,OAAOy9B,SAAS3xB,KAC7CA,EAAa,GAEjBwxB,GAAuBlkC,EAAYJ,EAAOoS,gBAAkBU,EAAaxW,EAAE8V,gBAE3EpS,EAAOQ,OAAO0b,WAAW8nB,UACzBM,EAAsBhoC,EAAE0W,eAAiBsxB,GAE7ChoC,EAAEuW,eAAeyxB,GACjBhoC,EAAEka,aAAa8tB,EAAqBtkC,GACpC1D,EAAE0Y,oBACF1Y,EAAEyX,qBACN,CACA,GAAIpR,MAAMC,QAAQyhC,GACd,IAAK,IAAIzlC,EAAI,EAAGA,EAAIylC,EAAW9rC,OAAQqG,GAAK,EACpCylC,EAAWzlC,KAAO6X,GAAgB4tB,EAAWzlC,aAAchH,GAC3D2sC,EAAuBF,EAAWzlC,SAGnCylC,aAAsBzsC,GAAU6e,IAAiB4tB,GACxDE,EAAuBF,EAE/B,EA4EIhzB,cA3EJ,SAAuB9Q,EAAUkW,GAC7B,MAAM7e,EAASoI,EAAOjI,YAChBssC,EAAarkC,EAAOkc,WAAWC,QACrC,IAAIvd,EACJ,SAAS8lC,EAAwBpoC,GACzBA,EAAEuL,YACNvL,EAAE+U,cAAc9Q,EAAUP,GACT,IAAbO,IACAjE,EAAE4b,kBACE5b,EAAEkE,OAAOsT,YACTvX,GAAS,KACLD,EAAE4U,kBAAkB,IAG5BhN,EAAqB5H,EAAEoE,WAAW,KACzB2jC,GACL/nC,EAAE6b,eAAe,KAG7B,CACA,GAAIxV,MAAMC,QAAQyhC,GACd,IAAKzlC,EAAI,EAAGA,EAAIylC,EAAW9rC,OAAQqG,GAAK,EAChCylC,EAAWzlC,KAAO6X,GAAgB4tB,EAAWzlC,aAAchH,GAC3D8sC,EAAwBL,EAAWzlC,SAGpCylC,aAAsBzsC,GAAU6e,IAAiB4tB,GACxDK,EAAwBL,EAEhC,GAgDJ,EAEA,SAActkC,GACV,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EACJ4pB,EAAa,CACTgb,KAAM,CACFj4B,SAAS,EACTk4B,kBAAmB,sBACnBC,iBAAkBC,GAAGC,QAAQ,6BAC7BC,iBAAkBF,GAAGC,QAAQ,6BAC7BE,kBAAmBH,GAAGC,QAAQ,8BAC9BG,iBAAkBJ,GAAGC,QAAQ,6BAC7BI,wBAAyBL,GAAGC,QAAQ,oCACpCK,kBAAmB,+BACnBC,iBAAkB,KAClBC,gCAAiC,KACjCC,2BAA4B,KAC5BC,UAAW,QACX3pC,GAAI,QAGZmE,EAAO2kC,KAAO,CACVc,SAAS,GAEb,IACIC,EACAC,EAFAC,EAAa,KAGbC,GAA6B,IAAIxqC,MAAO4F,UAC5C,SAAS6kC,EAAOf,GACZ,MAAMgB,EAAeH,EACO,IAAxBG,EAAaxtC,SACjBwtC,EAAahZ,UAAY,GACzBgZ,EAAahZ,UAAYgY,EAC7B,CAQA,SAASiB,EAAgBrpC,IACrBA,EAAK8H,EAAkB9H,IACpBtE,SAAQm/B,IACPA,EAAMh+B,aAAa,WAAY,IAAI,GAE3C,CACA,SAASysC,EAAmBtpC,IACxBA,EAAK8H,EAAkB9H,IACpBtE,SAAQm/B,IACPA,EAAMh+B,aAAa,WAAY,KAAK,GAE5C,CACA,SAAS0sC,EAAUvpC,EAAIwpC,IACnBxpC,EAAK8H,EAAkB9H,IACpBtE,SAAQm/B,IACPA,EAAMh+B,aAAa,OAAQ2sC,EAAK,GAExC,CACA,SAASC,EAAqBzpC,EAAI0pC,IAC9B1pC,EAAK8H,EAAkB9H,IACpBtE,SAAQm/B,IACPA,EAAMh+B,aAAa,uBAAwB6sC,EAAY,GAE/D,CAOA,SAASC,EAAW3pC,EAAIsP,IACpBtP,EAAK8H,EAAkB9H,IACpBtE,SAAQm/B,IACPA,EAAMh+B,aAAa,aAAcyS,EAAM,GAE/C,CAaA,SAASs6B,EAAU5pC,IACfA,EAAK8H,EAAkB9H,IACpBtE,SAAQm/B,IACPA,EAAMh+B,aAAa,iBAAiB,EAAK,GAEjD,CACA,SAASgtC,EAAS7pC,IACdA,EAAK8H,EAAkB9H,IACpBtE,SAAQm/B,IACPA,EAAMh+B,aAAa,iBAAiB,EAAM,GAElD,CACA,SAASitC,EAAkBriC,GACvB,GAAkB,KAAdA,EAAEyuB,SAAgC,KAAdzuB,EAAEyuB,QAAgB,OAC1C,MAAMryB,EAASR,EAAOQ,OAAOmkC,KACvBlnB,EAAWrZ,EAAElM,OACnB,IAAI8H,EAAOq4B,aAAcr4B,EAAOq4B,WAAW17B,IAAO8gB,IAAazd,EAAOq4B,WAAW17B,KAAMqD,EAAOq4B,WAAW17B,GAAG4M,SAASnF,EAAElM,SAC9GkM,EAAElM,OAAOgK,QAAQyqB,GAAkB3sB,EAAOQ,OAAO63B,WAAWiB,cADrE,CAGA,GAAIt5B,EAAOmjB,YAAcnjB,EAAOmjB,WAAWE,QAAUrjB,EAAOmjB,WAAWC,OAAQ,CAC3E,MAAM5O,EAAU/P,EAAkBzE,EAAOmjB,WAAWE,QACpC5e,EAAkBzE,EAAOmjB,WAAWC,QACxCxc,SAAS6W,KACXzd,EAAOkT,QAAUlT,EAAOQ,OAAO4K,MACjCpL,EAAOgZ,YAEPhZ,EAAOkT,MACP4yB,EAAOtlC,EAAO0kC,kBAEdY,EAAOtlC,EAAOwkC,mBAGlBxwB,EAAQ5N,SAAS6W,KACXzd,EAAOiT,cAAgBjT,EAAOQ,OAAO4K,MACvCpL,EAAOsZ,YAEPtZ,EAAOiT,YACP6yB,EAAOtlC,EAAOykC,mBAEda,EAAOtlC,EAAOqkC,kBAG1B,CACI7kC,EAAOq4B,YAAc5a,EAASvb,QAAQyqB,GAAkB3sB,EAAOQ,OAAO63B,WAAWiB,eACjF7b,EAASipB,OA1Bb,CA4BJ,CA0BA,SAASC,IACL,OAAO3mC,EAAOq4B,YAAcr4B,EAAOq4B,WAAW4B,SAAWj6B,EAAOq4B,WAAW4B,QAAQ1hC,MACvF,CACA,SAASquC,IACL,OAAOD,KAAmB3mC,EAAOQ,OAAO63B,WAAWC,SACvD,CAmBA,MAAMuO,EAAY,CAAClqC,EAAImqC,EAAW/B,KAC9BiB,EAAgBrpC,GACG,WAAfA,EAAG+6B,UACHwO,EAAUvpC,EAAI,UACdA,EAAGjE,iBAAiB,UAAW+tC,IAEnCH,EAAW3pC,EAAIooC,GA9HnB,SAAuBpoC,EAAIoqC,IACvBpqC,EAAK8H,EAAkB9H,IACpBtE,SAAQm/B,IACPA,EAAMh+B,aAAa,gBAAiButC,EAAS,GAErD,CA0HIC,CAAcrqC,EAAImqC,EAAU,EAE1BG,EAAoB7iC,IAClBuhC,GAAsBA,IAAuBvhC,EAAElM,SAAWytC,EAAmBp8B,SAASnF,EAAElM,UACxFwtC,GAAsB,GAE1B1lC,EAAO2kC,KAAKc,SAAU,CAAI,EAExByB,EAAkB,KACpBxB,GAAsB,EACtBhqC,uBAAsB,KAClBA,uBAAsB,KACbsE,EAAO6H,YACR7H,EAAO2kC,KAAKc,SAAU,EAC1B,GACF,GACJ,EAEA0B,EAAqB/iC,IACvByhC,GAA6B,IAAIxqC,MAAO4F,SAAS,EAE/CmmC,EAAchjC,IAChB,GAAIpE,EAAO2kC,KAAKc,QAAS,OACzB,IAAI,IAAIpqC,MAAO4F,UAAY4kC,EAA6B,IAAK,OAC7D,MAAMhkC,EAAUuC,EAAElM,OAAO0R,QAAQ,IAAI5J,EAAOQ,OAAOsJ,4BACnD,IAAKjI,IAAY7B,EAAOkK,OAAOtD,SAAS/E,GAAU,OAClD8jC,EAAqB9jC,EACrB,MAAMwlC,EAAWrnC,EAAOkK,OAAOhL,QAAQ2C,KAAa7B,EAAO0K,YACrD+H,EAAYzS,EAAOQ,OAAOoQ,qBAAuB5Q,EAAOwR,eAAiBxR,EAAOwR,cAAc5K,SAAS/E,GACzGwlC,GAAY50B,GACZrO,EAAEkjC,oBAAsBljC,EAAEkjC,mBAAmBC,mBAC7CvnC,EAAO0L,eACP1L,EAAOrD,GAAGyG,WAAa,EAEvBpD,EAAOrD,GAAGuG,UAAY,EAE1BxH,uBAAsB,KACdgqC,IACA1lC,EAAOQ,OAAO4K,KACdpL,EAAOyY,YAAY7M,SAAS/J,EAAQ+T,aAAa,4BAA6B,GAE9E5V,EAAO2X,QAAQ3X,EAAOkK,OAAOhL,QAAQ2C,GAAU,GAEnD6jC,GAAsB,EAAK,IAC7B,EAEAx3B,EAAa,KACf,MAAM1N,EAASR,EAAOQ,OAAOmkC,KACzBnkC,EAAO+kC,4BACPa,EAAqBpmC,EAAOkK,OAAQ1J,EAAO+kC,4BAE3C/kC,EAAOglC,WACPU,EAAUlmC,EAAOkK,OAAQ1J,EAAOglC,WAEpC,MAAM54B,EAAe5M,EAAOkK,OAAO3R,OAC/BiI,EAAO4kC,mBACPplC,EAAOkK,OAAO7R,SAAQ,CAACwJ,EAAS8G,KAC5B,MAAMkH,EAAa7P,EAAOQ,OAAO4K,KAAOQ,SAAS/J,EAAQ+T,aAAa,2BAA4B,IAAMjN,EAExG29B,EAAWzkC,EADcrB,EAAO4kC,kBAAkB5nC,QAAQ,gBAAiBqS,EAAa,GAAGrS,QAAQ,uBAAwBoP,GACtF,GAE7C,EAEEkY,EAAO,KACT,MAAMtkB,EAASR,EAAOQ,OAAOmkC,KAC7B3kC,EAAOrD,GAAGie,OAAOgrB,GAGjB,MAAM9d,EAAc9nB,EAAOrD,GACvB6D,EAAO8kC,iCACPc,EAAqBte,EAAatnB,EAAO8kC,iCAEzC9kC,EAAO6kC,kBACPiB,EAAWxe,EAAatnB,EAAO6kC,kBAInC,MAAM3kC,EAAYV,EAAOU,UACnBomC,EAAYtmC,EAAO3E,IAAM6E,EAAUkV,aAAa,OAAS,kBA5O1CtR,EA4O4E,QA3OpF,IAATA,IACAA,EAAO,IAGJ,IAAIkjC,OAAOljC,GAAM9G,QAAQ,MADb,IAAM2D,KAAKsmC,MAAM,GAAKtmC,KAAKumC,UAAU5pC,SAAS,QAJrE,IAAyBwG,EA6OrB,MAAMqjC,EAAO3nC,EAAOQ,OAAOijB,UAAYzjB,EAAOQ,OAAOijB,SAAS/W,QAAU,MAAQ,SAlMpF,IAAqB7Q,IAmMEirC,EAlMdriC,EAkMG/D,GAjMLrI,SAAQm/B,IACPA,EAAMh+B,aAAa,KAAMqC,EAAG,IAGpC,SAAmBc,EAAIgrC,IACnBhrC,EAAK8H,EAAkB9H,IACpBtE,SAAQm/B,IACPA,EAAMh+B,aAAa,YAAamuC,EAAK,GAE7C,CAyLIC,CAAUlnC,EAAWinC,GAGrBz5B,IAGA,IAAIkV,OACAA,EAAMC,OACNA,GACArjB,EAAOmjB,WAAanjB,EAAOmjB,WAAa,CAAC,EAW7C,GAVAC,EAAS3e,EAAkB2e,GAC3BC,EAAS5e,EAAkB4e,GACvBD,GACAA,EAAO/qB,SAAQsE,GAAMkqC,EAAUlqC,EAAImqC,EAAWtmC,EAAOwkC,oBAErD3hB,GACAA,EAAOhrB,SAAQsE,GAAMkqC,EAAUlqC,EAAImqC,EAAWtmC,EAAOqkC,oBAIrD+B,IAA0B,CACLniC,EAAkBzE,EAAOq4B,WAAW17B,IAC5CtE,SAAQsE,IACjBA,EAAGjE,iBAAiB,UAAW+tC,EAAkB,GAEzD,CAGiBpsC,IACR3B,iBAAiB,mBAAoByuC,GAC9CnnC,EAAOrD,GAAGjE,iBAAiB,QAAS0uC,GAAa,GACjDpnC,EAAOrD,GAAGjE,iBAAiB,QAAS0uC,GAAa,GACjDpnC,EAAOrD,GAAGjE,iBAAiB,cAAeuuC,GAAmB,GAC7DjnC,EAAOrD,GAAGjE,iBAAiB,YAAawuC,GAAiB,EAAK,EAiClE3/B,EAAG,cAAc,KACbq+B,EAAaxsC,EAAc,OAAQ4G,EAAOQ,OAAOmkC,KAAKC,mBACtDgB,EAAWpsC,aAAa,YAAa,aACrCosC,EAAWpsC,aAAa,cAAe,OAAO,IAElD+N,EAAG,aAAa,KACPvH,EAAOQ,OAAOmkC,KAAKj4B,SACxBoY,GAAM,IAEVvd,EAAG,kEAAkE,KAC5DvH,EAAOQ,OAAOmkC,KAAKj4B,SACxBwB,GAAY,IAEhB3G,EAAG,yCAAyC,KACnCvH,EAAOQ,OAAOmkC,KAAKj4B,SAzN5B,WACI,GAAI1M,EAAOQ,OAAO4K,MAAQpL,EAAOQ,OAAO2K,SAAWnL,EAAOmjB,WAAY,OACtE,MAAMC,OACFA,EAAMC,OACNA,GACArjB,EAAOmjB,WACPE,IACIrjB,EAAOiT,aACPszB,EAAUljB,GACV4iB,EAAmB5iB,KAEnBmjB,EAASnjB,GACT2iB,EAAgB3iB,KAGpBD,IACIpjB,EAAOkT,OACPqzB,EAAUnjB,GACV6iB,EAAmB7iB,KAEnBojB,EAASpjB,GACT4iB,EAAgB5iB,IAG5B,CAkMIykB,EAAkB,IAEtBtgC,EAAG,oBAAoB,KACdvH,EAAOQ,OAAOmkC,KAAKj4B,SA9L5B,WACI,MAAMlM,EAASR,EAAOQ,OAAOmkC,KACxBgC,KACL3mC,EAAOq4B,WAAW4B,QAAQ5hC,SAAQgiC,IAC1Br6B,EAAOQ,OAAO63B,WAAWC,YACzB0N,EAAgB3L,GACXr6B,EAAOQ,OAAO63B,WAAWO,eAC1BsN,EAAU7L,EAAU,UACpBiM,EAAWjM,EAAU75B,EAAO2kC,wBAAwB3nC,QAAQ,gBAAiBkG,EAAa22B,GAAY,MAG1GA,EAASn4B,QAAQyqB,GAAkB3sB,EAAOQ,OAAO63B,WAAWkB,oBAC5Dc,EAAS7gC,aAAa,eAAgB,QAEtC6gC,EAASlwB,gBAAgB,eAC7B,GAER,CA8KI29B,EAAkB,IAEtBvgC,EAAG,WAAW,KACLvH,EAAOQ,OAAOmkC,KAAKj4B,SArD5B,WACQk5B,GAAYA,EAAWp8B,SAC3B,IAAI4Z,OACAA,EAAMC,OACNA,GACArjB,EAAOmjB,WAAanjB,EAAOmjB,WAAa,CAAC,EAC7CC,EAAS3e,EAAkB2e,GAC3BC,EAAS5e,EAAkB4e,GACvBD,GACAA,EAAO/qB,SAAQsE,GAAMA,EAAGhE,oBAAoB,UAAW8tC,KAEvDpjB,GACAA,EAAOhrB,SAAQsE,GAAMA,EAAGhE,oBAAoB,UAAW8tC,KAIvDG,KACqBniC,EAAkBzE,EAAOq4B,WAAW17B,IAC5CtE,SAAQsE,IACjBA,EAAGhE,oBAAoB,UAAW8tC,EAAkB,IAG3CpsC,IACR1B,oBAAoB,mBAAoBwuC,GAE7CnnC,EAAOrD,IAA2B,iBAAdqD,EAAOrD,KAC3BqD,EAAOrD,GAAGhE,oBAAoB,QAASyuC,GAAa,GACpDpnC,EAAOrD,GAAGhE,oBAAoB,cAAesuC,GAAmB,GAChEjnC,EAAOrD,GAAGhE,oBAAoB,YAAauuC,GAAiB,GAEpE,CAwBIpb,EAAS,GAEjB,EAEA,SAAiB/rB,GACb,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EACJ4pB,EAAa,CACThvB,QAAS,CACL+R,SAAS,EACTq7B,KAAM,GACNntC,cAAc,EACdtC,IAAK,SACL0vC,WAAW,KAGnB,IAAInyB,GAAc,EACdoyB,EAAQ,CAAC,EACb,MAAMC,EAAU9lC,GACLA,EAAKtE,WAAWN,QAAQ,OAAQ,KAAKA,QAAQ,WAAY,IAAIA,QAAQ,OAAQ,KAAKA,QAAQ,MAAO,IAAIA,QAAQ,MAAO,IAEzH2qC,EAAgBC,IAClB,MAAMpsC,EAASF,IACf,IAAIlC,EAEAA,EADAwuC,EACW,IAAIC,IAAID,GAERpsC,EAAOpC,SAEtB,MAAM0uC,EAAY1uC,EAASM,SAASoE,MAAM,GAAGlC,MAAM,KAAKC,QAAOksC,GAAiB,KAATA,IACjEhO,EAAQ+N,EAAU/vC,OAGxB,MAAO,CACHD,IAHQgwC,EAAU/N,EAAQ,GAI1BlS,MAHUigB,EAAU/N,EAAQ,GAI/B,EAECiO,EAAa,CAAClwC,EAAKqQ,KACrB,MAAM3M,EAASF,IACf,IAAK+Z,IAAgB7V,EAAOQ,OAAO7F,QAAQ+R,QAAS,OACpD,IAAI9S,EAEAA,EADAoG,EAAOQ,OAAO2kB,IACH,IAAIkjB,IAAIroC,EAAOQ,OAAO2kB,KAEtBnpB,EAAOpC,SAEtB,MAAM0U,EAAQtO,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAAU1M,EAAOmM,SAASpT,cAAc,6BAA6B4P,OAAa3I,EAAOkK,OAAOvB,GACtJ,IAAI0f,EAAQ6f,EAAQ55B,EAAMsH,aAAa,iBACvC,GAAI5V,EAAOQ,OAAO7F,QAAQotC,KAAKxvC,OAAS,EAAG,CACvC,IAAIwvC,EAAO/nC,EAAOQ,OAAO7F,QAAQotC,KACH,MAA1BA,EAAKA,EAAKxvC,OAAS,KAAYwvC,EAAOA,EAAKzpC,MAAM,EAAGypC,EAAKxvC,OAAS,IACtE8vB,EAAQ,GAAG0f,KAAQzvC,EAAM,GAAGA,KAAS,KAAK+vB,GAC9C,MAAYzuB,EAASM,SAAS0M,SAAStO,KACnC+vB,EAAQ,GAAG/vB,EAAM,GAAGA,KAAS,KAAK+vB,KAElCroB,EAAOQ,OAAO7F,QAAQqtC,YACtB3f,GAASzuB,EAASQ,QAEtB,MAAMquC,EAAezsC,EAAOrB,QAAQ+tC,MAChCD,GAAgBA,EAAapgB,QAAUA,IAGvCroB,EAAOQ,OAAO7F,QAAQC,aACtBoB,EAAOrB,QAAQC,aAAa,CACxBytB,SACD,KAAMA,GAETrsB,EAAOrB,QAAQE,UAAU,CACrBwtB,SACD,KAAMA,GACb,EAEEsgB,EAAgB,CAACloC,EAAO4nB,EAAOtR,KACjC,GAAIsR,EACA,IAAK,IAAIzpB,EAAI,EAAGrG,EAASyH,EAAOkK,OAAO3R,OAAQqG,EAAIrG,EAAQqG,GAAK,EAAG,CAC/D,MAAM0P,EAAQtO,EAAOkK,OAAOtL,GAE5B,GADqBspC,EAAQ55B,EAAMsH,aAAa,mBAC3ByS,EAAO,CACxB,MAAM1f,EAAQ3I,EAAOqa,cAAc/L,GACnCtO,EAAO2X,QAAQhP,EAAOlI,EAAOsW,EACjC,CACJ,MAEA/W,EAAO2X,QAAQ,EAAGlX,EAAOsW,EAC7B,EAEE6xB,EAAqB,KACvBX,EAAQE,EAAcnoC,EAAOQ,OAAO2kB,KACpCwjB,EAAc3oC,EAAOQ,OAAOC,MAAOwnC,EAAM5f,OAAO,EAAM,EA6B1D9gB,EAAG,QAAQ,KACHvH,EAAOQ,OAAO7F,QAAQ+R,SA5BjB,MACT,MAAM1Q,EAASF,IACf,GAAKkE,EAAOQ,OAAO7F,QAAnB,CACA,IAAKqB,EAAOrB,UAAYqB,EAAOrB,QAAQE,UAGnC,OAFAmF,EAAOQ,OAAO7F,QAAQ+R,SAAU,OAChC1M,EAAOQ,OAAOqoC,eAAen8B,SAAU,GAG3CmJ,GAAc,EACdoyB,EAAQE,EAAcnoC,EAAOQ,OAAO2kB,KAC/B8iB,EAAM3vC,KAAQ2vC,EAAM5f,OAMzBsgB,EAAc,EAAGV,EAAM5f,MAAOroB,EAAOQ,OAAOsV,oBACvC9V,EAAOQ,OAAO7F,QAAQC,cACvBoB,EAAOtD,iBAAiB,WAAYkwC,IAP/B5oC,EAAOQ,OAAO7F,QAAQC,cACvBoB,EAAOtD,iBAAiB,WAAYkwC,EAVV,CAiBlC,EAUI9jB,EACJ,IAEJvd,EAAG,WAAW,KACNvH,EAAOQ,OAAO7F,QAAQ+R,SAZd,MACZ,MAAM1Q,EAASF,IACVkE,EAAOQ,OAAO7F,QAAQC,cACvBoB,EAAOrD,oBAAoB,WAAYiwC,EAC3C,EASI9c,EACJ,IAEJvkB,EAAG,4CAA4C,KACvCsO,GACA2yB,EAAWxoC,EAAOQ,OAAO7F,QAAQrC,IAAK0H,EAAO0K,YACjD,IAEJnD,EAAG,eAAe,KACVsO,GAAe7V,EAAOQ,OAAOuN,SAC7By6B,EAAWxoC,EAAOQ,OAAO7F,QAAQrC,IAAK0H,EAAO0K,YACjD,GAER,EAEA,SAAwB3K,GACpB,IAAIC,OACAA,EAAM2pB,aACNA,EAAY7gB,KACZA,EAAIvB,GACJA,GACAxH,EACA8V,GAAc,EAClB,MAAMtb,EAAWF,IACX2B,EAASF,IACf6tB,EAAa,CACTkf,eAAgB,CACZn8B,SAAS,EACT9R,cAAc,EACdkuC,YAAY,EACZ,aAAAzuB,CAAc8T,EAAIt0B,GACd,GAAImG,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAAS,CACjD,MAAMq8B,EAAgB/oC,EAAOkK,OAAO7N,QAAOwF,GAAWA,EAAQ+T,aAAa,eAAiB/b,IAAM,GAClG,IAAKkvC,EAAe,OAAO,EAE3B,OADcn9B,SAASm9B,EAAcnzB,aAAa,2BAA4B,GAElF,CACA,OAAO5V,EAAOqa,cAActY,EAAgB/B,EAAOmM,SAAU,IAAInM,EAAOQ,OAAOsJ,yBAAyBjQ,gCAAmCA,OAAU,GACzJ,KAGR,MAAMmvC,EAAe,KACjBlgC,EAAK,cACL,MAAMmgC,EAAU1uC,EAASX,SAASC,KAAK2D,QAAQ,IAAK,IAC9C0rC,EAAgBlpC,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAAU1M,EAAOmM,SAASpT,cAAc,6BAA6BiH,EAAO0K,iBAAmB1K,EAAOkK,OAAOlK,EAAO0K,aAElL,GAAIu+B,KADoBC,EAAgBA,EAActzB,aAAa,aAAe,IACjD,CAC7B,MAAM8C,EAAW1Y,EAAOQ,OAAOqoC,eAAexuB,cAAcra,EAAQipC,GACpE,QAAwB,IAAbvwB,GAA4B1R,OAAO6E,MAAM6M,GAAW,OAC/D1Y,EAAO2X,QAAQe,EACnB,GAEEywB,EAAU,KACZ,IAAKtzB,IAAgB7V,EAAOQ,OAAOqoC,eAAen8B,QAAS,OAC3D,MAAMw8B,EAAgBlpC,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAAU1M,EAAOmM,SAASpT,cAAc,6BAA6BiH,EAAO0K,iBAAmB1K,EAAOkK,OAAOlK,EAAO0K,aAC5K0+B,EAAkBF,EAAgBA,EAActzB,aAAa,cAAgBszB,EAActzB,aAAa,gBAAkB,GAC5H5V,EAAOQ,OAAOqoC,eAAejuC,cAAgBoB,EAAOrB,SAAWqB,EAAOrB,QAAQC,cAC9EoB,EAAOrB,QAAQC,aAAa,KAAM,KAAM,IAAIwuC,KAAqB,IACjEtgC,EAAK,aAELvO,EAASX,SAASC,KAAOuvC,GAAmB,GAC5CtgC,EAAK,WACT,EAoBJvB,EAAG,QAAQ,KACHvH,EAAOQ,OAAOqoC,eAAen8B,SAnBxB,MACT,IAAK1M,EAAOQ,OAAOqoC,eAAen8B,SAAW1M,EAAOQ,OAAO7F,SAAWqF,EAAOQ,OAAO7F,QAAQ+R,QAAS,OACrGmJ,GAAc,EACd,MAAMhc,EAAOU,EAASX,SAASC,KAAK2D,QAAQ,IAAK,IACjD,GAAI3D,EAAM,CACN,MAAM4G,EAAQ,EACRkI,EAAQ3I,EAAOQ,OAAOqoC,eAAexuB,cAAcra,EAAQnG,GACjEmG,EAAO2X,QAAQhP,GAAS,EAAGlI,EAAOT,EAAOQ,OAAOsV,oBAAoB,EACxE,CACI9V,EAAOQ,OAAOqoC,eAAeC,YAC7B9sC,EAAOtD,iBAAiB,aAAcswC,EAC1C,EASIlkB,EACJ,IAEJvd,EAAG,WAAW,KACNvH,EAAOQ,OAAOqoC,eAAen8B,SAV7B1M,EAAOQ,OAAOqoC,eAAeC,YAC7B9sC,EAAOrD,oBAAoB,aAAcqwC,EAW7C,IAEJzhC,EAAG,4CAA4C,KACvCsO,GACAszB,GACJ,IAEJ5hC,EAAG,eAAe,KACVsO,GAAe7V,EAAOQ,OAAOuN,SAC7Bo7B,GACJ,GAER,EAIA,SAAkBppC,GACd,IAuBIq0B,EACAiV,GAxBArpC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,EAAEuB,KACFA,EAAItI,OACJA,GACAT,EACJC,EAAOyjB,SAAW,CACdC,SAAS,EACTC,QAAQ,EACR2lB,SAAU,GAEd3f,EAAa,CACTlG,SAAU,CACN/W,SAAS,EACTlQ,MAAO,IACP+sC,mBAAmB,EACnBC,sBAAsB,EACtBC,iBAAiB,EACjBC,kBAAkB,EAClBC,mBAAmB,KAK3B,IAEIC,EAEAC,EACAhsB,EACAisB,EACAC,EACAC,EACAC,EACAC,EAVAC,EAAqB3pC,GAAUA,EAAOijB,SAAWjjB,EAAOijB,SAASjnB,MAAQ,IACzE4tC,EAAuB5pC,GAAUA,EAAOijB,SAAWjjB,EAAOijB,SAASjnB,MAAQ,IAE3E6tC,GAAoB,IAAIhvC,MAAO4F,UAQnC,SAASqgC,EAAgBl9B,GAChBpE,IAAUA,EAAO6H,WAAc7H,EAAOU,WACvC0D,EAAElM,SAAW8H,EAAOU,YACxBV,EAAOU,UAAU/H,oBAAoB,gBAAiB2oC,GAClD4I,GAAwB9lC,EAAEqd,QAAUrd,EAAEqd,OAAOC,mBAGjDmC,IACJ,CACA,MAAMymB,EAAe,KACjB,GAAItqC,EAAO6H,YAAc7H,EAAOyjB,SAASC,QAAS,OAC9C1jB,EAAOyjB,SAASE,OAChBkmB,GAAY,EACLA,IACPO,EAAuBR,EACvBC,GAAY,GAEhB,MAAMP,EAAWtpC,EAAOyjB,SAASE,OAASimB,EAAmBS,EAAoBD,GAAuB,IAAI/uC,MAAO4F,UACnHjB,EAAOyjB,SAAS6lB,SAAWA,EAC3BxgC,EAAK,mBAAoBwgC,EAAUA,EAAWa,GAC9Cd,EAAM3tC,uBAAsB,KACxB4uC,GAAc,GAChB,EAaAC,EAAMC,IACR,GAAIxqC,EAAO6H,YAAc7H,EAAOyjB,SAASC,QAAS,OAClD9nB,qBAAqBytC,GACrBiB,IACA,IAAI9tC,OAA8B,IAAfguC,EAA6BxqC,EAAOQ,OAAOijB,SAASjnB,MAAQguC,EAC/EL,EAAqBnqC,EAAOQ,OAAOijB,SAASjnB,MAC5C4tC,EAAuBpqC,EAAOQ,OAAOijB,SAASjnB,MAC9C,MAAMiuC,EAlBY,MAClB,IAAIvB,EAMJ,GAJIA,EADAlpC,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QACxB1M,EAAOkK,OAAO7N,QAAOwF,GAAWA,EAAQY,UAAU8G,SAAS,yBAAwB,GAEnFvJ,EAAOkK,OAAOlK,EAAO0K,cAEpCw+B,EAAe,OAEpB,OAD0Bt9B,SAASs9B,EAActzB,aAAa,wBAAyB,GAC/D,EASE80B,IACrB1jC,OAAO6E,MAAM4+B,IAAsBA,EAAoB,QAA2B,IAAfD,IACpEhuC,EAAQiuC,EACRN,EAAqBM,EACrBL,EAAuBK,GAE3Bb,EAAmBptC,EACnB,MAAMiE,EAAQT,EAAOQ,OAAOC,MACtBkqC,EAAU,KACP3qC,IAAUA,EAAO6H,YAClB7H,EAAOQ,OAAOijB,SAASimB,kBAClB1pC,EAAOiT,aAAejT,EAAOQ,OAAO4K,MAAQpL,EAAOQ,OAAO2K,QAC3DnL,EAAOsZ,UAAU7Y,GAAO,GAAM,GAC9BqI,EAAK,aACG9I,EAAOQ,OAAOijB,SAASgmB,kBAC/BzpC,EAAO2X,QAAQ3X,EAAOkK,OAAO3R,OAAS,EAAGkI,GAAO,GAAM,GACtDqI,EAAK,cAGJ9I,EAAOkT,OAASlT,EAAOQ,OAAO4K,MAAQpL,EAAOQ,OAAO2K,QACrDnL,EAAOgZ,UAAUvY,GAAO,GAAM,GAC9BqI,EAAK,aACG9I,EAAOQ,OAAOijB,SAASgmB,kBAC/BzpC,EAAO2X,QAAQ,EAAGlX,GAAO,GAAM,GAC/BqI,EAAK,aAGT9I,EAAOQ,OAAOuN,UACds8B,GAAoB,IAAIhvC,MAAO4F,UAC/BvF,uBAAsB,KAClB6uC,GAAK,KAEb,EAcJ,OAZI/tC,EAAQ,GACRhB,aAAa44B,GACbA,EAAU74B,YAAW,KACjBovC,GAAS,GACVnuC,IAEHd,uBAAsB,KAClBivC,GAAS,IAKVnuC,CAAK,EAEVouC,EAAQ,KACVP,GAAoB,IAAIhvC,MAAO4F,UAC/BjB,EAAOyjB,SAASC,SAAU,EAC1B6mB,IACAzhC,EAAK,gBAAgB,EAEnBouB,EAAO,KACTl3B,EAAOyjB,SAASC,SAAU,EAC1BloB,aAAa44B,GACbx4B,qBAAqBytC,GACrBvgC,EAAK,eAAe,EAElB+hC,EAAQ,CAAC5zB,EAAU6zB,KACrB,GAAI9qC,EAAO6H,YAAc7H,EAAOyjB,SAASC,QAAS,OAClDloB,aAAa44B,GACRnd,IACDgzB,GAAsB,GAE1B,MAAMU,EAAU,KACZ7hC,EAAK,iBACD9I,EAAOQ,OAAOijB,SAAS8lB,kBACvBvpC,EAAOU,UAAUhI,iBAAiB,gBAAiB4oC,GAEnDzd,GACJ,EAGJ,GADA7jB,EAAOyjB,SAASE,QAAS,EACrBmnB,EAMA,OALId,IACAJ,EAAmB5pC,EAAOQ,OAAOijB,SAASjnB,OAE9CwtC,GAAe,OACfW,IAGJ,MAAMnuC,EAAQotC,GAAoB5pC,EAAOQ,OAAOijB,SAASjnB,MACzDotC,EAAmBptC,IAAS,IAAInB,MAAO4F,UAAYopC,GAC/CrqC,EAAOkT,OAAS02B,EAAmB,IAAM5pC,EAAOQ,OAAO4K,OACvDw+B,EAAmB,IAAGA,EAAmB,GAC7Ce,IAAS,EAEP9mB,EAAS,KACP7jB,EAAOkT,OAAS02B,EAAmB,IAAM5pC,EAAOQ,OAAO4K,MAAQpL,EAAO6H,YAAc7H,EAAOyjB,SAASC,UACxG2mB,GAAoB,IAAIhvC,MAAO4F,UAC3BgpC,GACAA,GAAsB,EACtBM,EAAIX,IAEJW,IAEJvqC,EAAOyjB,SAASE,QAAS,EACzB7a,EAAK,kBAAiB,EAEpBq+B,EAAqB,KACvB,GAAInnC,EAAO6H,YAAc7H,EAAOyjB,SAASC,QAAS,OAClD,MAAMnpB,EAAWF,IACgB,WAA7BE,EAASwwC,kBACTd,GAAsB,EACtBY,GAAM,IAEuB,YAA7BtwC,EAASwwC,iBACTlnB,GACJ,EAEEmnB,EAAiB5mC,IACG,UAAlBA,EAAEoZ,cACNysB,GAAsB,EACtBC,GAAuB,EACnBlqC,EAAOkX,WAAalX,EAAOyjB,SAASE,QACxCknB,GAAM,GAAK,EAETI,EAAiB7mC,IACG,UAAlBA,EAAEoZ,cACN0sB,GAAuB,EACnBlqC,EAAOyjB,SAASE,QAChBE,IACJ,EAsBJtc,EAAG,QAAQ,KACHvH,EAAOQ,OAAOijB,SAAS/W,UApBvB1M,EAAOQ,OAAOijB,SAASkmB,oBACvB3pC,EAAOrD,GAAGjE,iBAAiB,eAAgBsyC,GAC3ChrC,EAAOrD,GAAGjE,iBAAiB,eAAgBuyC,IAU9B5wC,IACR3B,iBAAiB,mBAAoByuC,GAU1CyD,IACJ,IAEJrjC,EAAG,WAAW,KApBNvH,EAAOrD,IAA2B,iBAAdqD,EAAOrD,KAC3BqD,EAAOrD,GAAGhE,oBAAoB,eAAgBqyC,GAC9ChrC,EAAOrD,GAAGhE,oBAAoB,eAAgBsyC,IAQjC5wC,IACR1B,oBAAoB,mBAAoBwuC,GAY7CnnC,EAAOyjB,SAASC,SAChBwT,GACJ,IAEJ3vB,EAAG,0BAA0B,MACrBuiC,GAAiBG,IACjBpmB,GACJ,IAEJtc,EAAG,8BAA8B,KACxBvH,EAAOQ,OAAOijB,SAAS+lB,qBAGxBtS,IAFA2T,GAAM,GAAM,EAGhB,IAEJtjC,EAAG,yBAAyB,CAAC4mB,EAAI1tB,EAAOwW,MAChCjX,EAAO6H,WAAc7H,EAAOyjB,SAASC,UACrCzM,IAAajX,EAAOQ,OAAOijB,SAAS+lB,qBACpCqB,GAAM,GAAM,GAEZ3T,IACJ,IAEJ3vB,EAAG,mBAAmB,MACdvH,EAAO6H,WAAc7H,EAAOyjB,SAASC,UACrC1jB,EAAOQ,OAAOijB,SAAS+lB,qBACvBtS,KAGJrZ,GAAY,EACZisB,GAAgB,EAChBG,GAAsB,EACtBF,EAAoBxuC,YAAW,KAC3B0uC,GAAsB,EACtBH,GAAgB,EAChBe,GAAM,EAAK,GACZ,MAAI,IAEXtjC,EAAG,YAAY,KACX,IAAIvH,EAAO6H,WAAc7H,EAAOyjB,SAASC,SAAY7F,EAArD,CAGA,GAFAriB,aAAauuC,GACbvuC,aAAa44B,GACTp0B,EAAOQ,OAAOijB,SAAS+lB,qBAGvB,OAFAM,GAAgB,OAChBjsB,GAAY,GAGZisB,GAAiB9pC,EAAOQ,OAAOuN,SAAS8V,IAC5CimB,GAAgB,EAChBjsB,GAAY,CAV0D,CAUrD,IAErBtW,EAAG,eAAe,MACVvH,EAAO6H,WAAc7H,EAAOyjB,SAASC,UACzCsmB,GAAe,EAAI,IAEvBhyC,OAAO8T,OAAO9L,EAAOyjB,SAAU,CAC3BmnB,QACA1T,OACA2T,QACAhnB,UAER,EAEA,SAAe9jB,GACX,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EACJ4pB,EAAa,CACTuhB,OAAQ,CACJlrC,OAAQ,KACRmrC,sBAAsB,EACtBC,iBAAkB,EAClBC,sBAAuB,4BACvBC,qBAAsB,mBAG9B,IAAIz1B,GAAc,EACd01B,GAAgB,EAIpB,SAASC,IACL,MAAMC,EAAezrC,EAAOkrC,OAAOlrC,OACnC,IAAKyrC,GAAgBA,EAAa5jC,UAAW,OAC7C,MAAMuO,EAAeq1B,EAAar1B,aAC5BD,EAAes1B,EAAat1B,aAClC,GAAIA,GAAgBA,EAAa1T,UAAU8G,SAASvJ,EAAOQ,OAAO0qC,OAAOG,uBAAwB,OACjG,GAAI,MAAOj1B,EAAuD,OAClE,IAAI8D,EAEAA,EADAuxB,EAAajrC,OAAO4K,KACLQ,SAAS6/B,EAAat1B,aAAaP,aAAa,2BAA4B,IAE5EQ,EAEfpW,EAAOQ,OAAO4K,KACdpL,EAAOyY,YAAYyB,GAEnBla,EAAO2X,QAAQuC,EAEvB,CACA,SAAS4K,IACL,MACIomB,OAAQQ,GACR1rC,EAAOQ,OACX,GAAIqV,EAAa,OAAO,EACxBA,GAAc,EACd,MAAM81B,EAAc3rC,EAAOjI,YAC3B,GAAI2zC,EAAa1rC,kBAAkB2rC,EAC/B3rC,EAAOkrC,OAAOlrC,OAAS0rC,EAAa1rC,OACpChI,OAAO8T,OAAO9L,EAAOkrC,OAAOlrC,OAAO6mB,eAAgB,CAC/CjW,qBAAqB,EACrByF,qBAAqB,IAEzBre,OAAO8T,OAAO9L,EAAOkrC,OAAOlrC,OAAOQ,OAAQ,CACvCoQ,qBAAqB,EACrByF,qBAAqB,IAEzBrW,EAAOkrC,OAAOlrC,OAAOsL,cAClB,GAAIpN,EAASwtC,EAAa1rC,QAAS,CACtC,MAAM4rC,EAAqB5zC,OAAO8T,OAAO,CAAC,EAAG4/B,EAAa1rC,QAC1DhI,OAAO8T,OAAO8/B,EAAoB,CAC9Bh7B,qBAAqB,EACrByF,qBAAqB,IAEzBrW,EAAOkrC,OAAOlrC,OAAS,IAAI2rC,EAAYC,GACvCL,GAAgB,CACpB,CAGA,OAFAvrC,EAAOkrC,OAAOlrC,OAAOrD,GAAG8F,UAAUC,IAAI1C,EAAOQ,OAAO0qC,OAAOI,sBAC3DtrC,EAAOkrC,OAAOlrC,OAAOuH,GAAG,MAAOikC,IACxB,CACX,CACA,SAASlgC,EAAOsM,GACZ,MAAM6zB,EAAezrC,EAAOkrC,OAAOlrC,OACnC,IAAKyrC,GAAgBA,EAAa5jC,UAAW,OAC7C,MAAM0C,EAAsD,SAAtCkhC,EAAajrC,OAAO+J,cAA2BkhC,EAAajhC,uBAAyBihC,EAAajrC,OAAO+J,cAG/H,IAAIshC,EAAmB,EACvB,MAAMC,EAAmB9rC,EAAOQ,OAAO0qC,OAAOG,sBAS9C,GARIrrC,EAAOQ,OAAO+J,cAAgB,IAAMvK,EAAOQ,OAAOsN,iBAClD+9B,EAAmB7rC,EAAOQ,OAAO+J,eAEhCvK,EAAOQ,OAAO0qC,OAAOC,uBACtBU,EAAmB,GAEvBA,EAAmB1qC,KAAK4N,MAAM88B,GAC9BJ,EAAavhC,OAAO7R,SAAQwJ,GAAWA,EAAQY,UAAU+G,OAAOsiC,KAC5DL,EAAajrC,OAAO4K,MAAQqgC,EAAajrC,OAAOiM,SAAWg/B,EAAajrC,OAAOiM,QAAQC,QACvF,IAAK,IAAI9N,EAAI,EAAGA,EAAIitC,EAAkBjtC,GAAK,EACvCmD,EAAgB0pC,EAAat/B,SAAU,6BAA6BnM,EAAOqL,UAAYzM,OAAOvG,SAAQwJ,IAClGA,EAAQY,UAAUC,IAAIopC,EAAiB,SAI/C,IAAK,IAAIltC,EAAI,EAAGA,EAAIitC,EAAkBjtC,GAAK,EACnC6sC,EAAavhC,OAAOlK,EAAOqL,UAAYzM,IACvC6sC,EAAavhC,OAAOlK,EAAOqL,UAAYzM,GAAG6D,UAAUC,IAAIopC,GAIpE,MAAMV,EAAmBprC,EAAOQ,OAAO0qC,OAAOE,iBACxCW,EAAYX,IAAqBK,EAAajrC,OAAO4K,KAC3D,GAAIpL,EAAOqL,YAAcogC,EAAapgC,WAAa0gC,EAAW,CAC1D,MAAMC,EAAqBP,EAAa/gC,YACxC,IAAIuhC,EACAx0B,EACJ,GAAIg0B,EAAajrC,OAAO4K,KAAM,CAC1B,MAAM8gC,EAAiBT,EAAavhC,OAAO7N,QAAOwF,GAAWA,EAAQ+T,aAAa,6BAA+B,GAAG5V,EAAOqL,cAAa,GACxI4gC,EAAiBR,EAAavhC,OAAOhL,QAAQgtC,GAC7Cz0B,EAAYzX,EAAO0K,YAAc1K,EAAOkV,cAAgB,OAAS,MACrE,MACI+2B,EAAiBjsC,EAAOqL,UACxBoM,EAAYw0B,EAAiBjsC,EAAOkV,cAAgB,OAAS,OAE7D62B,IACAE,GAAgC,SAAdx0B,EAAuB2zB,GAAoB,EAAIA,GAEjEK,EAAax5B,sBAAwBw5B,EAAax5B,qBAAqB/S,QAAQ+sC,GAAkB,IAC7FR,EAAajrC,OAAOsN,eAEhBm+B,EADAA,EAAiBD,EACAC,EAAiB9qC,KAAK4N,MAAMxE,EAAgB,GAAK,EAEjD0hC,EAAiB9qC,KAAK4N,MAAMxE,EAAgB,GAAK,EAE/D0hC,EAAiBD,GAAsBP,EAAajrC,OAAO0O,eACtEu8B,EAAa9zB,QAAQs0B,EAAgBr0B,EAAU,OAAIlZ,GAE3D,CACJ,CA9GAsB,EAAOkrC,OAAS,CACZlrC,OAAQ,MA8GZuH,EAAG,cAAc,KACb,MAAM2jC,OACFA,GACAlrC,EAAOQ,OACX,GAAK0qC,GAAWA,EAAOlrC,OACvB,GAA6B,iBAAlBkrC,EAAOlrC,QAAuBkrC,EAAOlrC,kBAAkBjB,YAAa,CAC3E,MAAMxE,EAAWF,IACX8xC,EAA0B,KAC5B,MAAMC,EAAyC,iBAAlBlB,EAAOlrC,OAAsBzF,EAASxB,cAAcmyC,EAAOlrC,QAAUkrC,EAAOlrC,OACzG,GAAIosC,GAAiBA,EAAcpsC,OAC/BkrC,EAAOlrC,OAASosC,EAAcpsC,OAC9B8kB,IACAxZ,GAAO,QACJ,GAAI8gC,EAAe,CACtB,MAAMC,EAAiBjoC,IACnB8mC,EAAOlrC,OAASoE,EAAEqd,OAAO,GACzB2qB,EAAczzC,oBAAoB,OAAQ0zC,GAC1CvnB,IACAxZ,GAAO,GACP4/B,EAAOlrC,OAAOsL,SACdtL,EAAOsL,QAAQ,EAEnB8gC,EAAc1zC,iBAAiB,OAAQ2zC,EAC3C,CACA,OAAOD,CAAa,EAElBE,EAAyB,KAC3B,GAAItsC,EAAO6H,UAAW,OACAskC,KAElBzwC,sBAAsB4wC,EAC1B,EAEJ5wC,sBAAsB4wC,EAC1B,MACIxnB,IACAxZ,GAAO,EACX,IAEJ/D,EAAG,4CAA4C,KAC3C+D,GAAQ,IAEZ/D,EAAG,iBAAiB,CAAC4mB,EAAI5tB,KACrB,MAAMkrC,EAAezrC,EAAOkrC,OAAOlrC,OAC9ByrC,IAAgBA,EAAa5jC,WAClC4jC,EAAap6B,cAAc9Q,EAAS,IAExCgH,EAAG,iBAAiB,KAChB,MAAMkkC,EAAezrC,EAAOkrC,OAAOlrC,OAC9ByrC,IAAgBA,EAAa5jC,WAC9B0jC,GACAE,EAAa3f,SACjB,IAEJ9zB,OAAO8T,OAAO9L,EAAOkrC,OAAQ,CACzBpmB,OACAxZ,UAER,EAEA,SAAkBvL,GACd,IAAIC,OACAA,EAAM2pB,aACNA,EAAY7gB,KACZA,EAAId,KACJA,GACAjI,EACJ4pB,EAAa,CACT7J,SAAU,CACNpT,SAAS,EACT6/B,UAAU,EACVC,cAAe,EACfC,gBAAgB,EAChBC,oBAAqB,EACrBC,sBAAuB,EACvB9V,QAAQ,EACR+V,gBAAiB,OAiNzB50C,OAAO8T,OAAO9L,EAAQ,CAClB8f,SAAU,CACNhD,aAhNR,WACI,GAAI9c,EAAOQ,OAAOuN,QAAS,OAC3B,MAAM3N,EAAYJ,EAAOtD,eACzBsD,EAAOwW,aAAapW,GACpBJ,EAAOqR,cAAc,GACrBrR,EAAO+b,gBAAgBmO,WAAW3xB,OAAS,EAC3CyH,EAAO8f,SAASsC,WAAW,CACvBK,WAAYziB,EAAOsM,IAAMtM,EAAOI,WAAaJ,EAAOI,WAE5D,EAwMQ2f,YAvMR,WACI,GAAI/f,EAAOQ,OAAOuN,QAAS,OAC3B,MACIgO,gBAAiBhT,EAAIuU,QACrBA,GACAtd,EAE2B,IAA3B+I,EAAKmhB,WAAW3xB,QAChBwQ,EAAKmhB,WAAWjmB,KAAK,CACjB2yB,SAAUtZ,EAAQtd,EAAO0L,eAAiB,SAAW,UACrDrL,KAAM0I,EAAKsW,iBAGnBtW,EAAKmhB,WAAWjmB,KAAK,CACjB2yB,SAAUtZ,EAAQtd,EAAO0L,eAAiB,WAAa,YACvDrL,KAAM5D,KAEd,EAuLQ2lB,WAtLR,SAAoBuN,GAChB,IAAIlN,WACAA,GACAkN,EACJ,GAAI3vB,EAAOQ,OAAOuN,QAAS,OAC3B,MAAMvN,OACFA,EAAME,UACNA,EACA2L,aAAcC,EAAGO,SACjBA,EACAkP,gBAAiBhT,GACjB/I,EAGEsiB,EADe7lB,IACWsM,EAAKsW,eACrC,GAAIoD,GAAcziB,EAAOoS,eACrBpS,EAAO2X,QAAQ3X,EAAO0K,kBAG1B,GAAI+X,GAAcziB,EAAOgT,eACjBhT,EAAOkK,OAAO3R,OAASsU,EAAStU,OAChCyH,EAAO2X,QAAQ9K,EAAStU,OAAS,GAEjCyH,EAAO2X,QAAQ3X,EAAOkK,OAAO3R,OAAS,OAJ9C,CAQA,GAAIiI,EAAOsf,SAASysB,SAAU,CAC1B,GAAIxjC,EAAKmhB,WAAW3xB,OAAS,EAAG,CAC5B,MAAMs0C,EAAgB9jC,EAAKmhB,WAAW4iB,MAChCC,EAAgBhkC,EAAKmhB,WAAW4iB,MAChCE,EAAWH,EAAcjW,SAAWmW,EAAcnW,SAClDv2B,EAAOwsC,EAAcxsC,KAAO0sC,EAAc1sC,KAChDL,EAAO+pB,SAAWijB,EAAW3sC,EAC7BL,EAAO+pB,UAAY,EACf5oB,KAAK8N,IAAIjP,EAAO+pB,UAAYvpB,EAAOsf,SAAS8sB,kBAC5C5sC,EAAO+pB,SAAW,IAIlB1pB,EAAO,KAAO5D,IAAQowC,EAAcxsC,KAAO,OAC3CL,EAAO+pB,SAAW,EAE1B,MACI/pB,EAAO+pB,SAAW,EAEtB/pB,EAAO+pB,UAAYvpB,EAAOsf,SAAS6sB,sBACnC5jC,EAAKmhB,WAAW3xB,OAAS,EACzB,IAAI2qC,EAAmB,IAAO1iC,EAAOsf,SAAS0sB,cAC9C,MAAMS,EAAmBjtC,EAAO+pB,SAAWmZ,EAC3C,IAAIgK,EAAcltC,EAAOI,UAAY6sC,EACjC3gC,IAAK4gC,GAAeA,GACxB,IACIC,EADAC,GAAW,EAEf,MAAMC,EAA2C,GAA5BlsC,KAAK8N,IAAIjP,EAAO+pB,UAAiBvpB,EAAOsf,SAAS4sB,oBACtE,IAAIY,EACJ,GAAIJ,EAAcltC,EAAOgT,eACjBxS,EAAOsf,SAAS2sB,gBACZS,EAAcltC,EAAOgT,gBAAkBq6B,IACvCH,EAAcltC,EAAOgT,eAAiBq6B,GAE1CF,EAAsBntC,EAAOgT,eAC7Bo6B,GAAW,EACXrkC,EAAK6Y,qBAAsB,GAE3BsrB,EAAcltC,EAAOgT,eAErBxS,EAAO4K,MAAQ5K,EAAOsN,iBAAgBw/B,GAAe,QACtD,GAAIJ,EAAcltC,EAAOoS,eACxB5R,EAAOsf,SAAS2sB,gBACZS,EAAcltC,EAAOoS,eAAiBi7B,IACtCH,EAAcltC,EAAOoS,eAAiBi7B,GAE1CF,EAAsBntC,EAAOoS,eAC7Bg7B,GAAW,EACXrkC,EAAK6Y,qBAAsB,GAE3BsrB,EAAcltC,EAAOoS,eAErB5R,EAAO4K,MAAQ5K,EAAOsN,iBAAgBw/B,GAAe,QACtD,GAAI9sC,EAAOsf,SAAS+W,OAAQ,CAC/B,IAAI1iB,EACJ,IAAK,IAAIo5B,EAAI,EAAGA,EAAI1gC,EAAStU,OAAQg1C,GAAK,EACtC,GAAI1gC,EAAS0gC,IAAML,EAAa,CAC5B/4B,EAAYo5B,EACZ,KACJ,CAGAL,EADA/rC,KAAK8N,IAAIpC,EAASsH,GAAa+4B,GAAe/rC,KAAK8N,IAAIpC,EAASsH,EAAY,GAAK+4B,IAA0C,SAA1BltC,EAAOsf,eAC1FzS,EAASsH,GAETtH,EAASsH,EAAY,GAEvC+4B,GAAeA,CACnB,CAOA,GANII,GACAtlC,EAAK,iBAAiB,KAClBhI,EAAO8Y,SAAS,IAIA,IAApB9Y,EAAO+pB,UAMP,GAJImZ,EADA52B,EACmBnL,KAAK8N,MAAMi+B,EAAcltC,EAAOI,WAAaJ,EAAO+pB,UAEpD5oB,KAAK8N,KAAKi+B,EAAcltC,EAAOI,WAAaJ,EAAO+pB,UAEtEvpB,EAAOsf,SAAS+W,OAAQ,CAQxB,MAAM2W,EAAersC,KAAK8N,KAAK3C,GAAO4gC,EAAcA,GAAeltC,EAAOI,WACpEqtC,EAAmBztC,EAAO+M,gBAAgB/M,EAAO0K,aAEnDw4B,EADAsK,EAAeC,EACIjtC,EAAOC,MACnB+sC,EAAe,EAAIC,EACQ,IAAfjtC,EAAOC,MAEQ,IAAfD,EAAOC,KAElC,OACG,GAAID,EAAOsf,SAAS+W,OAEvB,YADA72B,EAAO+Z,iBAGPvZ,EAAOsf,SAAS2sB,gBAAkBW,GAClCptC,EAAO6S,eAAes6B,GACtBntC,EAAOqR,cAAc6xB,GACrBljC,EAAOwW,aAAa02B,GACpBltC,EAAOkY,iBAAgB,EAAMlY,EAAOsf,gBACpCtf,EAAOkX,WAAY,EACnBhT,EAAqBxD,GAAW,KACvBV,IAAUA,EAAO6H,WAAckB,EAAK6Y,sBACzC9Y,EAAK,kBACL9I,EAAOqR,cAAc7Q,EAAOC,OAC5BlF,YAAW,KACPyE,EAAOwW,aAAa22B,GACpBjpC,EAAqBxD,GAAW,KACvBV,IAAUA,EAAO6H,WACtB7H,EAAOmY,eAAe,GACxB,GACH,GAAE,KAEFnY,EAAO+pB,UACdjhB,EAAK,8BACL9I,EAAO6S,eAAeq6B,GACtBltC,EAAOqR,cAAc6xB,GACrBljC,EAAOwW,aAAa02B,GACpBltC,EAAOkY,iBAAgB,EAAMlY,EAAOsf,gBAC/Btf,EAAOkX,YACRlX,EAAOkX,WAAY,EACnBhT,EAAqBxD,GAAW,KACvBV,IAAUA,EAAO6H,WACtB7H,EAAOmY,eAAe,MAI9BnY,EAAO6S,eAAeq6B,GAE1BltC,EAAOgV,oBACPhV,EAAO+T,qBACX,KAAO,IAAIvT,EAAOsf,SAAS+W,OAEvB,YADA72B,EAAO+Z,iBAEAvZ,EAAOsf,UACdhX,EAAK,6BACT,GACKtI,EAAOsf,SAASysB,UAAYjqB,GAAY9hB,EAAOuiB,gBAChDja,EAAK,0BACL9I,EAAO6S,iBACP7S,EAAOgV,oBACPhV,EAAO+T,sBArJX,CAuJJ,IAQJ,EAEA,SAAchU,GACV,IAWI2tC,EACAC,EACAC,EACA9mB,GAdA9mB,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EACJ4pB,EAAa,CACThf,KAAM,CACFC,KAAM,EACNqQ,KAAM,YAOd,MAAM4yB,EAAkB,KACpB,IAAIvgC,EAAetN,EAAOQ,OAAO8M,aAMjC,MAL4B,iBAAjBA,GAA6BA,EAAapO,QAAQ,MAAQ,EACjEoO,EAAetP,WAAWsP,EAAa9P,QAAQ,IAAK,KAAO,IAAMwC,EAAOsE,KACzC,iBAAjBgJ,IACdA,EAAetP,WAAWsP,IAEvBA,CAAY,EAyHvB/F,EAAG,QAtBY,KACXuf,EAAc9mB,EAAOQ,OAAOmK,MAAQ3K,EAAOQ,OAAOmK,KAAKC,KAAO,CAAC,IAsBnErD,EAAG,UApBc,KACb,MAAM/G,OACFA,EAAM7D,GACNA,GACAqD,EACE+mB,EAAavmB,EAAOmK,MAAQnK,EAAOmK,KAAKC,KAAO,EACjDkc,IAAgBC,GAChBpqB,EAAG8F,UAAU+G,OAAO,GAAGhJ,EAAOuQ,6BAA8B,GAAGvQ,EAAOuQ,qCACtE68B,EAAiB,EACjB5tC,EAAOmnB,yBACCL,GAAeC,IACvBpqB,EAAG8F,UAAUC,IAAI,GAAGlC,EAAOuQ,8BACF,WAArBvQ,EAAOmK,KAAKsQ,MACZte,EAAG8F,UAAUC,IAAI,GAAGlC,EAAOuQ,qCAE/B/Q,EAAOmnB,wBAEXL,EAAcC,CAAU,IAI5B/mB,EAAO2K,KAAO,CACVuD,WA1HehE,IACf,MAAMK,cACFA,GACAvK,EAAOQ,QACLoK,KACFA,EAAIqQ,KACJA,GACAjb,EAAOQ,OAAOmK,KACZiC,EAAe5M,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAAU1M,EAAOyM,QAAQvC,OAAO3R,OAAS2R,EAAO3R,OAC7Gq1C,EAAiBzsC,KAAK4N,MAAMnC,EAAehC,GAEvC8iC,EADAvsC,KAAK4N,MAAMnC,EAAehC,KAAUgC,EAAehC,EAC1BgC,EAEAzL,KAAKsJ,KAAKmC,EAAehC,GAAQA,EAExC,SAAlBL,GAAqC,QAAT0Q,IAC5ByyB,EAAyBvsC,KAAKC,IAAIssC,EAAwBnjC,EAAgBK,IAE9E+iC,EAAeD,EAAyB9iC,CAAI,EAyG5CuD,YAvGgB,KACZnO,EAAOkK,QACPlK,EAAOkK,OAAO7R,SAAQiW,IACdA,EAAMw/B,qBACNx/B,EAAM/U,MAAMuM,OAAS,GACrBwI,EAAM/U,MAAMyG,EAAOkM,kBAAkB,eAAiB,GAC1D,GAER,EAgGAqC,YA9FgB,CAAC3P,EAAG0P,EAAOpE,KAC3B,MAAMgF,eACFA,GACAlP,EAAOQ,OACL8M,EAAeugC,KACfjjC,KACFA,EAAIqQ,KACJA,GACAjb,EAAOQ,OAAOmK,KACZiC,EAAe5M,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAAU1M,EAAOyM,QAAQvC,OAAO3R,OAAS2R,EAAO3R,OAE7G,IAAIw1C,EACA9iC,EACA+iC,EACJ,GAAa,QAAT/yB,GAAkB/L,EAAiB,EAAG,CACtC,MAAM++B,EAAa9sC,KAAK4N,MAAMnQ,GAAKsQ,EAAiBtE,IAC9CsjC,EAAoBtvC,EAAIgM,EAAOsE,EAAiB++B,EAChDE,EAAgC,IAAfF,EAAmB/+B,EAAiB/N,KAAKE,IAAIF,KAAKsJ,MAAMmC,EAAeqhC,EAAarjC,EAAOsE,GAAkBtE,GAAOsE,GAC3I8+B,EAAM7sC,KAAK4N,MAAMm/B,EAAoBC,GACrCljC,EAASijC,EAAoBF,EAAMG,EAAiBF,EAAa/+B,EACjE6+B,EAAqB9iC,EAAS+iC,EAAMN,EAAyB9iC,EAC7D0D,EAAM/U,MAAM60C,MAAQL,CACxB,KAAoB,WAAT9yB,GACPhQ,EAAS9J,KAAK4N,MAAMnQ,EAAIgM,GACxBojC,EAAMpvC,EAAIqM,EAASL,GACfK,EAAS2iC,GAAkB3iC,IAAW2iC,GAAkBI,IAAQpjC,EAAO,KACvEojC,GAAO,EACHA,GAAOpjC,IACPojC,EAAM,EACN/iC,GAAU,MAIlB+iC,EAAM7sC,KAAK4N,MAAMnQ,EAAI+uC,GACrB1iC,EAASrM,EAAIovC,EAAML,GAEvBr/B,EAAM0/B,IAAMA,EACZ1/B,EAAMrD,OAASA,EACfqD,EAAM/U,MAAMuM,OAAS,iBAAiB8E,EAAO,GAAK0C,UAAqB1C,KACvE0D,EAAM/U,MAAMyG,EAAOkM,kBAAkB,eAAyB,IAAR8hC,EAAY1gC,GAAgB,GAAGA,MAAmB,GACxGgB,EAAMw/B,oBAAqB,CAAI,EAuD/Bx+B,kBArDsB,CAACrB,EAAWpB,KAClC,MAAMiB,eACFA,EAAca,aACdA,GACA3O,EAAOQ,OACL8M,EAAeugC,KACfjjC,KACFA,GACA5K,EAAOQ,OAAOmK,KAMlB,GALA3K,EAAOyN,aAAeQ,EAAYX,GAAgBogC,EAClD1tC,EAAOyN,YAActM,KAAKsJ,KAAKzK,EAAOyN,YAAc7C,GAAQ0C,EACvDtN,EAAOQ,OAAOuN,UACf/N,EAAOU,UAAUnH,MAAMyG,EAAOkM,kBAAkB,UAAY,GAAGlM,EAAOyN,YAAcH,OAEpFQ,EAAgB,CAChB,MAAMyB,EAAgB,GACtB,IAAK,IAAI3Q,EAAI,EAAGA,EAAIiO,EAAStU,OAAQqG,GAAK,EAAG,CACzC,IAAI4Q,EAAiB3C,EAASjO,GAC1B+P,IAAca,EAAiBrO,KAAK4N,MAAMS,IAC1C3C,EAASjO,GAAKoB,EAAOyN,YAAcZ,EAAS,IAAI0C,EAActL,KAAKuL,EAC3E,CACA3C,EAASjE,OAAO,EAAGiE,EAAStU,QAC5BsU,EAAS5I,QAAQsL,EACrB,GAgCR,EAmLA,SAAsBxP,GAClB,IAAIC,OACAA,GACAD,EACJ/H,OAAO8T,OAAO9L,EAAQ,CAClB4sB,YAAaA,GAAYrG,KAAKvmB,GAC9BitB,aAAcA,GAAa1G,KAAKvmB,GAChCmtB,SAAUA,GAAS5G,KAAKvmB,GACxBwtB,YAAaA,GAAYjH,KAAKvmB,GAC9B2tB,gBAAiBA,GAAgBpH,KAAKvmB,IAE9C,EAiHA,SAAoBD,GAChB,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EACJ4pB,EAAa,CACT0kB,WAAY,CACRC,WAAW,KAoCnB1gB,GAAW,CACPxe,OAAQ,OACRpP,SACAuH,KACAiP,aArCiB,KACjB,MAAMtM,OACFA,GACAlK,EACWA,EAAOQ,OAAO6tC,WAC7B,IAAK,IAAIzvC,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EAAG,CACvC,MAAMiD,EAAU7B,EAAOkK,OAAOtL,GAE9B,IAAI2vC,GADW1sC,EAAQgQ,kBAElB7R,EAAOQ,OAAO8V,mBAAkBi4B,GAAMvuC,EAAOI,WAClD,IAAIouC,EAAK,EACJxuC,EAAO0L,iBACR8iC,EAAKD,EACLA,EAAK,GAET,MAAME,EAAezuC,EAAOQ,OAAO6tC,WAAWC,UAAYntC,KAAKC,IAAI,EAAID,KAAK8N,IAAIpN,EAAQX,UAAW,GAAK,EAAIC,KAAKE,IAAIF,KAAKC,IAAIS,EAAQX,UAAW,GAAI,GAC/Iuc,EAAW6Q,GAAa9tB,EAAQqB,GACtC4b,EAASlkB,MAAMkjC,QAAUgS,EACzBhxB,EAASlkB,MAAM6D,UAAY,eAAemxC,QAASC,WACvD,GAmBAn9B,cAjBkB9Q,IAClB,MAAMouB,EAAoB3uB,EAAOkK,OAAO5M,KAAIuE,GAAWD,EAAoBC,KAC3E8sB,EAAkBt2B,SAAQsE,IACtBA,EAAGpD,MAAMysB,mBAAqB,GAAGzlB,KAAY,IAEjDmuB,GAA2B,CACvB1uB,SACAO,WACAouB,oBACAC,WAAW,GACb,EAQFf,gBAAiB,KAAM,CACnBtjB,cAAe,EACf2E,eAAgB,EAChB0B,qBAAqB,EACrBtD,aAAc,EACdgJ,kBAAmBtW,EAAOQ,OAAOuN,WAG7C,EAEA,SAAoBhO,GAChB,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EACJ4pB,EAAa,CACT+kB,WAAY,CACRtgB,cAAc,EACdugB,QAAQ,EACRC,aAAc,GACdC,YAAa,OAGrB,MAAMC,EAAqB,CAACjtC,EAASX,EAAUwK,KAC3C,IAAIqjC,EAAerjC,EAAe7J,EAAQ9I,cAAc,6BAA+B8I,EAAQ9I,cAAc,4BACzGi2C,EAActjC,EAAe7J,EAAQ9I,cAAc,8BAAgC8I,EAAQ9I,cAAc,+BACxGg2C,IACDA,EAAe31C,EAAc,OAAO,iDAAgDsS,EAAe,OAAS,QAAQtP,MAAM,MAC1HyF,EAAQ+Y,OAAOm0B,IAEdC,IACDA,EAAc51C,EAAc,OAAO,iDAAgDsS,EAAe,QAAU,WAAWtP,MAAM,MAC7HyF,EAAQ+Y,OAAOo0B,IAEfD,IAAcA,EAAax1C,MAAMkjC,QAAUt7B,KAAKC,KAAKF,EAAU,IAC/D8tC,IAAaA,EAAYz1C,MAAMkjC,QAAUt7B,KAAKC,IAAIF,EAAU,GAAE,EA6HtE0sB,GAAW,CACPxe,OAAQ,OACRpP,SACAuH,KACAiP,aAvHiB,KACjB,MAAM7Z,GACFA,EAAE+D,UACFA,EAASwJ,OACTA,EACAtE,MAAOiuB,EACP/tB,OAAQguB,EACRznB,aAAcC,EACdhI,KAAM8H,EAAUxH,QAChBA,GACA5E,EACEQ,EAASR,EAAOQ,OAAOkuC,WACvBhjC,EAAe1L,EAAO0L,eACtBc,EAAYxM,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAC1D,IACIuiC,EADAC,EAAgB,EAEhB1uC,EAAOmuC,SACHjjC,GACAujC,EAAejvC,EAAOU,UAAU3H,cAAc,uBACzCk2C,IACDA,EAAe71C,EAAc,MAAO,sBACpC4G,EAAOU,UAAUka,OAAOq0B,IAE5BA,EAAa11C,MAAMuM,OAAS,GAAG+tB,QAE/Bob,EAAetyC,EAAG5D,cAAc,uBAC3Bk2C,IACDA,EAAe71C,EAAc,MAAO,sBACpCuD,EAAGie,OAAOq0B,MAItB,IAAK,IAAIrwC,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EAAG,CACvC,MAAMiD,EAAUqI,EAAOtL,GACvB,IAAIiR,EAAajR,EACb4N,IACAqD,EAAajE,SAAS/J,EAAQ+T,aAAa,2BAA4B,KAE3E,IAAIu5B,EAA0B,GAAbt/B,EACb43B,EAAQtmC,KAAK4N,MAAMogC,EAAa,KAChC7iC,IACA6iC,GAAcA,EACd1H,EAAQtmC,KAAK4N,OAAOogC,EAAa,MAErC,MAAMjuC,EAAWC,KAAKC,IAAID,KAAKE,IAAIQ,EAAQX,SAAU,IAAK,GAC1D,IAAIqtC,EAAK,EACLC,EAAK,EACLY,EAAK,EACLv/B,EAAa,GAAM,GACnB0+B,EAAc,GAAR9G,EAAYr7B,EAClBgjC,EAAK,IACGv/B,EAAa,GAAK,GAAM,GAChC0+B,EAAK,EACLa,EAAc,GAAR3H,EAAYr7B,IACVyD,EAAa,GAAK,GAAM,GAChC0+B,EAAKniC,EAAqB,EAARq7B,EAAYr7B,EAC9BgjC,EAAKhjC,IACGyD,EAAa,GAAK,GAAM,IAChC0+B,GAAMniC,EACNgjC,EAAK,EAAIhjC,EAA0B,EAAbA,EAAiBq7B,GAEvCn7B,IACAiiC,GAAMA,GAEL7iC,IACD8iC,EAAKD,EACLA,EAAK,GAET,MAAMnxC,EAAY,WAAWsO,EAAe,GAAKyjC,iBAA0BzjC,EAAeyjC,EAAa,qBAAqBZ,QAASC,QAASY,OAC1IluC,GAAY,GAAKA,GAAY,IAC7BguC,EAA6B,GAAbr/B,EAA6B,GAAX3O,EAC9BoL,IAAK4iC,EAA8B,IAAbr/B,EAA6B,GAAX3O,GACxClB,EAAO4E,SAAW5E,EAAO4E,QAAQwC,WAAajG,KAAK8N,IAAIigC,GAAiB,GAAK,GAAM,IACnFA,GAAiB,OAGzBrtC,EAAQtI,MAAM6D,UAAYA,EACtBoD,EAAO4tB,cACP0gB,EAAmBjtC,EAASX,EAAUwK,EAE9C,CAGA,GAFAhL,EAAUnH,MAAM81C,gBAAkB,YAAYjjC,EAAa,MAC3D1L,EAAUnH,MAAM,4BAA8B,YAAY6S,EAAa,MACnE5L,EAAOmuC,OACP,GAAIjjC,EACAujC,EAAa11C,MAAM6D,UAAY,oBAAoBy2B,EAAc,EAAIrzB,EAAOouC,oBAAoB/a,EAAc,8CAA8CrzB,EAAOquC,mBAChK,CACH,MAAMS,EAAcnuC,KAAK8N,IAAIigC,GAA4D,GAA3C/tC,KAAK4N,MAAM5N,KAAK8N,IAAIigC,GAAiB,IAC7Ep8B,EAAa,KAAO3R,KAAKouC,IAAkB,EAAdD,EAAkBnuC,KAAKK,GAAK,KAAO,EAAIL,KAAKI,IAAkB,EAAd+tC,EAAkBnuC,KAAKK,GAAK,KAAO,GAChHguC,EAAShvC,EAAOquC,YAChBY,EAASjvC,EAAOquC,YAAc/7B,EAC9Bye,EAAS/wB,EAAOouC,aACtBK,EAAa11C,MAAM6D,UAAY,WAAWoyC,SAAcC,uBAA4B3b,EAAe,EAAIvC,SAAcuC,EAAe,EAAI2b,yBAC5I,CAEJ,MAAMC,GAAW9qC,EAAQ6B,UAAY7B,EAAQqC,YAAcrC,EAAQ4B,oBAAsB4F,EAAa,EAAI,EAC1G1L,EAAUnH,MAAM6D,UAAY,qBAAqBsyC,gBAAsB1vC,EAAO0L,eAAiB,EAAIwjC,iBAA6BlvC,EAAO0L,gBAAkBwjC,EAAgB,QACzKxuC,EAAUnH,MAAMsG,YAAY,4BAA6B,GAAG6vC,MAAY,EAuBxEr+B,cArBkB9Q,IAClB,MAAM5D,GACFA,EAAEuN,OACFA,GACAlK,EAOJ,GANAkK,EAAO7R,SAAQwJ,IACXA,EAAQtI,MAAMysB,mBAAqB,GAAGzlB,MACtCsB,EAAQ7I,iBAAiB,gHAAgHX,SAAQm/B,IAC7IA,EAAMj+B,MAAMysB,mBAAqB,GAAGzlB,KAAY,GAClD,IAEFP,EAAOQ,OAAOkuC,WAAWC,SAAW3uC,EAAO0L,eAAgB,CAC3D,MAAM2iB,EAAW1xB,EAAG5D,cAAc,uBAC9Bs1B,IAAUA,EAAS90B,MAAMysB,mBAAqB,GAAGzlB,MACzD,GAQAwtB,gBAjIoB,KAEpB,MAAMriB,EAAe1L,EAAO0L,eAC5B1L,EAAOkK,OAAO7R,SAAQwJ,IAClB,MAAMX,EAAWC,KAAKC,IAAID,KAAKE,IAAIQ,EAAQX,SAAU,IAAK,GAC1D4tC,EAAmBjtC,EAASX,EAAUwK,EAAa,GACrD,EA4HFsiB,gBAAiB,IAAMhuB,EAAOQ,OAAOkuC,WACrC5gB,YAAa,KAAM,EACnBD,gBAAiB,KAAM,CACnBtjB,cAAe,EACf2E,eAAgB,EAChB0B,qBAAqB,EACrBqR,gBAAiB,EACjB3U,aAAc,EACdQ,gBAAgB,EAChBwI,kBAAkB,KAG9B,EAaA,SAAoBvW,GAChB,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EACJ4pB,EAAa,CACTgmB,WAAY,CACRvhB,cAAc,EACdwhB,eAAe,KAGvB,MAAMd,EAAqB,CAACjtC,EAASX,KACjC,IAAI6tC,EAAe/uC,EAAO0L,eAAiB7J,EAAQ9I,cAAc,6BAA+B8I,EAAQ9I,cAAc,4BAClHi2C,EAAchvC,EAAO0L,eAAiB7J,EAAQ9I,cAAc,8BAAgC8I,EAAQ9I,cAAc,+BACjHg2C,IACDA,EAAe/f,GAAa,OAAQntB,EAAS7B,EAAO0L,eAAiB,OAAS,QAE7EsjC,IACDA,EAAchgB,GAAa,OAAQntB,EAAS7B,EAAO0L,eAAiB,QAAU,WAE9EqjC,IAAcA,EAAax1C,MAAMkjC,QAAUt7B,KAAKC,KAAKF,EAAU,IAC/D8tC,IAAaA,EAAYz1C,MAAMkjC,QAAUt7B,KAAKC,IAAIF,EAAU,GAAE,EAsEtE0sB,GAAW,CACPxe,OAAQ,OACRpP,SACAuH,KACAiP,aA7DiB,KACjB,MAAMtM,OACFA,EACAmC,aAAcC,GACdtM,EACEQ,EAASR,EAAOQ,OAAOmvC,WAC7B,IAAK,IAAI/wC,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EAAG,CACvC,MAAMiD,EAAUqI,EAAOtL,GACvB,IAAIsC,EAAWW,EAAQX,SACnBlB,EAAOQ,OAAOmvC,WAAWC,gBACzB1uC,EAAWC,KAAKC,IAAID,KAAKE,IAAIQ,EAAQX,SAAU,IAAK,IAExD,MAAMqwB,EAAS1vB,EAAQgQ,kBAEvB,IAAIg+B,GADY,IAAM3uC,EAElB4uC,EAAU,EACVvB,EAAKvuC,EAAOQ,OAAOuN,SAAWwjB,EAASvxB,EAAOI,WAAamxB,EAC3Did,EAAK,EACJxuC,EAAO0L,eAKDY,IACPujC,GAAWA,IALXrB,EAAKD,EACLA,EAAK,EACLuB,GAAWD,EACXA,EAAU,GAIV7vC,EAAO4E,SAAW5E,EAAO4E,QAAQwC,YAC7BjG,KAAK8N,IAAI4gC,GAAW,GAAK,GAAM,IAC/BA,GAAW,MAEX1uC,KAAK8N,IAAI6gC,GAAW,GAAK,GAAM,IAC/BA,GAAW,OAGnBjuC,EAAQtI,MAAMw2C,QAAU5uC,KAAK8N,IAAI9N,KAAKsmC,MAAMvmC,IAAagJ,EAAO3R,OAC5DiI,EAAO4tB,cACP0gB,EAAmBjtC,EAASX,GAEhC,MAAM9D,EAAY,eAAemxC,QAASC,qBAAsBsB,iBAAuBD,QACtEvhB,GAAa9tB,EAAQqB,GAC7BtI,MAAM6D,UAAYA,CAC/B,GAqBAiU,cAnBkB9Q,IAClB,MAAMouB,EAAoB3uB,EAAOkK,OAAO5M,KAAIuE,GAAWD,EAAoBC,KAC3E8sB,EAAkBt2B,SAAQsE,IACtBA,EAAGpD,MAAMysB,mBAAqB,GAAGzlB,MACjC5D,EAAG3D,iBAAiB,gHAAgHX,SAAQg2B,IACxIA,EAAS90B,MAAMysB,mBAAqB,GAAGzlB,KAAY,GACrD,IAENmuB,GAA2B,CACvB1uB,SACAO,WACAouB,qBACF,EAQFZ,gBA1EoB,KAEpB/tB,EAAOQ,OAAOmvC,WACd3vC,EAAOkK,OAAO7R,SAAQwJ,IAClB,IAAIX,EAAWW,EAAQX,SACnBlB,EAAOQ,OAAOmvC,WAAWC,gBACzB1uC,EAAWC,KAAKC,IAAID,KAAKE,IAAIQ,EAAQX,SAAU,IAAK,IAExD4tC,EAAmBjtC,EAASX,EAAS,GACvC,EAkEF8sB,gBAAiB,IAAMhuB,EAAOQ,OAAOmvC,WACrC7hB,YAAa,KAAM,EACnBD,gBAAiB,KAAM,CACnBtjB,cAAe,EACf2E,eAAgB,EAChB0B,qBAAqB,EACrBtD,aAAc,EACdgJ,kBAAmBtW,EAAOQ,OAAOuN,WAG7C,EAEA,SAAyBhO,GACrB,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EACJ4pB,EAAa,CACTqmB,gBAAiB,CACbjS,OAAQ,GACRkS,QAAS,EACTC,MAAO,IACP1U,MAAO,EACP2U,SAAU,EACV/hB,cAAc,KA+EtBR,GAAW,CACPxe,OAAQ,YACRpP,SACAuH,KACAiP,aAhFiB,KACjB,MACI5Q,MAAOiuB,EACP/tB,OAAQguB,EAAY5pB,OACpBA,EAAM6C,gBACNA,GACA/M,EACEQ,EAASR,EAAOQ,OAAOwvC,gBACvBtkC,EAAe1L,EAAO0L,eACtBtO,EAAY4C,EAAOI,UACnBgwC,EAAS1kC,EAA4BmoB,EAAc,EAA1Bz2B,EAA2C02B,EAAe,EAA3B12B,EACxD2gC,EAASryB,EAAelL,EAAOu9B,QAAUv9B,EAAOu9B,OAChD39B,EAAYI,EAAO0vC,MAEzB,IAAK,IAAItxC,EAAI,EAAGrG,EAAS2R,EAAO3R,OAAQqG,EAAIrG,EAAQqG,GAAK,EAAG,CACxD,MAAMiD,EAAUqI,EAAOtL,GACjBqP,EAAYlB,EAAgBnO,GAE5ByxC,GAAgBD,EADFvuC,EAAQgQ,kBACiB5D,EAAY,GAAKA,EACxDqiC,EAA8C,mBAApB9vC,EAAO2vC,SAA0B3vC,EAAO2vC,SAASE,GAAgBA,EAAe7vC,EAAO2vC,SACvH,IAAIN,EAAUnkC,EAAeqyB,EAASuS,EAAmB,EACrDR,EAAUpkC,EAAe,EAAIqyB,EAASuS,EAEtCC,GAAcnwC,EAAYe,KAAK8N,IAAIqhC,GACnCL,EAAUzvC,EAAOyvC,QAEE,iBAAZA,IAAkD,IAA1BA,EAAQ/wC,QAAQ,OAC/C+wC,EAAUjyC,WAAWwC,EAAOyvC,SAAW,IAAMhiC,GAEjD,IAAI4zB,EAAan2B,EAAe,EAAIukC,EAAUK,EAC1C1O,EAAal2B,EAAeukC,EAAUK,EAAmB,EACzD9U,EAAQ,GAAK,EAAIh7B,EAAOg7B,OAASr6B,KAAK8N,IAAIqhC,GAG1CnvC,KAAK8N,IAAI2yB,GAAc,OAAOA,EAAa,GAC3CzgC,KAAK8N,IAAI4yB,GAAc,OAAOA,EAAa,GAC3C1gC,KAAK8N,IAAIshC,GAAc,OAAOA,EAAa,GAC3CpvC,KAAK8N,IAAI4gC,GAAW,OAAOA,EAAU,GACrC1uC,KAAK8N,IAAI6gC,GAAW,OAAOA,EAAU,GACrC3uC,KAAK8N,IAAIusB,GAAS,OAAOA,EAAQ,GACjCx7B,EAAO4E,SAAW5E,EAAO4E,QAAQwC,YAC7BjG,KAAK8N,IAAI4gC,GAAW,GAAK,GAAM,IAC/BA,GAAW,MAEX1uC,KAAK8N,IAAI6gC,GAAW,GAAK,GAAM,IAC/BA,GAAW,OAGnB,MAAMU,EAAiB,eAAe5O,OAAgBC,OAAgB0O,iBAA0BT,iBAAuBD,eAAqBrU,KAI5I,GAHiBlN,GAAa9tB,EAAQqB,GAC7BtI,MAAM6D,UAAYozC,EAC3B3uC,EAAQtI,MAAMw2C,OAAmD,EAAzC5uC,KAAK8N,IAAI9N,KAAKsmC,MAAM6I,IACxC9vC,EAAO4tB,aAAc,CAErB,IAAIqiB,EAAiB/kC,EAAe7J,EAAQ9I,cAAc,6BAA+B8I,EAAQ9I,cAAc,4BAC3G23C,EAAgBhlC,EAAe7J,EAAQ9I,cAAc,8BAAgC8I,EAAQ9I,cAAc,+BAC1G03C,IACDA,EAAiBzhB,GAAa,YAAantB,EAAS6J,EAAe,OAAS,QAE3EglC,IACDA,EAAgB1hB,GAAa,YAAantB,EAAS6J,EAAe,QAAU,WAE5E+kC,IAAgBA,EAAel3C,MAAMkjC,QAAU6T,EAAmB,EAAIA,EAAmB,GACzFI,IAAeA,EAAcn3C,MAAMkjC,SAAW6T,EAAmB,GAAKA,EAAmB,EACjG,CACJ,GAgBAj/B,cAdkB9Q,IACQP,EAAOkK,OAAO5M,KAAIuE,GAAWD,EAAoBC,KACzDxJ,SAAQsE,IACtBA,EAAGpD,MAAMysB,mBAAqB,GAAGzlB,MACjC5D,EAAG3D,iBAAiB,gHAAgHX,SAAQg2B,IACxIA,EAAS90B,MAAMysB,mBAAqB,GAAGzlB,KAAY,GACrD,GACJ,EAQFutB,YAAa,KAAM,EACnBD,gBAAiB,KAAM,CACnBjd,qBAAqB,KAGjC,EAEA,SAAwB7Q,GACpB,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EACJ4pB,EAAa,CACTgnB,eAAgB,CACZC,cAAe,EACfC,mBAAmB,EACnBC,mBAAoB,EACpBhjB,aAAa,EACbpZ,KAAM,CACFtU,UAAW,CAAC,EAAG,EAAG,GAClB29B,OAAQ,CAAC,EAAG,EAAG,GACftB,QAAS,EACTjB,MAAO,GAEXlnB,KAAM,CACFlU,UAAW,CAAC,EAAG,EAAG,GAClB29B,OAAQ,CAAC,EAAG,EAAG,GACftB,QAAS,EACTjB,MAAO,MAInB,MAAMuV,EAAoB1oB,GACD,iBAAVA,EAA2BA,EAC/B,GAAGA,MAmGduF,GAAW,CACPxe,OAAQ,WACRpP,SACAuH,KACAiP,aArGiB,KACjB,MAAMtM,OACFA,EAAMxJ,UACNA,EAASqM,gBACTA,GACA/M,EACEQ,EAASR,EAAOQ,OAAOmwC,gBAEzBG,mBAAoBh+B,GACpBtS,EACEwwC,EAAmBhxC,EAAOQ,OAAOsN,eACvC,GAAIkjC,EAAkB,CAClB,MAAMC,EAASlkC,EAAgB,GAAK,EAAI/M,EAAOQ,OAAOyM,oBAAsB,EAC5EvM,EAAUnH,MAAM6D,UAAY,yBAAyB6zC,OACzD,CACA,IAAK,IAAIryC,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EAAG,CACvC,MAAMiD,EAAUqI,EAAOtL,GACjBuT,EAAgBtQ,EAAQX,SACxBA,EAAWC,KAAKE,IAAIF,KAAKC,IAAIS,EAAQX,UAAWV,EAAOowC,eAAgBpwC,EAAOowC,eACpF,IAAIh+B,EAAmB1R,EAClB8vC,IACDp+B,EAAmBzR,KAAKE,IAAIF,KAAKC,IAAIS,EAAQ+Q,kBAAmBpS,EAAOowC,eAAgBpwC,EAAOowC,gBAElG,MAAMrf,EAAS1vB,EAAQgQ,kBACjBuG,EAAI,CAACpY,EAAOQ,OAAOuN,SAAWwjB,EAASvxB,EAAOI,WAAamxB,EAAQ,EAAG,GACtE2f,EAAI,CAAC,EAAG,EAAG,GACjB,IAAIC,GAAS,EACRnxC,EAAO0L,iBACR0M,EAAE,GAAKA,EAAE,GACTA,EAAE,GAAK,GAEX,IAAIrP,EAAO,CACP3I,UAAW,CAAC,EAAG,EAAG,GAClB29B,OAAQ,CAAC,EAAG,EAAG,GACfvC,MAAO,EACPiB,QAAS,GAETv7B,EAAW,GACX6H,EAAOvI,EAAO8T,KACd68B,GAAS,GACFjwC,EAAW,IAClB6H,EAAOvI,EAAOkU,KACdy8B,GAAS,GAGb/4B,EAAE/f,SAAQ,CAACgwB,EAAO1f,KACdyP,EAAEzP,GAAS,QAAQ0f,UAAc0oB,EAAkBhoC,EAAK3I,UAAUuI,SAAaxH,KAAK8N,IAAI/N,EAAW4R,MAAe,IAGtHo+B,EAAE74C,SAAQ,CAACgwB,EAAO1f,KACd,IAAI6Q,EAAMzQ,EAAKg1B,OAAOp1B,GAASxH,KAAK8N,IAAI/N,EAAW4R,GAC/C9S,EAAO4E,SAAW5E,EAAO4E,QAAQwC,WAAajG,KAAK8N,IAAIuK,GAAO,GAAK,GAAM,IACzEA,GAAO,MAEX03B,EAAEvoC,GAAS6Q,CAAG,IAElB3X,EAAQtI,MAAMw2C,QAAU5uC,KAAK8N,IAAI9N,KAAKsmC,MAAMt1B,IAAkBjI,EAAO3R,OACrE,MAAM64C,EAAkBh5B,EAAE3a,KAAK,MACzB4zC,EAAe,WAAWH,EAAE,kBAAkBA,EAAE,kBAAkBA,EAAE,SACpEI,EAAc1+B,EAAmB,EAAI,SAAS,GAAK,EAAI7J,EAAKyyB,OAAS5oB,EAAmBE,KAAgB,SAAS,GAAK,EAAI/J,EAAKyyB,OAAS5oB,EAAmBE,KAC3Jy+B,EAAgB3+B,EAAmB,EAAI,GAAK,EAAI7J,EAAK0zB,SAAW7pB,EAAmBE,EAAa,GAAK,EAAI/J,EAAK0zB,SAAW7pB,EAAmBE,EAC5I1V,EAAY,eAAeg0C,MAAoBC,KAAgBC,IAGrE,GAAIH,GAAUpoC,EAAK4lC,SAAWwC,EAAQ,CAClC,IAAI9iB,EAAWxsB,EAAQ9I,cAAc,wBAIrC,IAHKs1B,GAAYtlB,EAAK4lC,SAClBtgB,EAAWW,GAAa,WAAYntB,IAEpCwsB,EAAU,CACV,MAAMmjB,EAAgBhxC,EAAOqwC,kBAAoB3vC,GAAY,EAAIV,EAAOowC,eAAiB1vC,EACzFmtB,EAAS90B,MAAMkjC,QAAUt7B,KAAKE,IAAIF,KAAKC,IAAID,KAAK8N,IAAIuiC,GAAgB,GAAI,EAC5E,CACJ,CACA,MAAM/zB,EAAW6Q,GAAa9tB,EAAQqB,GACtC4b,EAASlkB,MAAM6D,UAAYA,EAC3BqgB,EAASlkB,MAAMkjC,QAAU8U,EACrBxoC,EAAK9O,SACLwjB,EAASlkB,MAAM81C,gBAAkBtmC,EAAK9O,OAE9C,GAsBAoX,cApBkB9Q,IAClB,MAAMouB,EAAoB3uB,EAAOkK,OAAO5M,KAAIuE,GAAWD,EAAoBC,KAC3E8sB,EAAkBt2B,SAAQsE,IACtBA,EAAGpD,MAAMysB,mBAAqB,GAAGzlB,MACjC5D,EAAG3D,iBAAiB,wBAAwBX,SAAQg2B,IAChDA,EAAS90B,MAAMysB,mBAAqB,GAAGzlB,KAAY,GACrD,IAENmuB,GAA2B,CACvB1uB,SACAO,WACAouB,oBACAC,WAAW,GACb,EAQFd,YAAa,IAAM9tB,EAAOQ,OAAOmwC,eAAe7iB,YAChDD,gBAAiB,KAAM,CACnBjd,qBAAqB,EACrB0F,kBAAmBtW,EAAOQ,OAAOuN,WAG7C,EAEA,SAAqBhO,GACjB,IAAIC,OACAA,EAAM2pB,aACNA,EAAYpiB,GACZA,GACAxH,EACJ4pB,EAAa,CACT8nB,YAAa,CACTrjB,cAAc,EACd2P,QAAQ,EACR2T,eAAgB,EAChBC,eAAgB,KA6FxB/jB,GAAW,CACPxe,OAAQ,QACRpP,SACAuH,KACAiP,aA9FiB,KACjB,MAAMtM,OACFA,EAAMQ,YACNA,EACA2B,aAAcC,GACdtM,EACEQ,EAASR,EAAOQ,OAAOixC,aACvBz1B,eACFA,EAAc6B,UACdA,GACA7d,EAAO+b,gBACLxF,EAAmBjK,GAAOtM,EAAOI,UAAYJ,EAAOI,UAC1D,IAAK,IAAIxB,EAAI,EAAGA,EAAIsL,EAAO3R,OAAQqG,GAAK,EAAG,CACvC,MAAMiD,EAAUqI,EAAOtL,GACjBuT,EAAgBtQ,EAAQX,SACxBA,EAAWC,KAAKE,IAAIF,KAAKC,IAAI+Q,GAAgB,GAAI,GACvD,IAAIof,EAAS1vB,EAAQgQ,kBACjB7R,EAAOQ,OAAOsN,iBAAmB9N,EAAOQ,OAAOuN,UAC/C/N,EAAOU,UAAUnH,MAAM6D,UAAY,cAAc4C,EAAOoS,qBAExDpS,EAAOQ,OAAOsN,gBAAkB9N,EAAOQ,OAAOuN,UAC9CwjB,GAAUrnB,EAAO,GAAG2H,mBAExB,IAAI+/B,EAAK5xC,EAAOQ,OAAOuN,SAAWwjB,EAASvxB,EAAOI,WAAamxB,EAC3DsgB,EAAK,EACT,MAAMC,GAAM,IAAM3wC,KAAK8N,IAAI/N,GAC3B,IAAIs6B,EAAQ,EACRuC,GAAUv9B,EAAOkxC,eAAiBxwC,EAClC6wC,EAAQvxC,EAAOmxC,eAAsC,IAArBxwC,KAAK8N,IAAI/N,GAC7C,MAAM2O,EAAa7P,EAAOyM,SAAWzM,EAAOQ,OAAOiM,QAAQC,QAAU1M,EAAOyM,QAAQ1B,KAAOnM,EAAIA,EACzFozC,GAAiBniC,IAAenF,GAAemF,IAAenF,EAAc,IAAMxJ,EAAW,GAAKA,EAAW,IAAM2c,GAAa7d,EAAOQ,OAAOuN,UAAYwI,EAAmByF,EAC7Ki2B,GAAiBpiC,IAAenF,GAAemF,IAAenF,EAAc,IAAMxJ,EAAW,GAAKA,GAAY,IAAM2c,GAAa7d,EAAOQ,OAAOuN,UAAYwI,EAAmByF,EACpL,GAAIg2B,GAAiBC,EAAe,CAChC,MAAMC,GAAe,EAAI/wC,KAAK8N,KAAK9N,KAAK8N,IAAI/N,GAAY,IAAO,MAAS,GACxE68B,IAAW,GAAK78B,EAAWgxC,EAC3B1W,IAAU,GAAM0W,EAChBH,GAAS,GAAKG,EACdL,GAAS,GAAKK,EAAc/wC,KAAK8N,IAAI/N,GAAhC,GACT,CAUA,GAPI0wC,EAFA1wC,EAAW,EAEN,QAAQ0wC,OAAQtlC,EAAM,IAAM,QAAQylC,EAAQ5wC,KAAK8N,IAAI/N,QACnDA,EAAW,EAEb,QAAQ0wC,OAAQtlC,EAAM,IAAM,SAASylC,EAAQ5wC,KAAK8N,IAAI/N,QAEtD,GAAG0wC,OAEP5xC,EAAO0L,eAAgB,CACxB,MAAMymC,EAAQN,EACdA,EAAKD,EACLA,EAAKO,CACT,CACA,MAAMb,EAAcpwC,EAAW,EAAI,IAAG,GAAK,EAAIs6B,GAASt6B,GAAa,IAAG,GAAK,EAAIs6B,GAASt6B,GAGpF9D,EAAY,yBACZw0C,MAAOC,MAAOC,yBAClBtxC,EAAOu9B,OAASzxB,GAAOyxB,EAASA,EAAS,wBAC3CuT,aAIA,GAAI9wC,EAAO4tB,aAAc,CAErB,IAAIC,EAAWxsB,EAAQ9I,cAAc,wBAChCs1B,IACDA,EAAWW,GAAa,QAASntB,IAEjCwsB,IAAUA,EAAS90B,MAAMkjC,QAAUt7B,KAAKE,IAAIF,KAAKC,KAAKD,KAAK8N,IAAI/N,GAAY,IAAO,GAAK,GAAI,GACnG,CACAW,EAAQtI,MAAMw2C,QAAU5uC,KAAK8N,IAAI9N,KAAKsmC,MAAMt1B,IAAkBjI,EAAO3R,OACpD+1B,GAAa9tB,EAAQqB,GAC7BtI,MAAM6D,UAAYA,CAC/B,GAqBAiU,cAnBkB9Q,IAClB,MAAMouB,EAAoB3uB,EAAOkK,OAAO5M,KAAIuE,GAAWD,EAAoBC,KAC3E8sB,EAAkBt2B,SAAQsE,IACtBA,EAAGpD,MAAMysB,mBAAqB,GAAGzlB,MACjC5D,EAAG3D,iBAAiB,wBAAwBX,SAAQg2B,IAChDA,EAAS90B,MAAMysB,mBAAqB,GAAGzlB,KAAY,GACrD,IAENmuB,GAA2B,CACvB1uB,SACAO,WACAouB,qBACF,EAQFb,YAAa,KAAM,EACnBD,gBAAiB,KAAM,CACnBjd,qBAAqB,EACrB0F,kBAAmBtW,EAAOQ,OAAOuN,WAG7C,GAmBA,OAFAnW,GAAO00B,IAAI9C,IAEJ5xB,EAEV,CAv6SY","ignoreList":[],"sourcesContent":["/**\n * Swiper 11.1.4\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2024 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: May 30, 2024\n */\n\nvar Swiper = (function () {\n    'use strict';\n\n    /**\n     * SSR Window 4.0.2\n     * Better handling for window object in SSR environment\n     * https://github.com/nolimits4web/ssr-window\n     *\n     * Copyright 2021, Vladimir Kharlampidi\n     *\n     * Licensed under MIT\n     *\n     * Released on: December 13, 2021\n     */\n    /* eslint-disable no-param-reassign */\n    function isObject$1(obj) {\n        return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n    }\n    function extend$1(target, src) {\n        if (target === void 0) {\n            target = {};\n        }\n        if (src === void 0) {\n            src = {};\n        }\n        Object.keys(src).forEach(key => {\n            if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n                extend$1(target[key], src[key]);\n            }\n        });\n    }\n    const ssrDocument = {\n        body: {},\n        addEventListener() {},\n        removeEventListener() {},\n        activeElement: {\n            blur() {},\n            nodeName: ''\n        },\n        querySelector() {\n            return null;\n        },\n        querySelectorAll() {\n            return [];\n        },\n        getElementById() {\n            return null;\n        },\n        createEvent() {\n            return {\n                initEvent() {}\n            };\n        },\n        createElement() {\n            return {\n                children: [],\n                childNodes: [],\n                style: {},\n                setAttribute() {},\n                getElementsByTagName() {\n                    return [];\n                }\n            };\n        },\n        createElementNS() {\n            return {};\n        },\n        importNode() {\n            return null;\n        },\n        location: {\n            hash: '',\n            host: '',\n            hostname: '',\n            href: '',\n            origin: '',\n            pathname: '',\n            protocol: '',\n            search: ''\n        }\n    };\n    function getDocument() {\n        const doc = typeof document !== 'undefined' ? document : {};\n        extend$1(doc, ssrDocument);\n        return doc;\n    }\n    const ssrWindow = {\n        document: ssrDocument,\n        navigator: {\n            userAgent: ''\n        },\n        location: {\n            hash: '',\n            host: '',\n            hostname: '',\n            href: '',\n            origin: '',\n            pathname: '',\n            protocol: '',\n            search: ''\n        },\n        history: {\n            replaceState() {},\n            pushState() {},\n            go() {},\n            back() {}\n        },\n        CustomEvent: function CustomEvent() {\n            return this;\n        },\n        addEventListener() {},\n        removeEventListener() {},\n        getComputedStyle() {\n            return {\n                getPropertyValue() {\n                    return '';\n                }\n            };\n        },\n        Image() {},\n        Date() {},\n        screen: {},\n        setTimeout() {},\n        clearTimeout() {},\n        matchMedia() {\n            return {};\n        },\n        requestAnimationFrame(callback) {\n            if (typeof setTimeout === 'undefined') {\n                callback();\n                return null;\n            }\n            return setTimeout(callback, 0);\n        },\n        cancelAnimationFrame(id) {\n            if (typeof setTimeout === 'undefined') {\n                return;\n            }\n            clearTimeout(id);\n        }\n    };\n    function getWindow() {\n        const win = typeof window !== 'undefined' ? window : {};\n        extend$1(win, ssrWindow);\n        return win;\n    }\n\n    function classesToTokens(classes) {\n        if (classes === void 0) {\n            classes = '';\n        }\n        return classes.trim().split(' ').filter(c => !!c.trim());\n    }\n\n    function deleteProps(obj) {\n        const object = obj;\n        Object.keys(object).forEach(key => {\n            try {\n                object[key] = null;\n            } catch (e) {\n                // no getter for object\n            }\n            try {\n                delete object[key];\n            } catch (e) {\n                // something got wrong\n            }\n        });\n    }\n    function nextTick(callback, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return setTimeout(callback, delay);\n    }\n    function now() {\n        return Date.now();\n    }\n    function getComputedStyle$1(el) {\n        const window = getWindow();\n        let style;\n        if (window.getComputedStyle) {\n            style = window.getComputedStyle(el, null);\n        }\n        if (!style && el.currentStyle) {\n            style = el.currentStyle;\n        }\n        if (!style) {\n            style = el.style;\n        }\n        return style;\n    }\n    function getTranslate(el, axis) {\n        if (axis === void 0) {\n            axis = 'x';\n        }\n        const window = getWindow();\n        let matrix;\n        let curTransform;\n        let transformMatrix;\n        const curStyle = getComputedStyle$1(el);\n        if (window.WebKitCSSMatrix) {\n            curTransform = curStyle.transform || curStyle.webkitTransform;\n            if (curTransform.split(',').length > 6) {\n                curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n            }\n            // Some old versions of Webkit choke when 'none' is passed; pass\n            // empty string instead in this case\n            transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n        } else {\n            transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n            matrix = transformMatrix.toString().split(',');\n        }\n        if (axis === 'x') {\n            // Latest Chrome and webkits Fix\n            if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n            // Crazy IE10 Matrix\n            else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n            // Normal Browsers\n            else curTransform = parseFloat(matrix[4]);\n        }\n        if (axis === 'y') {\n            // Latest Chrome and webkits Fix\n            if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n            // Crazy IE10 Matrix\n            else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n            // Normal Browsers\n            else curTransform = parseFloat(matrix[5]);\n        }\n        return curTransform || 0;\n    }\n    function isObject(o) {\n        return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n    }\n    function isNode(node) {\n        // eslint-disable-next-line\n        if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n            return node instanceof HTMLElement;\n        }\n        return node && (node.nodeType === 1 || node.nodeType === 11);\n    }\n    function extend() {\n        const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n        const noExtend = ['__proto__', 'constructor', 'prototype'];\n        for (let i = 1; i < arguments.length; i += 1) {\n            const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n            if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n                const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);\n                for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n                    const nextKey = keysArray[nextIndex];\n                    const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n                    if (desc !== undefined && desc.enumerable) {\n                        if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                            if (nextSource[nextKey].__swiper__) {\n                                to[nextKey] = nextSource[nextKey];\n                            } else {\n                                extend(to[nextKey], nextSource[nextKey]);\n                            }\n                        } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                            to[nextKey] = {};\n                            if (nextSource[nextKey].__swiper__) {\n                                to[nextKey] = nextSource[nextKey];\n                            } else {\n                                extend(to[nextKey], nextSource[nextKey]);\n                            }\n                        } else {\n                            to[nextKey] = nextSource[nextKey];\n                        }\n                    }\n                }\n            }\n        }\n        return to;\n    }\n    function setCSSProperty(el, varName, varValue) {\n        el.style.setProperty(varName, varValue);\n    }\n    function animateCSSModeScroll(_ref) {\n        let {\n            swiper,\n            targetPosition,\n            side\n        } = _ref;\n        const window = getWindow();\n        const startPosition = -swiper.translate;\n        let startTime = null;\n        let time;\n        const duration = swiper.params.speed;\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        window.cancelAnimationFrame(swiper.cssModeFrameID);\n        const dir = targetPosition > startPosition ? 'next' : 'prev';\n        const isOutOfBound = (current, target) => {\n            return dir === 'next' && current >= target || dir === 'prev' && current <= target;\n        };\n        const animate = () => {\n            time = new Date().getTime();\n            if (startTime === null) {\n                startTime = time;\n            }\n            const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n            const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n            let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n            if (isOutOfBound(currentPosition, targetPosition)) {\n                currentPosition = targetPosition;\n            }\n            swiper.wrapperEl.scrollTo({\n                [side]: currentPosition\n            });\n            if (isOutOfBound(currentPosition, targetPosition)) {\n                swiper.wrapperEl.style.overflow = 'hidden';\n                swiper.wrapperEl.style.scrollSnapType = '';\n                setTimeout(() => {\n                    swiper.wrapperEl.style.overflow = '';\n                    swiper.wrapperEl.scrollTo({\n                        [side]: currentPosition\n                    });\n                });\n                window.cancelAnimationFrame(swiper.cssModeFrameID);\n                return;\n            }\n            swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n        };\n        animate();\n    }\n    function getSlideTransformEl(slideEl) {\n        return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;\n    }\n    function elementChildren(element, selector) {\n        if (selector === void 0) {\n            selector = '';\n        }\n        return [...element.children].filter(el => el.matches(selector));\n    }\n    function showWarning(text) {\n        try {\n            console.warn(text);\n            return;\n        } catch (err) {\n            // err\n        }\n    }\n    function createElement(tag, classes) {\n        if (classes === void 0) {\n            classes = [];\n        }\n        const el = document.createElement(tag);\n        el.classList.add(...(Array.isArray(classes) ? classes : classesToTokens(classes)));\n        return el;\n    }\n    function elementOffset(el) {\n        const window = getWindow();\n        const document = getDocument();\n        const box = el.getBoundingClientRect();\n        const body = document.body;\n        const clientTop = el.clientTop || body.clientTop || 0;\n        const clientLeft = el.clientLeft || body.clientLeft || 0;\n        const scrollTop = el === window ? window.scrollY : el.scrollTop;\n        const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n        return {\n            top: box.top + scrollTop - clientTop,\n            left: box.left + scrollLeft - clientLeft\n        };\n    }\n    function elementPrevAll(el, selector) {\n        const prevEls = [];\n        while (el.previousElementSibling) {\n            const prev = el.previousElementSibling; // eslint-disable-line\n            if (selector) {\n                if (prev.matches(selector)) prevEls.push(prev);\n            } else prevEls.push(prev);\n            el = prev;\n        }\n        return prevEls;\n    }\n    function elementNextAll(el, selector) {\n        const nextEls = [];\n        while (el.nextElementSibling) {\n            const next = el.nextElementSibling; // eslint-disable-line\n            if (selector) {\n                if (next.matches(selector)) nextEls.push(next);\n            } else nextEls.push(next);\n            el = next;\n        }\n        return nextEls;\n    }\n    function elementStyle(el, prop) {\n        const window = getWindow();\n        return window.getComputedStyle(el, null).getPropertyValue(prop);\n    }\n    function elementIndex(el) {\n        let child = el;\n        let i;\n        if (child) {\n            i = 0;\n            // eslint-disable-next-line\n            while ((child = child.previousSibling) !== null) {\n                if (child.nodeType === 1) i += 1;\n            }\n            return i;\n        }\n        return undefined;\n    }\n    function elementParents(el, selector) {\n        const parents = []; // eslint-disable-line\n        let parent = el.parentElement; // eslint-disable-line\n        while (parent) {\n            if (selector) {\n                if (parent.matches(selector)) parents.push(parent);\n            } else {\n                parents.push(parent);\n            }\n            parent = parent.parentElement;\n        }\n        return parents;\n    }\n    function elementTransitionEnd(el, callback) {\n        function fireCallBack(e) {\n            if (e.target !== el) return;\n            callback.call(el, e);\n            el.removeEventListener('transitionend', fireCallBack);\n        }\n        if (callback) {\n            el.addEventListener('transitionend', fireCallBack);\n        }\n    }\n    function elementOuterSize(el, size, includeMargins) {\n        const window = getWindow();\n        if (includeMargins) {\n            return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));\n        }\n        return el.offsetWidth;\n    }\n    function makeElementsArray(el) {\n        return (Array.isArray(el) ? el : [el]).filter(e => !!e);\n    }\n\n    let support;\n    function calcSupport() {\n        const window = getWindow();\n        const document = getDocument();\n        return {\n            smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,\n            touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)\n        };\n    }\n    function getSupport() {\n        if (!support) {\n            support = calcSupport();\n        }\n        return support;\n    }\n\n    let deviceCached;\n    function calcDevice(_temp) {\n        let {\n            userAgent\n        } = _temp === void 0 ? {} : _temp;\n        const support = getSupport();\n        const window = getWindow();\n        const platform = window.navigator.platform;\n        const ua = userAgent || window.navigator.userAgent;\n        const device = {\n            ios: false,\n            android: false\n        };\n        const screenWidth = window.screen.width;\n        const screenHeight = window.screen.height;\n        const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n        let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n        const windows = platform === 'Win32';\n        let macos = platform === 'MacIntel';\n\n        // iPadOs 13 fix\n        const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\n        if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n            ipad = ua.match(/(Version)\\/([\\d.]+)/);\n            if (!ipad) ipad = [0, 1, '13_0_0'];\n            macos = false;\n        }\n\n        // Android\n        if (android && !windows) {\n            device.os = 'android';\n            device.android = true;\n        }\n        if (ipad || iphone || ipod) {\n            device.os = 'ios';\n            device.ios = true;\n        }\n\n        // Export object\n        return device;\n    }\n    function getDevice(overrides) {\n        if (overrides === void 0) {\n            overrides = {};\n        }\n        if (!deviceCached) {\n            deviceCached = calcDevice(overrides);\n        }\n        return deviceCached;\n    }\n\n    let browser;\n    function calcBrowser() {\n        const window = getWindow();\n        const device = getDevice();\n        let needPerspectiveFix = false;\n        function isSafari() {\n            const ua = window.navigator.userAgent.toLowerCase();\n            return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n        }\n        if (isSafari()) {\n            const ua = String(window.navigator.userAgent);\n            if (ua.includes('Version/')) {\n                const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));\n                needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n            }\n        }\n        const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);\n        const isSafariBrowser = isSafari();\n        const need3dFix = isSafariBrowser || isWebView && device.ios;\n        return {\n            isSafari: needPerspectiveFix || isSafariBrowser,\n            needPerspectiveFix,\n            need3dFix,\n            isWebView\n        };\n    }\n    function getBrowser() {\n        if (!browser) {\n            browser = calcBrowser();\n        }\n        return browser;\n    }\n\n    function Resize(_ref) {\n        let {\n            swiper,\n            on,\n            emit\n        } = _ref;\n        const window = getWindow();\n        let observer = null;\n        let animationFrame = null;\n        const resizeHandler = () => {\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            emit('beforeResize');\n            emit('resize');\n        };\n        const createObserver = () => {\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            observer = new ResizeObserver(entries => {\n                animationFrame = window.requestAnimationFrame(() => {\n                    const {\n                        width,\n                        height\n                    } = swiper;\n                    let newWidth = width;\n                    let newHeight = height;\n                    entries.forEach(_ref2 => {\n                        let {\n                            contentBoxSize,\n                            contentRect,\n                            target\n                        } = _ref2;\n                        if (target && target !== swiper.el) return;\n                        newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n                        newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n                    });\n                    if (newWidth !== width || newHeight !== height) {\n                        resizeHandler();\n                    }\n                });\n            });\n            observer.observe(swiper.el);\n        };\n        const removeObserver = () => {\n            if (animationFrame) {\n                window.cancelAnimationFrame(animationFrame);\n            }\n            if (observer && observer.unobserve && swiper.el) {\n                observer.unobserve(swiper.el);\n                observer = null;\n            }\n        };\n        const orientationChangeHandler = () => {\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            emit('orientationchange');\n        };\n        on('init', () => {\n            if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n                createObserver();\n                return;\n            }\n            window.addEventListener('resize', resizeHandler);\n            window.addEventListener('orientationchange', orientationChangeHandler);\n        });\n        on('destroy', () => {\n            removeObserver();\n            window.removeEventListener('resize', resizeHandler);\n            window.removeEventListener('orientationchange', orientationChangeHandler);\n        });\n    }\n\n    function Observer(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on,\n            emit\n        } = _ref;\n        const observers = [];\n        const window = getWindow();\n        const attach = function (target, options) {\n            if (options === void 0) {\n                options = {};\n            }\n            const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n            const observer = new ObserverFunc(mutations => {\n                // The observerUpdate event should only be triggered\n                // once despite the number of mutations.  Additional\n                // triggers are redundant and are very costly\n                if (swiper.__preventObserver__) return;\n                if (mutations.length === 1) {\n                    emit('observerUpdate', mutations[0]);\n                    return;\n                }\n                const observerUpdate = function observerUpdate() {\n                    emit('observerUpdate', mutations[0]);\n                };\n                if (window.requestAnimationFrame) {\n                    window.requestAnimationFrame(observerUpdate);\n                } else {\n                    window.setTimeout(observerUpdate, 0);\n                }\n            });\n            observer.observe(target, {\n                attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n                childList: typeof options.childList === 'undefined' ? true : options.childList,\n                characterData: typeof options.characterData === 'undefined' ? true : options.characterData\n            });\n            observers.push(observer);\n        };\n        const init = () => {\n            if (!swiper.params.observer) return;\n            if (swiper.params.observeParents) {\n                const containerParents = elementParents(swiper.hostEl);\n                for (let i = 0; i < containerParents.length; i += 1) {\n                    attach(containerParents[i]);\n                }\n            }\n            // Observe container\n            attach(swiper.hostEl, {\n                childList: swiper.params.observeSlideChildren\n            });\n\n            // Observe wrapper\n            attach(swiper.wrapperEl, {\n                attributes: false\n            });\n        };\n        const destroy = () => {\n            observers.forEach(observer => {\n                observer.disconnect();\n            });\n            observers.splice(0, observers.length);\n        };\n        extendParams({\n            observer: false,\n            observeParents: false,\n            observeSlideChildren: false\n        });\n        on('init', init);\n        on('destroy', destroy);\n    }\n\n    /* eslint-disable no-underscore-dangle */\n\n    var eventsEmitter = {\n        on(events, handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== 'function') return self;\n            const method = priority ? 'unshift' : 'push';\n            events.split(' ').forEach(event => {\n                if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n                self.eventsListeners[event][method](handler);\n            });\n            return self;\n        },\n        once(events, handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== 'function') return self;\n            function onceHandler() {\n                self.off(events, onceHandler);\n                if (onceHandler.__emitterProxy) {\n                    delete onceHandler.__emitterProxy;\n                }\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                    args[_key] = arguments[_key];\n                }\n                handler.apply(self, args);\n            }\n            onceHandler.__emitterProxy = handler;\n            return self.on(events, onceHandler, priority);\n        },\n        onAny(handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== 'function') return self;\n            const method = priority ? 'unshift' : 'push';\n            if (self.eventsAnyListeners.indexOf(handler) < 0) {\n                self.eventsAnyListeners[method](handler);\n            }\n            return self;\n        },\n        offAny(handler) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsAnyListeners) return self;\n            const index = self.eventsAnyListeners.indexOf(handler);\n            if (index >= 0) {\n                self.eventsAnyListeners.splice(index, 1);\n            }\n            return self;\n        },\n        off(events, handler) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsListeners) return self;\n            events.split(' ').forEach(event => {\n                if (typeof handler === 'undefined') {\n                    self.eventsListeners[event] = [];\n                } else if (self.eventsListeners[event]) {\n                    self.eventsListeners[event].forEach((eventHandler, index) => {\n                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n                            self.eventsListeners[event].splice(index, 1);\n                        }\n                    });\n                }\n            });\n            return self;\n        },\n        emit() {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsListeners) return self;\n            let events;\n            let data;\n            let context;\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n            }\n            if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n                events = args[0];\n                data = args.slice(1, args.length);\n                context = self;\n            } else {\n                events = args[0].events;\n                data = args[0].data;\n                context = args[0].context || self;\n            }\n            data.unshift(context);\n            const eventsArray = Array.isArray(events) ? events : events.split(' ');\n            eventsArray.forEach(event => {\n                if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n                    self.eventsAnyListeners.forEach(eventHandler => {\n                        eventHandler.apply(context, [event, ...data]);\n                    });\n                }\n                if (self.eventsListeners && self.eventsListeners[event]) {\n                    self.eventsListeners[event].forEach(eventHandler => {\n                        eventHandler.apply(context, data);\n                    });\n                }\n            });\n            return self;\n        }\n    };\n\n    function updateSize() {\n        const swiper = this;\n        let width;\n        let height;\n        const el = swiper.el;\n        if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n            width = swiper.params.width;\n        } else {\n            width = el.clientWidth;\n        }\n        if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n            height = swiper.params.height;\n        } else {\n            height = el.clientHeight;\n        }\n        if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n            return;\n        }\n\n        // Subtract paddings\n        width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);\n        height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);\n        if (Number.isNaN(width)) width = 0;\n        if (Number.isNaN(height)) height = 0;\n        Object.assign(swiper, {\n            width,\n            height,\n            size: swiper.isHorizontal() ? width : height\n        });\n    }\n\n    function updateSlides() {\n        const swiper = this;\n        function getDirectionPropertyValue(node, label) {\n            return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);\n        }\n        const params = swiper.params;\n        const {\n            wrapperEl,\n            slidesEl,\n            size: swiperSize,\n            rtlTranslate: rtl,\n            wrongRTL\n        } = swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n        const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n        const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n        let snapGrid = [];\n        const slidesGrid = [];\n        const slidesSizesGrid = [];\n        let offsetBefore = params.slidesOffsetBefore;\n        if (typeof offsetBefore === 'function') {\n            offsetBefore = params.slidesOffsetBefore.call(swiper);\n        }\n        let offsetAfter = params.slidesOffsetAfter;\n        if (typeof offsetAfter === 'function') {\n            offsetAfter = params.slidesOffsetAfter.call(swiper);\n        }\n        const previousSnapGridLength = swiper.snapGrid.length;\n        const previousSlidesGridLength = swiper.slidesGrid.length;\n        let spaceBetween = params.spaceBetween;\n        let slidePosition = -offsetBefore;\n        let prevSlideSize = 0;\n        let index = 0;\n        if (typeof swiperSize === 'undefined') {\n            return;\n        }\n        if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n            spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n        } else if (typeof spaceBetween === 'string') {\n            spaceBetween = parseFloat(spaceBetween);\n        }\n        swiper.virtualSize = -spaceBetween;\n\n        // reset margins\n        slides.forEach(slideEl => {\n            if (rtl) {\n                slideEl.style.marginLeft = '';\n            } else {\n                slideEl.style.marginRight = '';\n            }\n            slideEl.style.marginBottom = '';\n            slideEl.style.marginTop = '';\n        });\n\n        // reset cssMode offsets\n        if (params.centeredSlides && params.cssMode) {\n            setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n            setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n        }\n        const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n        if (gridEnabled) {\n            swiper.grid.initSlides(slides);\n        } else if (swiper.grid) {\n            swiper.grid.unsetSlides();\n        }\n\n        // Calc slides\n        let slideSize;\n        const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n            return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n        }).length > 0;\n        for (let i = 0; i < slidesLength; i += 1) {\n            slideSize = 0;\n            let slide;\n            if (slides[i]) slide = slides[i];\n            if (gridEnabled) {\n                swiper.grid.updateSlide(i, slide, slides);\n            }\n            if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n            if (params.slidesPerView === 'auto') {\n                if (shouldResetSlideSize) {\n                    slides[i].style[swiper.getDirectionLabel('width')] = ``;\n                }\n                const slideStyles = getComputedStyle(slide);\n                const currentTransform = slide.style.transform;\n                const currentWebKitTransform = slide.style.webkitTransform;\n                if (currentTransform) {\n                    slide.style.transform = 'none';\n                }\n                if (currentWebKitTransform) {\n                    slide.style.webkitTransform = 'none';\n                }\n                if (params.roundLengths) {\n                    slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);\n                } else {\n                    // eslint-disable-next-line\n                    const width = getDirectionPropertyValue(slideStyles, 'width');\n                    const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n                    const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n                    const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n                    const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n                    const boxSizing = slideStyles.getPropertyValue('box-sizing');\n                    if (boxSizing && boxSizing === 'border-box') {\n                        slideSize = width + marginLeft + marginRight;\n                    } else {\n                        const {\n                            clientWidth,\n                            offsetWidth\n                        } = slide;\n                        slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n                    }\n                }\n                if (currentTransform) {\n                    slide.style.transform = currentTransform;\n                }\n                if (currentWebKitTransform) {\n                    slide.style.webkitTransform = currentWebKitTransform;\n                }\n                if (params.roundLengths) slideSize = Math.floor(slideSize);\n            } else {\n                slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n                if (params.roundLengths) slideSize = Math.floor(slideSize);\n                if (slides[i]) {\n                    slides[i].style[swiper.getDirectionLabel('width')] = `${slideSize}px`;\n                }\n            }\n            if (slides[i]) {\n                slides[i].swiperSlideSize = slideSize;\n            }\n            slidesSizesGrid.push(slideSize);\n            if (params.centeredSlides) {\n                slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n                if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n                if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n                if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n                if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n                if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n                slidesGrid.push(slidePosition);\n            } else {\n                if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n                if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n                slidesGrid.push(slidePosition);\n                slidePosition = slidePosition + slideSize + spaceBetween;\n            }\n            swiper.virtualSize += slideSize + spaceBetween;\n            prevSlideSize = slideSize;\n            index += 1;\n        }\n        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n        if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n            wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n        }\n        if (params.setWrapperSize) {\n            wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n        }\n        if (gridEnabled) {\n            swiper.grid.updateWrapperSize(slideSize, snapGrid);\n        }\n\n        // Remove last grid elements depending on width\n        if (!params.centeredSlides) {\n            const newSlidesGrid = [];\n            for (let i = 0; i < snapGrid.length; i += 1) {\n                let slidesGridItem = snapGrid[i];\n                if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n                if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n                    newSlidesGrid.push(slidesGridItem);\n                }\n            }\n            snapGrid = newSlidesGrid;\n            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n                snapGrid.push(swiper.virtualSize - swiperSize);\n            }\n        }\n        if (isVirtual && params.loop) {\n            const size = slidesSizesGrid[0] + spaceBetween;\n            if (params.slidesPerGroup > 1) {\n                const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n                const groupSize = size * params.slidesPerGroup;\n                for (let i = 0; i < groups; i += 1) {\n                    snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n                }\n            }\n            for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n                if (params.slidesPerGroup === 1) {\n                    snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n                }\n                slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n                swiper.virtualSize += size;\n            }\n        }\n        if (snapGrid.length === 0) snapGrid = [0];\n        if (spaceBetween !== 0) {\n            const key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');\n            slides.filter((_, slideIndex) => {\n                if (!params.cssMode || params.loop) return true;\n                if (slideIndex === slides.length - 1) {\n                    return false;\n                }\n                return true;\n            }).forEach(slideEl => {\n                slideEl.style[key] = `${spaceBetween}px`;\n            });\n        }\n        if (params.centeredSlides && params.centeredSlidesBounds) {\n            let allSlidesSize = 0;\n            slidesSizesGrid.forEach(slideSizeValue => {\n                allSlidesSize += slideSizeValue + (spaceBetween || 0);\n            });\n            allSlidesSize -= spaceBetween;\n            const maxSnap = allSlidesSize - swiperSize;\n            snapGrid = snapGrid.map(snap => {\n                if (snap <= 0) return -offsetBefore;\n                if (snap > maxSnap) return maxSnap + offsetAfter;\n                return snap;\n            });\n        }\n        if (params.centerInsufficientSlides) {\n            let allSlidesSize = 0;\n            slidesSizesGrid.forEach(slideSizeValue => {\n                allSlidesSize += slideSizeValue + (spaceBetween || 0);\n            });\n            allSlidesSize -= spaceBetween;\n            const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);\n            if (allSlidesSize + offsetSize < swiperSize) {\n                const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;\n                snapGrid.forEach((snap, snapIndex) => {\n                    snapGrid[snapIndex] = snap - allSlidesOffset;\n                });\n                slidesGrid.forEach((snap, snapIndex) => {\n                    slidesGrid[snapIndex] = snap + allSlidesOffset;\n                });\n            }\n        }\n        Object.assign(swiper, {\n            slides,\n            snapGrid,\n            slidesGrid,\n            slidesSizesGrid\n        });\n        if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n            setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n            setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n            const addToSnapGrid = -swiper.snapGrid[0];\n            const addToSlidesGrid = -swiper.slidesGrid[0];\n            swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n            swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n        }\n        if (slidesLength !== previousSlidesLength) {\n            swiper.emit('slidesLengthChange');\n        }\n        if (snapGrid.length !== previousSnapGridLength) {\n            if (swiper.params.watchOverflow) swiper.checkOverflow();\n            swiper.emit('snapGridLengthChange');\n        }\n        if (slidesGrid.length !== previousSlidesGridLength) {\n            swiper.emit('slidesGridLengthChange');\n        }\n        if (params.watchSlidesProgress) {\n            swiper.updateSlidesOffset();\n        }\n        swiper.emit('slidesUpdated');\n        if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n            const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n            const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n            if (slidesLength <= params.maxBackfaceHiddenSlides) {\n                if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n            } else if (hasClassBackfaceClassAdded) {\n                swiper.el.classList.remove(backFaceHiddenClass);\n            }\n        }\n    }\n\n    function updateAutoHeight(speed) {\n        const swiper = this;\n        const activeSlides = [];\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        let newHeight = 0;\n        let i;\n        if (typeof speed === 'number') {\n            swiper.setTransition(speed);\n        } else if (speed === true) {\n            swiper.setTransition(swiper.params.speed);\n        }\n        const getSlideByIndex = index => {\n            if (isVirtual) {\n                return swiper.slides[swiper.getSlideIndexByData(index)];\n            }\n            return swiper.slides[index];\n        };\n        // Find slides currently in view\n        if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n            if (swiper.params.centeredSlides) {\n                (swiper.visibleSlides || []).forEach(slide => {\n                    activeSlides.push(slide);\n                });\n            } else {\n                for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n                    const index = swiper.activeIndex + i;\n                    if (index > swiper.slides.length && !isVirtual) break;\n                    activeSlides.push(getSlideByIndex(index));\n                }\n            }\n        } else {\n            activeSlides.push(getSlideByIndex(swiper.activeIndex));\n        }\n\n        // Find new height from highest slide in view\n        for (i = 0; i < activeSlides.length; i += 1) {\n            if (typeof activeSlides[i] !== 'undefined') {\n                const height = activeSlides[i].offsetHeight;\n                newHeight = height > newHeight ? height : newHeight;\n            }\n        }\n\n        // Update Height\n        if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n    }\n\n    function updateSlidesOffset() {\n        const swiper = this;\n        const slides = swiper.slides;\n        // eslint-disable-next-line\n        const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n        for (let i = 0; i < slides.length; i += 1) {\n            slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n        }\n    }\n\n    const toggleSlideClasses$1 = (slideEl, condition, className) => {\n        if (condition && !slideEl.classList.contains(className)) {\n            slideEl.classList.add(className);\n        } else if (!condition && slideEl.classList.contains(className)) {\n            slideEl.classList.remove(className);\n        }\n    };\n    function updateSlidesProgress(translate) {\n        if (translate === void 0) {\n            translate = this && this.translate || 0;\n        }\n        const swiper = this;\n        const params = swiper.params;\n        const {\n            slides,\n            rtlTranslate: rtl,\n            snapGrid\n        } = swiper;\n        if (slides.length === 0) return;\n        if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n        let offsetCenter = -translate;\n        if (rtl) offsetCenter = translate;\n        swiper.visibleSlidesIndexes = [];\n        swiper.visibleSlides = [];\n        let spaceBetween = params.spaceBetween;\n        if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n            spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n        } else if (typeof spaceBetween === 'string') {\n            spaceBetween = parseFloat(spaceBetween);\n        }\n        for (let i = 0; i < slides.length; i += 1) {\n            const slide = slides[i];\n            let slideOffset = slide.swiperSlideOffset;\n            if (params.cssMode && params.centeredSlides) {\n                slideOffset -= slides[0].swiperSlideOffset;\n            }\n            const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n            const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n            const slideBefore = -(offsetCenter - slideOffset);\n            const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n            const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];\n            const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n            if (isVisible) {\n                swiper.visibleSlides.push(slide);\n                swiper.visibleSlidesIndexes.push(i);\n            }\n            toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);\n            toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);\n            slide.progress = rtl ? -slideProgress : slideProgress;\n            slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n        }\n    }\n\n    function updateProgress(translate) {\n        const swiper = this;\n        if (typeof translate === 'undefined') {\n            const multiplier = swiper.rtlTranslate ? -1 : 1;\n            // eslint-disable-next-line\n            translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n        }\n        const params = swiper.params;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        let {\n            progress,\n            isBeginning,\n            isEnd,\n            progressLoop\n        } = swiper;\n        const wasBeginning = isBeginning;\n        const wasEnd = isEnd;\n        if (translatesDiff === 0) {\n            progress = 0;\n            isBeginning = true;\n            isEnd = true;\n        } else {\n            progress = (translate - swiper.minTranslate()) / translatesDiff;\n            const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n            const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n            isBeginning = isBeginningRounded || progress <= 0;\n            isEnd = isEndRounded || progress >= 1;\n            if (isBeginningRounded) progress = 0;\n            if (isEndRounded) progress = 1;\n        }\n        if (params.loop) {\n            const firstSlideIndex = swiper.getSlideIndexByData(0);\n            const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n            const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n            const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n            const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n            const translateAbs = Math.abs(translate);\n            if (translateAbs >= firstSlideTranslate) {\n                progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n            } else {\n                progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n            }\n            if (progressLoop > 1) progressLoop -= 1;\n        }\n        Object.assign(swiper, {\n            progress,\n            progressLoop,\n            isBeginning,\n            isEnd\n        });\n        if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n        if (isBeginning && !wasBeginning) {\n            swiper.emit('reachBeginning toEdge');\n        }\n        if (isEnd && !wasEnd) {\n            swiper.emit('reachEnd toEdge');\n        }\n        if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n            swiper.emit('fromEdge');\n        }\n        swiper.emit('progress', progress);\n    }\n\n    const toggleSlideClasses = (slideEl, condition, className) => {\n        if (condition && !slideEl.classList.contains(className)) {\n            slideEl.classList.add(className);\n        } else if (!condition && slideEl.classList.contains(className)) {\n            slideEl.classList.remove(className);\n        }\n    };\n    function updateSlidesClasses() {\n        const swiper = this;\n        const {\n            slides,\n            params,\n            slidesEl,\n            activeIndex\n        } = swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n        const getFilteredSlide = selector => {\n            return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n        };\n        let activeSlide;\n        let prevSlide;\n        let nextSlide;\n        if (isVirtual) {\n            if (params.loop) {\n                let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n                if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n                if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n                activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n            } else {\n                activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n            }\n        } else {\n            if (gridEnabled) {\n                activeSlide = slides.filter(slideEl => slideEl.column === activeIndex)[0];\n                nextSlide = slides.filter(slideEl => slideEl.column === activeIndex + 1)[0];\n                prevSlide = slides.filter(slideEl => slideEl.column === activeIndex - 1)[0];\n            } else {\n                activeSlide = slides[activeIndex];\n            }\n        }\n        if (activeSlide) {\n            if (!gridEnabled) {\n                // Next Slide\n                nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n                if (params.loop && !nextSlide) {\n                    nextSlide = slides[0];\n                }\n\n                // Prev Slide\n                prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n                if (params.loop && !prevSlide === 0) {\n                    prevSlide = slides[slides.length - 1];\n                }\n            }\n        }\n        slides.forEach(slideEl => {\n            toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);\n            toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);\n            toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);\n        });\n        swiper.emitSlidesClasses();\n    }\n\n    const processLazyPreloader = (swiper, imageEl) => {\n        if (!swiper || swiper.destroyed || !swiper.params) return;\n        const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n        const slideEl = imageEl.closest(slideSelector());\n        if (slideEl) {\n            let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n            if (!lazyEl && swiper.isElement) {\n                if (slideEl.shadowRoot) {\n                    lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n                } else {\n                    // init later\n                    requestAnimationFrame(() => {\n                        if (slideEl.shadowRoot) {\n                            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n                            if (lazyEl) lazyEl.remove();\n                        }\n                    });\n                }\n            }\n            if (lazyEl) lazyEl.remove();\n        }\n    };\n    const unlazy = (swiper, index) => {\n        if (!swiper.slides[index]) return;\n        const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n        if (imageEl) imageEl.removeAttribute('loading');\n    };\n    const preload = swiper => {\n        if (!swiper || swiper.destroyed || !swiper.params) return;\n        let amount = swiper.params.lazyPreloadPrevNext;\n        const len = swiper.slides.length;\n        if (!len || !amount || amount < 0) return;\n        amount = Math.min(amount, len);\n        const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n        const activeIndex = swiper.activeIndex;\n        if (swiper.params.grid && swiper.params.grid.rows > 1) {\n            const activeColumn = activeIndex;\n            const preloadColumns = [activeColumn - amount];\n            preloadColumns.push(...Array.from({\n                length: amount\n            }).map((_, i) => {\n                return activeColumn + slidesPerView + i;\n            }));\n            swiper.slides.forEach((slideEl, i) => {\n                if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n            });\n            return;\n        }\n        const slideIndexLastInView = activeIndex + slidesPerView - 1;\n        if (swiper.params.rewind || swiper.params.loop) {\n            for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n                const realIndex = (i % len + len) % len;\n                if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n            }\n        } else {\n            for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n                if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n                    unlazy(swiper, i);\n                }\n            }\n        }\n    };\n\n    function getActiveIndexByTranslate(swiper) {\n        const {\n            slidesGrid,\n            params\n        } = swiper;\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        let activeIndex;\n        for (let i = 0; i < slidesGrid.length; i += 1) {\n            if (typeof slidesGrid[i + 1] !== 'undefined') {\n                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n                    activeIndex = i;\n                } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n                    activeIndex = i + 1;\n                }\n            } else if (translate >= slidesGrid[i]) {\n                activeIndex = i;\n            }\n        }\n        // Normalize slideIndex\n        if (params.normalizeSlideIndex) {\n            if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n        }\n        return activeIndex;\n    }\n    function updateActiveIndex(newActiveIndex) {\n        const swiper = this;\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        const {\n            snapGrid,\n            params,\n            activeIndex: previousIndex,\n            realIndex: previousRealIndex,\n            snapIndex: previousSnapIndex\n        } = swiper;\n        let activeIndex = newActiveIndex;\n        let snapIndex;\n        const getVirtualRealIndex = aIndex => {\n            let realIndex = aIndex - swiper.virtual.slidesBefore;\n            if (realIndex < 0) {\n                realIndex = swiper.virtual.slides.length + realIndex;\n            }\n            if (realIndex >= swiper.virtual.slides.length) {\n                realIndex -= swiper.virtual.slides.length;\n            }\n            return realIndex;\n        };\n        if (typeof activeIndex === 'undefined') {\n            activeIndex = getActiveIndexByTranslate(swiper);\n        }\n        if (snapGrid.indexOf(translate) >= 0) {\n            snapIndex = snapGrid.indexOf(translate);\n        } else {\n            const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n            snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n        }\n        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n        if (activeIndex === previousIndex && !swiper.params.loop) {\n            if (snapIndex !== previousSnapIndex) {\n                swiper.snapIndex = snapIndex;\n                swiper.emit('snapIndexChange');\n            }\n            return;\n        }\n        if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n            swiper.realIndex = getVirtualRealIndex(activeIndex);\n            return;\n        }\n        const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n\n        // Get real index\n        let realIndex;\n        if (swiper.virtual && params.virtual.enabled && params.loop) {\n            realIndex = getVirtualRealIndex(activeIndex);\n        } else if (gridEnabled) {\n            const firstSlideInColumn = swiper.slides.filter(slideEl => slideEl.column === activeIndex)[0];\n            let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);\n            if (Number.isNaN(activeSlideIndex)) {\n                activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);\n            }\n            realIndex = Math.floor(activeSlideIndex / params.grid.rows);\n        } else if (swiper.slides[activeIndex]) {\n            const slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');\n            if (slideIndex) {\n                realIndex = parseInt(slideIndex, 10);\n            } else {\n                realIndex = activeIndex;\n            }\n        } else {\n            realIndex = activeIndex;\n        }\n        Object.assign(swiper, {\n            previousSnapIndex,\n            snapIndex,\n            previousRealIndex,\n            realIndex,\n            previousIndex,\n            activeIndex\n        });\n        if (swiper.initialized) {\n            preload(swiper);\n        }\n        swiper.emit('activeIndexChange');\n        swiper.emit('snapIndexChange');\n        if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n            if (previousRealIndex !== realIndex) {\n                swiper.emit('realIndexChange');\n            }\n            swiper.emit('slideChange');\n        }\n    }\n\n    function updateClickedSlide(el, path) {\n        const swiper = this;\n        const params = swiper.params;\n        let slide = el.closest(`.${params.slideClass}, swiper-slide`);\n        if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {\n            [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {\n                if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {\n                    slide = pathEl;\n                }\n            });\n        }\n        let slideFound = false;\n        let slideIndex;\n        if (slide) {\n            for (let i = 0; i < swiper.slides.length; i += 1) {\n                if (swiper.slides[i] === slide) {\n                    slideFound = true;\n                    slideIndex = i;\n                    break;\n                }\n            }\n        }\n        if (slide && slideFound) {\n            swiper.clickedSlide = slide;\n            if (swiper.virtual && swiper.params.virtual.enabled) {\n                swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n            } else {\n                swiper.clickedIndex = slideIndex;\n            }\n        } else {\n            swiper.clickedSlide = undefined;\n            swiper.clickedIndex = undefined;\n            return;\n        }\n        if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n            swiper.slideToClickedSlide();\n        }\n    }\n\n    var update = {\n        updateSize,\n        updateSlides,\n        updateAutoHeight,\n        updateSlidesOffset,\n        updateSlidesProgress,\n        updateProgress,\n        updateSlidesClasses,\n        updateActiveIndex,\n        updateClickedSlide\n    };\n\n    function getSwiperTranslate(axis) {\n        if (axis === void 0) {\n            axis = this.isHorizontal() ? 'x' : 'y';\n        }\n        const swiper = this;\n        const {\n            params,\n            rtlTranslate: rtl,\n            translate,\n            wrapperEl\n        } = swiper;\n        if (params.virtualTranslate) {\n            return rtl ? -translate : translate;\n        }\n        if (params.cssMode) {\n            return translate;\n        }\n        let currentTranslate = getTranslate(wrapperEl, axis);\n        currentTranslate += swiper.cssOverflowAdjustment();\n        if (rtl) currentTranslate = -currentTranslate;\n        return currentTranslate || 0;\n    }\n\n    function setTranslate(translate, byController) {\n        const swiper = this;\n        const {\n            rtlTranslate: rtl,\n            params,\n            wrapperEl,\n            progress\n        } = swiper;\n        let x = 0;\n        let y = 0;\n        const z = 0;\n        if (swiper.isHorizontal()) {\n            x = rtl ? -translate : translate;\n        } else {\n            y = translate;\n        }\n        if (params.roundLengths) {\n            x = Math.floor(x);\n            y = Math.floor(y);\n        }\n        swiper.previousTranslate = swiper.translate;\n        swiper.translate = swiper.isHorizontal() ? x : y;\n        if (params.cssMode) {\n            wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n        } else if (!params.virtualTranslate) {\n            if (swiper.isHorizontal()) {\n                x -= swiper.cssOverflowAdjustment();\n            } else {\n                y -= swiper.cssOverflowAdjustment();\n            }\n            wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n        }\n\n        // Check if we need to update progress\n        let newProgress;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        if (translatesDiff === 0) {\n            newProgress = 0;\n        } else {\n            newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n        }\n        if (newProgress !== progress) {\n            swiper.updateProgress(translate);\n        }\n        swiper.emit('setTranslate', swiper.translate, byController);\n    }\n\n    function minTranslate() {\n        return -this.snapGrid[0];\n    }\n\n    function maxTranslate() {\n        return -this.snapGrid[this.snapGrid.length - 1];\n    }\n\n    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n        if (translate === void 0) {\n            translate = 0;\n        }\n        if (speed === void 0) {\n            speed = this.params.speed;\n        }\n        if (runCallbacks === void 0) {\n            runCallbacks = true;\n        }\n        if (translateBounds === void 0) {\n            translateBounds = true;\n        }\n        const swiper = this;\n        const {\n            params,\n            wrapperEl\n        } = swiper;\n        if (swiper.animating && params.preventInteractionOnTransition) {\n            return false;\n        }\n        const minTranslate = swiper.minTranslate();\n        const maxTranslate = swiper.maxTranslate();\n        let newTranslate;\n        if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;\n\n        // Update progress\n        swiper.updateProgress(newTranslate);\n        if (params.cssMode) {\n            const isH = swiper.isHorizontal();\n            if (speed === 0) {\n                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n            } else {\n                if (!swiper.support.smoothScroll) {\n                    animateCSSModeScroll({\n                        swiper,\n                        targetPosition: -newTranslate,\n                        side: isH ? 'left' : 'top'\n                    });\n                    return true;\n                }\n                wrapperEl.scrollTo({\n                    [isH ? 'left' : 'top']: -newTranslate,\n                    behavior: 'smooth'\n                });\n            }\n            return true;\n        }\n        if (speed === 0) {\n            swiper.setTransition(0);\n            swiper.setTranslate(newTranslate);\n            if (runCallbacks) {\n                swiper.emit('beforeTransitionStart', speed, internal);\n                swiper.emit('transitionEnd');\n            }\n        } else {\n            swiper.setTransition(speed);\n            swiper.setTranslate(newTranslate);\n            if (runCallbacks) {\n                swiper.emit('beforeTransitionStart', speed, internal);\n                swiper.emit('transitionStart');\n            }\n            if (!swiper.animating) {\n                swiper.animating = true;\n                if (!swiper.onTranslateToWrapperTransitionEnd) {\n                    swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n                        if (!swiper || swiper.destroyed) return;\n                        if (e.target !== this) return;\n                        swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n                        swiper.onTranslateToWrapperTransitionEnd = null;\n                        delete swiper.onTranslateToWrapperTransitionEnd;\n                        swiper.animating = false;\n                        if (runCallbacks) {\n                            swiper.emit('transitionEnd');\n                        }\n                    };\n                }\n                swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n            }\n        }\n        return true;\n    }\n\n    var translate = {\n        getTranslate: getSwiperTranslate,\n        setTranslate,\n        minTranslate,\n        maxTranslate,\n        translateTo\n    };\n\n    function setTransition(duration, byController) {\n        const swiper = this;\n        if (!swiper.params.cssMode) {\n            swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n            swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';\n        }\n        swiper.emit('setTransition', duration, byController);\n    }\n\n    function transitionEmit(_ref) {\n        let {\n            swiper,\n            runCallbacks,\n            direction,\n            step\n        } = _ref;\n        const {\n            activeIndex,\n            previousIndex\n        } = swiper;\n        let dir = direction;\n        if (!dir) {\n            if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';\n        }\n        swiper.emit(`transition${step}`);\n        if (runCallbacks && activeIndex !== previousIndex) {\n            if (dir === 'reset') {\n                swiper.emit(`slideResetTransition${step}`);\n                return;\n            }\n            swiper.emit(`slideChangeTransition${step}`);\n            if (dir === 'next') {\n                swiper.emit(`slideNextTransition${step}`);\n            } else {\n                swiper.emit(`slidePrevTransition${step}`);\n            }\n        }\n    }\n\n    function transitionStart(runCallbacks, direction) {\n        if (runCallbacks === void 0) {\n            runCallbacks = true;\n        }\n        const swiper = this;\n        const {\n            params\n        } = swiper;\n        if (params.cssMode) return;\n        if (params.autoHeight) {\n            swiper.updateAutoHeight();\n        }\n        transitionEmit({\n            swiper,\n            runCallbacks,\n            direction,\n            step: 'Start'\n        });\n    }\n\n    function transitionEnd(runCallbacks, direction) {\n        if (runCallbacks === void 0) {\n            runCallbacks = true;\n        }\n        const swiper = this;\n        const {\n            params\n        } = swiper;\n        swiper.animating = false;\n        if (params.cssMode) return;\n        swiper.setTransition(0);\n        transitionEmit({\n            swiper,\n            runCallbacks,\n            direction,\n            step: 'End'\n        });\n    }\n\n    var transition = {\n        setTransition,\n        transitionStart,\n        transitionEnd\n    };\n\n    function slideTo(index, speed, runCallbacks, internal, initial) {\n        if (index === void 0) {\n            index = 0;\n        }\n        if (runCallbacks === void 0) {\n            runCallbacks = true;\n        }\n        if (typeof index === 'string') {\n            index = parseInt(index, 10);\n        }\n        const swiper = this;\n        let slideIndex = index;\n        if (slideIndex < 0) slideIndex = 0;\n        const {\n            params,\n            snapGrid,\n            slidesGrid,\n            previousIndex,\n            activeIndex,\n            rtlTranslate: rtl,\n            wrapperEl,\n            enabled\n        } = swiper;\n        if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {\n            return false;\n        }\n        if (typeof speed === 'undefined') {\n            speed = swiper.params.speed;\n        }\n        const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n        let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n        const translate = -snapGrid[snapIndex];\n        // Normalize slideIndex\n        if (params.normalizeSlideIndex) {\n            for (let i = 0; i < slidesGrid.length; i += 1) {\n                const normalizedTranslate = -Math.floor(translate * 100);\n                const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n                const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n                if (typeof slidesGrid[i + 1] !== 'undefined') {\n                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n                        slideIndex = i;\n                    } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n                        slideIndex = i + 1;\n                    }\n                } else if (normalizedTranslate >= normalizedGrid) {\n                    slideIndex = i;\n                }\n            }\n        }\n        // Directions locks\n        if (swiper.initialized && slideIndex !== activeIndex) {\n            if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n                return false;\n            }\n            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n                if ((activeIndex || 0) !== slideIndex) {\n                    return false;\n                }\n            }\n        }\n        if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n            swiper.emit('beforeSlideChangeStart');\n        }\n\n        // Update progress\n        swiper.updateProgress(translate);\n        let direction;\n        if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';\n\n        // Update Index\n        if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n            swiper.updateActiveIndex(slideIndex);\n            // Update Height\n            if (params.autoHeight) {\n                swiper.updateAutoHeight();\n            }\n            swiper.updateSlidesClasses();\n            if (params.effect !== 'slide') {\n                swiper.setTranslate(translate);\n            }\n            if (direction !== 'reset') {\n                swiper.transitionStart(runCallbacks, direction);\n                swiper.transitionEnd(runCallbacks, direction);\n            }\n            return false;\n        }\n        if (params.cssMode) {\n            const isH = swiper.isHorizontal();\n            const t = rtl ? translate : -translate;\n            if (speed === 0) {\n                const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n                if (isVirtual) {\n                    swiper.wrapperEl.style.scrollSnapType = 'none';\n                    swiper._immediateVirtual = true;\n                }\n                if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n                    swiper._cssModeVirtualInitialSet = true;\n                    requestAnimationFrame(() => {\n                        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n                    });\n                } else {\n                    wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n                }\n                if (isVirtual) {\n                    requestAnimationFrame(() => {\n                        swiper.wrapperEl.style.scrollSnapType = '';\n                        swiper._immediateVirtual = false;\n                    });\n                }\n            } else {\n                if (!swiper.support.smoothScroll) {\n                    animateCSSModeScroll({\n                        swiper,\n                        targetPosition: t,\n                        side: isH ? 'left' : 'top'\n                    });\n                    return true;\n                }\n                wrapperEl.scrollTo({\n                    [isH ? 'left' : 'top']: t,\n                    behavior: 'smooth'\n                });\n            }\n            return true;\n        }\n        swiper.setTransition(speed);\n        swiper.setTranslate(translate);\n        swiper.updateActiveIndex(slideIndex);\n        swiper.updateSlidesClasses();\n        swiper.emit('beforeTransitionStart', speed, internal);\n        swiper.transitionStart(runCallbacks, direction);\n        if (speed === 0) {\n            swiper.transitionEnd(runCallbacks, direction);\n        } else if (!swiper.animating) {\n            swiper.animating = true;\n            if (!swiper.onSlideToWrapperTransitionEnd) {\n                swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n                    if (!swiper || swiper.destroyed) return;\n                    if (e.target !== this) return;\n                    swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n                    swiper.onSlideToWrapperTransitionEnd = null;\n                    delete swiper.onSlideToWrapperTransitionEnd;\n                    swiper.transitionEnd(runCallbacks, direction);\n                };\n            }\n            swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n        }\n        return true;\n    }\n\n    function slideToLoop(index, speed, runCallbacks, internal) {\n        if (index === void 0) {\n            index = 0;\n        }\n        if (runCallbacks === void 0) {\n            runCallbacks = true;\n        }\n        if (typeof index === 'string') {\n            const indexAsNumber = parseInt(index, 10);\n            index = indexAsNumber;\n        }\n        const swiper = this;\n        if (swiper.destroyed) return;\n        if (typeof speed === 'undefined') {\n            speed = swiper.params.speed;\n        }\n        const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;\n        let newIndex = index;\n        if (swiper.params.loop) {\n            if (swiper.virtual && swiper.params.virtual.enabled) {\n                // eslint-disable-next-line\n                newIndex = newIndex + swiper.virtual.slidesBefore;\n            } else {\n                let targetSlideIndex;\n                if (gridEnabled) {\n                    const slideIndex = newIndex * swiper.params.grid.rows;\n                    targetSlideIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;\n                } else {\n                    targetSlideIndex = swiper.getSlideIndexByData(newIndex);\n                }\n                const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;\n                const {\n                    centeredSlides\n                } = swiper.params;\n                let slidesPerView = swiper.params.slidesPerView;\n                if (slidesPerView === 'auto') {\n                    slidesPerView = swiper.slidesPerViewDynamic();\n                } else {\n                    slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));\n                    if (centeredSlides && slidesPerView % 2 === 0) {\n                        slidesPerView = slidesPerView + 1;\n                    }\n                }\n                let needLoopFix = cols - targetSlideIndex < slidesPerView;\n                if (centeredSlides) {\n                    needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);\n                }\n                if (internal && centeredSlides && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {\n                    needLoopFix = false;\n                }\n                if (needLoopFix) {\n                    const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';\n                    swiper.loopFix({\n                        direction,\n                        slideTo: true,\n                        activeSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,\n                        slideRealIndex: direction === 'next' ? swiper.realIndex : undefined\n                    });\n                }\n                if (gridEnabled) {\n                    const slideIndex = newIndex * swiper.params.grid.rows;\n                    newIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;\n                } else {\n                    newIndex = swiper.getSlideIndexByData(newIndex);\n                }\n            }\n        }\n        requestAnimationFrame(() => {\n            swiper.slideTo(newIndex, speed, runCallbacks, internal);\n        });\n        return swiper;\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slideNext(speed, runCallbacks, internal) {\n        if (runCallbacks === void 0) {\n            runCallbacks = true;\n        }\n        const swiper = this;\n        const {\n            enabled,\n            params,\n            animating\n        } = swiper;\n        if (!enabled || swiper.destroyed) return swiper;\n        if (typeof speed === 'undefined') {\n            speed = swiper.params.speed;\n        }\n        let perGroup = params.slidesPerGroup;\n        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n            perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n        }\n        const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        if (params.loop) {\n            if (animating && !isVirtual && params.loopPreventsSliding) return false;\n            swiper.loopFix({\n                direction: 'next'\n            });\n            // eslint-disable-next-line\n            swiper._clientLeft = swiper.wrapperEl.clientLeft;\n            if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {\n                requestAnimationFrame(() => {\n                    swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n                });\n                return true;\n            }\n        }\n        if (params.rewind && swiper.isEnd) {\n            return swiper.slideTo(0, speed, runCallbacks, internal);\n        }\n        return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slidePrev(speed, runCallbacks, internal) {\n        if (runCallbacks === void 0) {\n            runCallbacks = true;\n        }\n        const swiper = this;\n        const {\n            params,\n            snapGrid,\n            slidesGrid,\n            rtlTranslate,\n            enabled,\n            animating\n        } = swiper;\n        if (!enabled || swiper.destroyed) return swiper;\n        if (typeof speed === 'undefined') {\n            speed = swiper.params.speed;\n        }\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        if (params.loop) {\n            if (animating && !isVirtual && params.loopPreventsSliding) return false;\n            swiper.loopFix({\n                direction: 'prev'\n            });\n            // eslint-disable-next-line\n            swiper._clientLeft = swiper.wrapperEl.clientLeft;\n        }\n        const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n        function normalize(val) {\n            if (val < 0) return -Math.floor(Math.abs(val));\n            return Math.floor(val);\n        }\n        const normalizedTranslate = normalize(translate);\n        const normalizedSnapGrid = snapGrid.map(val => normalize(val));\n        let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n        if (typeof prevSnap === 'undefined' && params.cssMode) {\n            let prevSnapIndex;\n            snapGrid.forEach((snap, snapIndex) => {\n                if (normalizedTranslate >= snap) {\n                    // prevSnap = snap;\n                    prevSnapIndex = snapIndex;\n                }\n            });\n            if (typeof prevSnapIndex !== 'undefined') {\n                prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n            }\n        }\n        let prevIndex = 0;\n        if (typeof prevSnap !== 'undefined') {\n            prevIndex = slidesGrid.indexOf(prevSnap);\n            if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n            if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n                prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n                prevIndex = Math.max(prevIndex, 0);\n            }\n        }\n        if (params.rewind && swiper.isBeginning) {\n            const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n            return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n        } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {\n            requestAnimationFrame(() => {\n                swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n            });\n            return true;\n        }\n        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slideReset(speed, runCallbacks, internal) {\n        if (runCallbacks === void 0) {\n            runCallbacks = true;\n        }\n        const swiper = this;\n        if (swiper.destroyed) return;\n        if (typeof speed === 'undefined') {\n            speed = swiper.params.speed;\n        }\n        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n    }\n\n    /* eslint no-unused-vars: \"off\" */\n    function slideToClosest(speed, runCallbacks, internal, threshold) {\n        if (runCallbacks === void 0) {\n            runCallbacks = true;\n        }\n        if (threshold === void 0) {\n            threshold = 0.5;\n        }\n        const swiper = this;\n        if (swiper.destroyed) return;\n        if (typeof speed === 'undefined') {\n            speed = swiper.params.speed;\n        }\n        let index = swiper.activeIndex;\n        const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n        const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        if (translate >= swiper.snapGrid[snapIndex]) {\n            // The current translate is on or after the current snap index, so the choice\n            // is between the current index and the one after it.\n            const currentSnap = swiper.snapGrid[snapIndex];\n            const nextSnap = swiper.snapGrid[snapIndex + 1];\n            if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n                index += swiper.params.slidesPerGroup;\n            }\n        } else {\n            // The current translate is before the current snap index, so the choice\n            // is between the current index and the one before it.\n            const prevSnap = swiper.snapGrid[snapIndex - 1];\n            const currentSnap = swiper.snapGrid[snapIndex];\n            if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n                index -= swiper.params.slidesPerGroup;\n            }\n        }\n        index = Math.max(index, 0);\n        index = Math.min(index, swiper.slidesGrid.length - 1);\n        return swiper.slideTo(index, speed, runCallbacks, internal);\n    }\n\n    function slideToClickedSlide() {\n        const swiper = this;\n        if (swiper.destroyed) return;\n        const {\n            params,\n            slidesEl\n        } = swiper;\n        const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n        let slideToIndex = swiper.clickedIndex;\n        let realIndex;\n        const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n        if (params.loop) {\n            if (swiper.animating) return;\n            realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n            if (params.centeredSlides) {\n                if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n                    swiper.loopFix();\n                    slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n                    nextTick(() => {\n                        swiper.slideTo(slideToIndex);\n                    });\n                } else {\n                    swiper.slideTo(slideToIndex);\n                }\n            } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n                swiper.loopFix();\n                slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n                nextTick(() => {\n                    swiper.slideTo(slideToIndex);\n                });\n            } else {\n                swiper.slideTo(slideToIndex);\n            }\n        } else {\n            swiper.slideTo(slideToIndex);\n        }\n    }\n\n    var slide = {\n        slideTo,\n        slideToLoop,\n        slideNext,\n        slidePrev,\n        slideReset,\n        slideToClosest,\n        slideToClickedSlide\n    };\n\n    function loopCreate(slideRealIndex) {\n        const swiper = this;\n        const {\n            params,\n            slidesEl\n        } = swiper;\n        if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n        const initSlides = () => {\n            const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n            slides.forEach((el, index) => {\n                el.setAttribute('data-swiper-slide-index', index);\n            });\n        };\n        const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n        const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);\n        const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;\n        const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;\n        const addBlankSlides = amountOfSlides => {\n            for (let i = 0; i < amountOfSlides; i += 1) {\n                const slideEl = swiper.isElement ? createElement('swiper-slide', [params.slideBlankClass]) : createElement('div', [params.slideClass, params.slideBlankClass]);\n                swiper.slidesEl.append(slideEl);\n            }\n        };\n        if (shouldFillGroup) {\n            if (params.loopAddBlankSlides) {\n                const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;\n                addBlankSlides(slidesToAdd);\n                swiper.recalcSlides();\n                swiper.updateSlides();\n            } else {\n                showWarning('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');\n            }\n            initSlides();\n        } else if (shouldFillGrid) {\n            if (params.loopAddBlankSlides) {\n                const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;\n                addBlankSlides(slidesToAdd);\n                swiper.recalcSlides();\n                swiper.updateSlides();\n            } else {\n                showWarning('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');\n            }\n            initSlides();\n        } else {\n            initSlides();\n        }\n        swiper.loopFix({\n            slideRealIndex,\n            direction: params.centeredSlides ? undefined : 'next'\n        });\n    }\n\n    function loopFix(_temp) {\n        let {\n            slideRealIndex,\n            slideTo = true,\n            direction,\n            setTranslate,\n            activeSlideIndex,\n            byController,\n            byMousewheel\n        } = _temp === void 0 ? {} : _temp;\n        const swiper = this;\n        if (!swiper.params.loop) return;\n        swiper.emit('beforeLoopFix');\n        const {\n            slides,\n            allowSlidePrev,\n            allowSlideNext,\n            slidesEl,\n            params\n        } = swiper;\n        const {\n            centeredSlides\n        } = params;\n        swiper.allowSlidePrev = true;\n        swiper.allowSlideNext = true;\n        if (swiper.virtual && params.virtual.enabled) {\n            if (slideTo) {\n                if (!params.centeredSlides && swiper.snapIndex === 0) {\n                    swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n                } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n                    swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n                } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n                    swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n                }\n            }\n            swiper.allowSlidePrev = allowSlidePrev;\n            swiper.allowSlideNext = allowSlideNext;\n            swiper.emit('loopFix');\n            return;\n        }\n        let slidesPerView = params.slidesPerView;\n        if (slidesPerView === 'auto') {\n            slidesPerView = swiper.slidesPerViewDynamic();\n        } else {\n            slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));\n            if (centeredSlides && slidesPerView % 2 === 0) {\n                slidesPerView = slidesPerView + 1;\n            }\n        }\n        const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;\n        let loopedSlides = slidesPerGroup;\n        if (loopedSlides % slidesPerGroup !== 0) {\n            loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;\n        }\n        loopedSlides += params.loopAdditionalSlides;\n        swiper.loopedSlides = loopedSlides;\n        const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n        if (slides.length < slidesPerView + loopedSlides) {\n            showWarning('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');\n        } else if (gridEnabled && params.grid.fill === 'row') {\n            showWarning('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');\n        }\n        const prependSlidesIndexes = [];\n        const appendSlidesIndexes = [];\n        let activeIndex = swiper.activeIndex;\n        if (typeof activeSlideIndex === 'undefined') {\n            activeSlideIndex = swiper.getSlideIndex(slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);\n        } else {\n            activeIndex = activeSlideIndex;\n        }\n        const isNext = direction === 'next' || !direction;\n        const isPrev = direction === 'prev' || !direction;\n        let slidesPrepended = 0;\n        let slidesAppended = 0;\n        const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;\n        const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;\n        const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);\n        // prepend last slides before start\n        if (activeColIndexWithShift < loopedSlides) {\n            slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);\n            for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {\n                const index = i - Math.floor(i / cols) * cols;\n                if (gridEnabled) {\n                    const colIndexToPrepend = cols - index - 1;\n                    for (let i = slides.length - 1; i >= 0; i -= 1) {\n                        if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);\n                    }\n                    // slides.forEach((slide, slideIndex) => {\n                    //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);\n                    // });\n                } else {\n                    prependSlidesIndexes.push(cols - index - 1);\n                }\n            }\n        } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {\n            slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);\n            for (let i = 0; i < slidesAppended; i += 1) {\n                const index = i - Math.floor(i / cols) * cols;\n                if (gridEnabled) {\n                    slides.forEach((slide, slideIndex) => {\n                        if (slide.column === index) appendSlidesIndexes.push(slideIndex);\n                    });\n                } else {\n                    appendSlidesIndexes.push(index);\n                }\n            }\n        }\n        swiper.__preventObserver__ = true;\n        requestAnimationFrame(() => {\n            swiper.__preventObserver__ = false;\n        });\n        if (isPrev) {\n            prependSlidesIndexes.forEach(index => {\n                slides[index].swiperLoopMoveDOM = true;\n                slidesEl.prepend(slides[index]);\n                slides[index].swiperLoopMoveDOM = false;\n            });\n        }\n        if (isNext) {\n            appendSlidesIndexes.forEach(index => {\n                slides[index].swiperLoopMoveDOM = true;\n                slidesEl.append(slides[index]);\n                slides[index].swiperLoopMoveDOM = false;\n            });\n        }\n        swiper.recalcSlides();\n        if (params.slidesPerView === 'auto') {\n            swiper.updateSlides();\n        } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {\n            swiper.slides.forEach((slide, slideIndex) => {\n                swiper.grid.updateSlide(slideIndex, slide, swiper.slides);\n            });\n        }\n        if (params.watchSlidesProgress) {\n            swiper.updateSlidesOffset();\n        }\n        if (slideTo) {\n            if (prependSlidesIndexes.length > 0 && isPrev) {\n                if (typeof slideRealIndex === 'undefined') {\n                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                    const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n                    const diff = newSlideTranslate - currentSlideTranslate;\n                    if (byMousewheel) {\n                        swiper.setTranslate(swiper.translate - diff);\n                    } else {\n                        swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);\n                        if (setTranslate) {\n                            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n                            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n                        }\n                    }\n                } else {\n                    if (setTranslate) {\n                        const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;\n                        swiper.slideTo(swiper.activeIndex + shift, 0, false, true);\n                        swiper.touchEventsData.currentTranslate = swiper.translate;\n                    }\n                }\n            } else if (appendSlidesIndexes.length > 0 && isNext) {\n                if (typeof slideRealIndex === 'undefined') {\n                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                    const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n                    const diff = newSlideTranslate - currentSlideTranslate;\n                    if (byMousewheel) {\n                        swiper.setTranslate(swiper.translate - diff);\n                    } else {\n                        swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n                        if (setTranslate) {\n                            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n                            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n                        }\n                    }\n                } else {\n                    const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;\n                    swiper.slideTo(swiper.activeIndex - shift, 0, false, true);\n                }\n            }\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        if (swiper.controller && swiper.controller.control && !byController) {\n            const loopParams = {\n                slideRealIndex,\n                direction,\n                setTranslate,\n                activeSlideIndex,\n                byController: true\n            };\n            if (Array.isArray(swiper.controller.control)) {\n                swiper.controller.control.forEach(c => {\n                    if (!c.destroyed && c.params.loop) c.loopFix({\n                        ...loopParams,\n                        slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false\n                    });\n                });\n            } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n                swiper.controller.control.loopFix({\n                    ...loopParams,\n                    slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false\n                });\n            }\n        }\n        swiper.emit('loopFix');\n    }\n\n    function loopDestroy() {\n        const swiper = this;\n        const {\n            params,\n            slidesEl\n        } = swiper;\n        if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n        swiper.recalcSlides();\n        const newSlidesOrder = [];\n        swiper.slides.forEach(slideEl => {\n            const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;\n            newSlidesOrder[index] = slideEl;\n        });\n        swiper.slides.forEach(slideEl => {\n            slideEl.removeAttribute('data-swiper-slide-index');\n        });\n        newSlidesOrder.forEach(slideEl => {\n            slidesEl.append(slideEl);\n        });\n        swiper.recalcSlides();\n        swiper.slideTo(swiper.realIndex, 0);\n    }\n\n    var loop = {\n        loopCreate,\n        loopFix,\n        loopDestroy\n    };\n\n    function setGrabCursor(moving) {\n        const swiper = this;\n        if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n        const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n        if (swiper.isElement) {\n            swiper.__preventObserver__ = true;\n        }\n        el.style.cursor = 'move';\n        el.style.cursor = moving ? 'grabbing' : 'grab';\n        if (swiper.isElement) {\n            requestAnimationFrame(() => {\n                swiper.__preventObserver__ = false;\n            });\n        }\n    }\n\n    function unsetGrabCursor() {\n        const swiper = this;\n        if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n            return;\n        }\n        if (swiper.isElement) {\n            swiper.__preventObserver__ = true;\n        }\n        swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n        if (swiper.isElement) {\n            requestAnimationFrame(() => {\n                swiper.__preventObserver__ = false;\n            });\n        }\n    }\n\n    var grabCursor = {\n        setGrabCursor,\n        unsetGrabCursor\n    };\n\n    // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\n    function closestElement(selector, base) {\n        if (base === void 0) {\n            base = this;\n        }\n        function __closestFrom(el) {\n            if (!el || el === getDocument() || el === getWindow()) return null;\n            if (el.assignedSlot) el = el.assignedSlot;\n            const found = el.closest(selector);\n            if (!found && !el.getRootNode) {\n                return null;\n            }\n            return found || __closestFrom(el.getRootNode().host);\n        }\n        return __closestFrom(base);\n    }\n    function preventEdgeSwipe(swiper, event, startX) {\n        const window = getWindow();\n        const {\n            params\n        } = swiper;\n        const edgeSwipeDetection = params.edgeSwipeDetection;\n        const edgeSwipeThreshold = params.edgeSwipeThreshold;\n        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n            if (edgeSwipeDetection === 'prevent') {\n                event.preventDefault();\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    function onTouchStart(event) {\n        const swiper = this;\n        const document = getDocument();\n        let e = event;\n        if (e.originalEvent) e = e.originalEvent;\n        const data = swiper.touchEventsData;\n        if (e.type === 'pointerdown') {\n            if (data.pointerId !== null && data.pointerId !== e.pointerId) {\n                return;\n            }\n            data.pointerId = e.pointerId;\n        } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {\n            data.touchId = e.targetTouches[0].identifier;\n        }\n        if (e.type === 'touchstart') {\n            // don't proceed touch event\n            preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);\n            return;\n        }\n        const {\n            params,\n            touches,\n            enabled\n        } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && e.pointerType === 'mouse') return;\n        if (swiper.animating && params.preventInteractionOnTransition) {\n            return;\n        }\n        if (!swiper.animating && params.cssMode && params.loop) {\n            swiper.loopFix();\n        }\n        let targetEl = e.target;\n        if (params.touchEventsTarget === 'wrapper') {\n            if (!swiper.wrapperEl.contains(targetEl)) return;\n        }\n        if ('which' in e && e.which === 3) return;\n        if ('button' in e && e.button > 0) return;\n        if (data.isTouched && data.isMoved) return;\n\n        // change target el for shadow root component\n        const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n        // eslint-disable-next-line\n        const eventPath = e.composedPath ? e.composedPath() : e.path;\n        if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n            targetEl = eventPath[0];\n        }\n        const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n        const isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n        // use closestElement for shadow root element to get the actual closest for nested shadow root element\n        if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n            swiper.allowClick = true;\n            return;\n        }\n        if (params.swipeHandler) {\n            if (!targetEl.closest(params.swipeHandler)) return;\n        }\n        touches.currentX = e.pageX;\n        touches.currentY = e.pageY;\n        const startX = touches.currentX;\n        const startY = touches.currentY;\n\n        // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n        if (!preventEdgeSwipe(swiper, e, startX)) {\n            return;\n        }\n        Object.assign(data, {\n            isTouched: true,\n            isMoved: false,\n            allowTouchCallbacks: true,\n            isScrolling: undefined,\n            startMoving: undefined\n        });\n        touches.startX = startX;\n        touches.startY = startY;\n        data.touchStartTime = now();\n        swiper.allowClick = true;\n        swiper.updateSize();\n        swiper.swipeDirection = undefined;\n        if (params.threshold > 0) data.allowThresholdMove = false;\n        let preventDefault = true;\n        if (targetEl.matches(data.focusableElements)) {\n            preventDefault = false;\n            if (targetEl.nodeName === 'SELECT') {\n                data.isTouched = false;\n            }\n        }\n        if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {\n            document.activeElement.blur();\n        }\n        const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n            e.preventDefault();\n        }\n        if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n            swiper.freeMode.onTouchStart();\n        }\n        swiper.emit('touchStart', e);\n    }\n\n    function onTouchMove(event) {\n        const document = getDocument();\n        const swiper = this;\n        const data = swiper.touchEventsData;\n        const {\n            params,\n            touches,\n            rtlTranslate: rtl,\n            enabled\n        } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && event.pointerType === 'mouse') return;\n        let e = event;\n        if (e.originalEvent) e = e.originalEvent;\n        if (e.type === 'pointermove') {\n            if (data.touchId !== null) return; // return from pointer if we use touch\n            const id = e.pointerId;\n            if (id !== data.pointerId) return;\n        }\n        let targetTouch;\n        if (e.type === 'touchmove') {\n            targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];\n            if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n        } else {\n            targetTouch = e;\n        }\n        if (!data.isTouched) {\n            if (data.startMoving && data.isScrolling) {\n                swiper.emit('touchMoveOpposite', e);\n            }\n            return;\n        }\n        const pageX = targetTouch.pageX;\n        const pageY = targetTouch.pageY;\n        if (e.preventedByNestedSwiper) {\n            touches.startX = pageX;\n            touches.startY = pageY;\n            return;\n        }\n        if (!swiper.allowTouchMove) {\n            if (!e.target.matches(data.focusableElements)) {\n                swiper.allowClick = false;\n            }\n            if (data.isTouched) {\n                Object.assign(touches, {\n                    startX: pageX,\n                    startY: pageY,\n                    currentX: pageX,\n                    currentY: pageY\n                });\n                data.touchStartTime = now();\n            }\n            return;\n        }\n        if (params.touchReleaseOnEdges && !params.loop) {\n            if (swiper.isVertical()) {\n                // Vertical\n                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n                    data.isTouched = false;\n                    data.isMoved = false;\n                    return;\n                }\n            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n                return;\n            }\n        }\n        if (document.activeElement) {\n            if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n                data.isMoved = true;\n                swiper.allowClick = false;\n                return;\n            }\n        }\n        if (data.allowTouchCallbacks) {\n            swiper.emit('touchMove', e);\n        }\n        touches.previousX = touches.currentX;\n        touches.previousY = touches.currentY;\n        touches.currentX = pageX;\n        touches.currentY = pageY;\n        const diffX = touches.currentX - touches.startX;\n        const diffY = touches.currentY - touches.startY;\n        if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n        if (typeof data.isScrolling === 'undefined') {\n            let touchAngle;\n            if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n                data.isScrolling = false;\n            } else {\n                // eslint-disable-next-line\n                if (diffX * diffX + diffY * diffY >= 25) {\n                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n                }\n            }\n        }\n        if (data.isScrolling) {\n            swiper.emit('touchMoveOpposite', e);\n        }\n        if (typeof data.startMoving === 'undefined') {\n            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n                data.startMoving = true;\n            }\n        }\n        if (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {\n            data.isTouched = false;\n            return;\n        }\n        if (!data.startMoving) {\n            return;\n        }\n        swiper.allowClick = false;\n        if (!params.cssMode && e.cancelable) {\n            e.preventDefault();\n        }\n        if (params.touchMoveStopPropagation && !params.nested) {\n            e.stopPropagation();\n        }\n        let diff = swiper.isHorizontal() ? diffX : diffY;\n        let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n        if (params.oneWayMovement) {\n            diff = Math.abs(diff) * (rtl ? 1 : -1);\n            touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n        }\n        touches.diff = diff;\n        diff *= params.touchRatio;\n        if (rtl) {\n            diff = -diff;\n            touchesDiff = -touchesDiff;\n        }\n        const prevTouchesDirection = swiper.touchesDirection;\n        swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n        swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n        const isLoop = swiper.params.loop && !params.cssMode;\n        const allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;\n        if (!data.isMoved) {\n            if (isLoop && allowLoopFix) {\n                swiper.loopFix({\n                    direction: swiper.swipeDirection\n                });\n            }\n            data.startTranslate = swiper.getTranslate();\n            swiper.setTransition(0);\n            if (swiper.animating) {\n                const evt = new window.CustomEvent('transitionend', {\n                    bubbles: true,\n                    cancelable: true,\n                    detail: {\n                        bySwiperTouchMove: true\n                    }\n                });\n                swiper.wrapperEl.dispatchEvent(evt);\n            }\n            data.allowMomentumBounce = false;\n            // Grab Cursor\n            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n                swiper.setGrabCursor(true);\n            }\n            swiper.emit('sliderFirstMove', e);\n        }\n        let loopFixed;\n        new Date().getTime();\n        if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {\n            Object.assign(touches, {\n                startX: pageX,\n                startY: pageY,\n                currentX: pageX,\n                currentY: pageY,\n                startTranslate: data.currentTranslate\n            });\n            data.loopSwapReset = true;\n            data.startTranslate = data.currentTranslate;\n            return;\n        }\n        swiper.emit('sliderMove', e);\n        data.isMoved = true;\n        data.currentTranslate = diff + data.startTranslate;\n        let disableParentSwiper = true;\n        let resistanceRatio = params.resistanceRatio;\n        if (params.touchReleaseOnEdges) {\n            resistanceRatio = 0;\n        }\n        if (diff > 0) {\n            if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) {\n                swiper.loopFix({\n                    direction: 'prev',\n                    setTranslate: true,\n                    activeSlideIndex: 0\n                });\n            }\n            if (data.currentTranslate > swiper.minTranslate()) {\n                disableParentSwiper = false;\n                if (params.resistance) {\n                    data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n                }\n            }\n        } else if (diff < 0) {\n            if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) {\n                swiper.loopFix({\n                    direction: 'next',\n                    setTranslate: true,\n                    activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n                });\n            }\n            if (data.currentTranslate < swiper.maxTranslate()) {\n                disableParentSwiper = false;\n                if (params.resistance) {\n                    data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n                }\n            }\n        }\n        if (disableParentSwiper) {\n            e.preventedByNestedSwiper = true;\n        }\n\n        // Directions locks\n        if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n            data.currentTranslate = data.startTranslate;\n        }\n        if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n            data.currentTranslate = data.startTranslate;\n        }\n        if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n            data.currentTranslate = data.startTranslate;\n        }\n\n        // Threshold\n        if (params.threshold > 0) {\n            if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n                if (!data.allowThresholdMove) {\n                    data.allowThresholdMove = true;\n                    touches.startX = touches.currentX;\n                    touches.startY = touches.currentY;\n                    data.currentTranslate = data.startTranslate;\n                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n                    return;\n                }\n            } else {\n                data.currentTranslate = data.startTranslate;\n                return;\n            }\n        }\n        if (!params.followFinger || params.cssMode) return;\n\n        // Update active index in free mode\n        if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n            swiper.freeMode.onTouchMove();\n        }\n        // Update progress\n        swiper.updateProgress(data.currentTranslate);\n        // Update translate\n        swiper.setTranslate(data.currentTranslate);\n    }\n\n    function onTouchEnd(event) {\n        const swiper = this;\n        const data = swiper.touchEventsData;\n        let e = event;\n        if (e.originalEvent) e = e.originalEvent;\n        let targetTouch;\n        const isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';\n        if (!isTouchEvent) {\n            if (data.touchId !== null) return; // return from pointer if we use touch\n            if (e.pointerId !== data.pointerId) return;\n            targetTouch = e;\n        } else {\n            targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];\n            if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n        }\n        if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(e.type)) {\n            const proceed = ['pointercancel', 'contextmenu'].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);\n            if (!proceed) {\n                return;\n            }\n        }\n        data.pointerId = null;\n        data.touchId = null;\n        const {\n            params,\n            touches,\n            rtlTranslate: rtl,\n            slidesGrid,\n            enabled\n        } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && e.pointerType === 'mouse') return;\n        if (data.allowTouchCallbacks) {\n            swiper.emit('touchEnd', e);\n        }\n        data.allowTouchCallbacks = false;\n        if (!data.isTouched) {\n            if (data.isMoved && params.grabCursor) {\n                swiper.setGrabCursor(false);\n            }\n            data.isMoved = false;\n            data.startMoving = false;\n            return;\n        }\n\n        // Return Grab Cursor\n        if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n            swiper.setGrabCursor(false);\n        }\n\n        // Time diff\n        const touchEndTime = now();\n        const timeDiff = touchEndTime - data.touchStartTime;\n\n        // Tap, doubleTap, Click\n        if (swiper.allowClick) {\n            const pathTree = e.path || e.composedPath && e.composedPath();\n            swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);\n            swiper.emit('tap click', e);\n            if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n                swiper.emit('doubleTap doubleClick', e);\n            }\n        }\n        data.lastClickTime = now();\n        nextTick(() => {\n            if (!swiper.destroyed) swiper.allowClick = true;\n        });\n        if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {\n            data.isTouched = false;\n            data.isMoved = false;\n            data.startMoving = false;\n            return;\n        }\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        let currentPos;\n        if (params.followFinger) {\n            currentPos = rtl ? swiper.translate : -swiper.translate;\n        } else {\n            currentPos = -data.currentTranslate;\n        }\n        if (params.cssMode) {\n            return;\n        }\n        if (params.freeMode && params.freeMode.enabled) {\n            swiper.freeMode.onTouchEnd({\n                currentPos\n            });\n            return;\n        }\n\n        // Find current slide\n        const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;\n        let stopIndex = 0;\n        let groupSize = swiper.slidesSizesGrid[0];\n        for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n            const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n            if (typeof slidesGrid[i + increment] !== 'undefined') {\n                if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n                    stopIndex = i;\n                    groupSize = slidesGrid[i + increment] - slidesGrid[i];\n                }\n            } else if (swipeToLast || currentPos >= slidesGrid[i]) {\n                stopIndex = i;\n                groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n            }\n        }\n        let rewindFirstIndex = null;\n        let rewindLastIndex = null;\n        if (params.rewind) {\n            if (swiper.isBeginning) {\n                rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n            } else if (swiper.isEnd) {\n                rewindFirstIndex = 0;\n            }\n        }\n        // Find current slide size\n        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n        const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (timeDiff > params.longSwipesMs) {\n            // Long touches\n            if (!params.longSwipes) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            if (swiper.swipeDirection === 'next') {\n                if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);\n            }\n            if (swiper.swipeDirection === 'prev') {\n                if (ratio > 1 - params.longSwipesRatio) {\n                    swiper.slideTo(stopIndex + increment);\n                } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n                    swiper.slideTo(rewindLastIndex);\n                } else {\n                    swiper.slideTo(stopIndex);\n                }\n            }\n        } else {\n            // Short swipes\n            if (!params.shortSwipes) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n            if (!isNavButtonTarget) {\n                if (swiper.swipeDirection === 'next') {\n                    swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n                }\n                if (swiper.swipeDirection === 'prev') {\n                    swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n                }\n            } else if (e.target === swiper.navigation.nextEl) {\n                swiper.slideTo(stopIndex + increment);\n            } else {\n                swiper.slideTo(stopIndex);\n            }\n        }\n    }\n\n    function onResize() {\n        const swiper = this;\n        const {\n            params,\n            el\n        } = swiper;\n        if (el && el.offsetWidth === 0) return;\n\n        // Breakpoints\n        if (params.breakpoints) {\n            swiper.setBreakpoint();\n        }\n\n        // Save locks\n        const {\n            allowSlideNext,\n            allowSlidePrev,\n            snapGrid\n        } = swiper;\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n        // Disable locks on resize\n        swiper.allowSlideNext = true;\n        swiper.allowSlidePrev = true;\n        swiper.updateSize();\n        swiper.updateSlides();\n        swiper.updateSlidesClasses();\n        const isVirtualLoop = isVirtual && params.loop;\n        if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n            swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n        } else {\n            if (swiper.params.loop && !isVirtual) {\n                swiper.slideToLoop(swiper.realIndex, 0, false, true);\n            } else {\n                swiper.slideTo(swiper.activeIndex, 0, false, true);\n            }\n        }\n        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n            clearTimeout(swiper.autoplay.resizeTimeout);\n            swiper.autoplay.resizeTimeout = setTimeout(() => {\n                if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n                    swiper.autoplay.resume();\n                }\n            }, 500);\n        }\n        // Return locks after resize\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n            swiper.checkOverflow();\n        }\n    }\n\n    function onClick(e) {\n        const swiper = this;\n        if (!swiper.enabled) return;\n        if (!swiper.allowClick) {\n            if (swiper.params.preventClicks) e.preventDefault();\n            if (swiper.params.preventClicksPropagation && swiper.animating) {\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n            }\n        }\n    }\n\n    function onScroll() {\n        const swiper = this;\n        const {\n            wrapperEl,\n            rtlTranslate,\n            enabled\n        } = swiper;\n        if (!enabled) return;\n        swiper.previousTranslate = swiper.translate;\n        if (swiper.isHorizontal()) {\n            swiper.translate = -wrapperEl.scrollLeft;\n        } else {\n            swiper.translate = -wrapperEl.scrollTop;\n        }\n        // eslint-disable-next-line\n        if (swiper.translate === 0) swiper.translate = 0;\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        let newProgress;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        if (translatesDiff === 0) {\n            newProgress = 0;\n        } else {\n            newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n        }\n        if (newProgress !== swiper.progress) {\n            swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n        }\n        swiper.emit('setTranslate', swiper.translate, false);\n    }\n\n    function onLoad(e) {\n        const swiper = this;\n        processLazyPreloader(swiper, e.target);\n        if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {\n            return;\n        }\n        swiper.update();\n    }\n\n    function onDocumentTouchStart() {\n        const swiper = this;\n        if (swiper.documentTouchHandlerProceeded) return;\n        swiper.documentTouchHandlerProceeded = true;\n        if (swiper.params.touchReleaseOnEdges) {\n            swiper.el.style.touchAction = 'auto';\n        }\n    }\n\n    const events = (swiper, method) => {\n        const document = getDocument();\n        const {\n            params,\n            el,\n            wrapperEl,\n            device\n        } = swiper;\n        const capture = !!params.nested;\n        const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n        const swiperMethod = method;\n        if (!el || typeof el === 'string') return;\n\n        // Touch Events\n        document[domMethod]('touchstart', swiper.onDocumentTouchStart, {\n            passive: false,\n            capture\n        });\n        el[domMethod]('touchstart', swiper.onTouchStart, {\n            passive: false\n        });\n        el[domMethod]('pointerdown', swiper.onTouchStart, {\n            passive: false\n        });\n        document[domMethod]('touchmove', swiper.onTouchMove, {\n            passive: false,\n            capture\n        });\n        document[domMethod]('pointermove', swiper.onTouchMove, {\n            passive: false,\n            capture\n        });\n        document[domMethod]('touchend', swiper.onTouchEnd, {\n            passive: true\n        });\n        document[domMethod]('pointerup', swiper.onTouchEnd, {\n            passive: true\n        });\n        document[domMethod]('pointercancel', swiper.onTouchEnd, {\n            passive: true\n        });\n        document[domMethod]('touchcancel', swiper.onTouchEnd, {\n            passive: true\n        });\n        document[domMethod]('pointerout', swiper.onTouchEnd, {\n            passive: true\n        });\n        document[domMethod]('pointerleave', swiper.onTouchEnd, {\n            passive: true\n        });\n        document[domMethod]('contextmenu', swiper.onTouchEnd, {\n            passive: true\n        });\n\n        // Prevent Links Clicks\n        if (params.preventClicks || params.preventClicksPropagation) {\n            el[domMethod]('click', swiper.onClick, true);\n        }\n        if (params.cssMode) {\n            wrapperEl[domMethod]('scroll', swiper.onScroll);\n        }\n\n        // Resize handler\n        if (params.updateOnWindowResize) {\n            swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);\n        } else {\n            swiper[swiperMethod]('observerUpdate', onResize, true);\n        }\n\n        // Images loader\n        el[domMethod]('load', swiper.onLoad, {\n            capture: true\n        });\n    };\n    function attachEvents() {\n        const swiper = this;\n        const {\n            params\n        } = swiper;\n        swiper.onTouchStart = onTouchStart.bind(swiper);\n        swiper.onTouchMove = onTouchMove.bind(swiper);\n        swiper.onTouchEnd = onTouchEnd.bind(swiper);\n        swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);\n        if (params.cssMode) {\n            swiper.onScroll = onScroll.bind(swiper);\n        }\n        swiper.onClick = onClick.bind(swiper);\n        swiper.onLoad = onLoad.bind(swiper);\n        events(swiper, 'on');\n    }\n    function detachEvents() {\n        const swiper = this;\n        events(swiper, 'off');\n    }\n    var events$1 = {\n        attachEvents,\n        detachEvents\n    };\n\n    const isGridEnabled = (swiper, params) => {\n        return swiper.grid && params.grid && params.grid.rows > 1;\n    };\n    function setBreakpoint() {\n        const swiper = this;\n        const {\n            realIndex,\n            initialized,\n            params,\n            el\n        } = swiper;\n        const breakpoints = params.breakpoints;\n        if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n\n        // Get breakpoint for window width and update parameters\n        const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n        if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n        const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n        const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n        const wasMultiRow = isGridEnabled(swiper, params);\n        const isMultiRow = isGridEnabled(swiper, breakpointParams);\n        const wasGrabCursor = swiper.params.grabCursor;\n        const isGrabCursor = breakpointParams.grabCursor;\n        const wasEnabled = params.enabled;\n        if (wasMultiRow && !isMultiRow) {\n            el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n            swiper.emitContainerClasses();\n        } else if (!wasMultiRow && isMultiRow) {\n            el.classList.add(`${params.containerModifierClass}grid`);\n            if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {\n                el.classList.add(`${params.containerModifierClass}grid-column`);\n            }\n            swiper.emitContainerClasses();\n        }\n        if (wasGrabCursor && !isGrabCursor) {\n            swiper.unsetGrabCursor();\n        } else if (!wasGrabCursor && isGrabCursor) {\n            swiper.setGrabCursor();\n        }\n\n        // Toggle navigation, pagination, scrollbar\n        ['navigation', 'pagination', 'scrollbar'].forEach(prop => {\n            if (typeof breakpointParams[prop] === 'undefined') return;\n            const wasModuleEnabled = params[prop] && params[prop].enabled;\n            const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n            if (wasModuleEnabled && !isModuleEnabled) {\n                swiper[prop].disable();\n            }\n            if (!wasModuleEnabled && isModuleEnabled) {\n                swiper[prop].enable();\n            }\n        });\n        const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n        const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n        const wasLoop = params.loop;\n        if (directionChanged && initialized) {\n            swiper.changeDirection();\n        }\n        extend(swiper.params, breakpointParams);\n        const isEnabled = swiper.params.enabled;\n        const hasLoop = swiper.params.loop;\n        Object.assign(swiper, {\n            allowTouchMove: swiper.params.allowTouchMove,\n            allowSlideNext: swiper.params.allowSlideNext,\n            allowSlidePrev: swiper.params.allowSlidePrev\n        });\n        if (wasEnabled && !isEnabled) {\n            swiper.disable();\n        } else if (!wasEnabled && isEnabled) {\n            swiper.enable();\n        }\n        swiper.currentBreakpoint = breakpoint;\n        swiper.emit('_beforeBreakpoint', breakpointParams);\n        if (initialized) {\n            if (needsReLoop) {\n                swiper.loopDestroy();\n                swiper.loopCreate(realIndex);\n                swiper.updateSlides();\n            } else if (!wasLoop && hasLoop) {\n                swiper.loopCreate(realIndex);\n                swiper.updateSlides();\n            } else if (wasLoop && !hasLoop) {\n                swiper.loopDestroy();\n            }\n        }\n        swiper.emit('breakpoint', breakpointParams);\n    }\n\n    function getBreakpoint(breakpoints, base, containerEl) {\n        if (base === void 0) {\n            base = 'window';\n        }\n        if (!breakpoints || base === 'container' && !containerEl) return undefined;\n        let breakpoint = false;\n        const window = getWindow();\n        const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n        const points = Object.keys(breakpoints).map(point => {\n            if (typeof point === 'string' && point.indexOf('@') === 0) {\n                const minRatio = parseFloat(point.substr(1));\n                const value = currentHeight * minRatio;\n                return {\n                    value,\n                    point\n                };\n            }\n            return {\n                value: point,\n                point\n            };\n        });\n        points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n        for (let i = 0; i < points.length; i += 1) {\n            const {\n                point,\n                value\n            } = points[i];\n            if (base === 'window') {\n                if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n                    breakpoint = point;\n                }\n            } else if (value <= containerEl.clientWidth) {\n                breakpoint = point;\n            }\n        }\n        return breakpoint || 'max';\n    }\n\n    var breakpoints = {\n        setBreakpoint,\n        getBreakpoint\n    };\n\n    function prepareClasses(entries, prefix) {\n        const resultClasses = [];\n        entries.forEach(item => {\n            if (typeof item === 'object') {\n                Object.keys(item).forEach(classNames => {\n                    if (item[classNames]) {\n                        resultClasses.push(prefix + classNames);\n                    }\n                });\n            } else if (typeof item === 'string') {\n                resultClasses.push(prefix + item);\n            }\n        });\n        return resultClasses;\n    }\n    function addClasses() {\n        const swiper = this;\n        const {\n            classNames,\n            params,\n            rtl,\n            el,\n            device\n        } = swiper;\n        // prettier-ignore\n        const suffixes = prepareClasses(['initialized', params.direction, {\n            'free-mode': swiper.params.freeMode && params.freeMode.enabled\n        }, {\n            'autoheight': params.autoHeight\n        }, {\n            'rtl': rtl\n        }, {\n            'grid': params.grid && params.grid.rows > 1\n        }, {\n            'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'\n        }, {\n            'android': device.android\n        }, {\n            'ios': device.ios\n        }, {\n            'css-mode': params.cssMode\n        }, {\n            'centered': params.cssMode && params.centeredSlides\n        }, {\n            'watch-progress': params.watchSlidesProgress\n        }], params.containerModifierClass);\n        classNames.push(...suffixes);\n        el.classList.add(...classNames);\n        swiper.emitContainerClasses();\n    }\n\n    function removeClasses() {\n        const swiper = this;\n        const {\n            el,\n            classNames\n        } = swiper;\n        if (!el || typeof el === 'string') return;\n        el.classList.remove(...classNames);\n        swiper.emitContainerClasses();\n    }\n\n    var classes = {\n        addClasses,\n        removeClasses\n    };\n\n    function checkOverflow() {\n        const swiper = this;\n        const {\n            isLocked: wasLocked,\n            params\n        } = swiper;\n        const {\n            slidesOffsetBefore\n        } = params;\n        if (slidesOffsetBefore) {\n            const lastSlideIndex = swiper.slides.length - 1;\n            const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n            swiper.isLocked = swiper.size > lastSlideRightEdge;\n        } else {\n            swiper.isLocked = swiper.snapGrid.length === 1;\n        }\n        if (params.allowSlideNext === true) {\n            swiper.allowSlideNext = !swiper.isLocked;\n        }\n        if (params.allowSlidePrev === true) {\n            swiper.allowSlidePrev = !swiper.isLocked;\n        }\n        if (wasLocked && wasLocked !== swiper.isLocked) {\n            swiper.isEnd = false;\n        }\n        if (wasLocked !== swiper.isLocked) {\n            swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n        }\n    }\n    var checkOverflow$1 = {\n        checkOverflow\n    };\n\n    var defaults = {\n        init: true,\n        direction: 'horizontal',\n        oneWayMovement: false,\n        swiperElementNodeName: 'SWIPER-CONTAINER',\n        touchEventsTarget: 'wrapper',\n        initialSlide: 0,\n        speed: 300,\n        cssMode: false,\n        updateOnWindowResize: true,\n        resizeObserver: true,\n        nested: false,\n        createElements: false,\n        eventsPrefix: 'swiper',\n        enabled: true,\n        focusableElements: 'input, select, option, textarea, button, video, label',\n        // Overrides\n        width: null,\n        height: null,\n        //\n        preventInteractionOnTransition: false,\n        // ssr\n        userAgent: null,\n        url: null,\n        // To support iOS's swipe-to-go-back gesture (when being used in-app).\n        edgeSwipeDetection: false,\n        edgeSwipeThreshold: 20,\n        // Autoheight\n        autoHeight: false,\n        // Set wrapper width\n        setWrapperSize: false,\n        // Virtual Translate\n        virtualTranslate: false,\n        // Effects\n        effect: 'slide',\n        // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n        // Breakpoints\n        breakpoints: undefined,\n        breakpointsBase: 'window',\n        // Slides grid\n        spaceBetween: 0,\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        slidesPerGroupSkip: 0,\n        slidesPerGroupAuto: false,\n        centeredSlides: false,\n        centeredSlidesBounds: false,\n        slidesOffsetBefore: 0,\n        // in px\n        slidesOffsetAfter: 0,\n        // in px\n        normalizeSlideIndex: true,\n        centerInsufficientSlides: false,\n        // Disable swiper and hide navigation when container not overflow\n        watchOverflow: true,\n        // Round length\n        roundLengths: false,\n        // Touches\n        touchRatio: 1,\n        touchAngle: 45,\n        simulateTouch: true,\n        shortSwipes: true,\n        longSwipes: true,\n        longSwipesRatio: 0.5,\n        longSwipesMs: 300,\n        followFinger: true,\n        allowTouchMove: true,\n        threshold: 5,\n        touchMoveStopPropagation: false,\n        touchStartPreventDefault: true,\n        touchStartForcePreventDefault: false,\n        touchReleaseOnEdges: false,\n        // Unique Navigation Elements\n        uniqueNavElements: true,\n        // Resistance\n        resistance: true,\n        resistanceRatio: 0.85,\n        // Progress\n        watchSlidesProgress: false,\n        // Cursor\n        grabCursor: false,\n        // Clicks\n        preventClicks: true,\n        preventClicksPropagation: true,\n        slideToClickedSlide: false,\n        // loop\n        loop: false,\n        loopAddBlankSlides: true,\n        loopAdditionalSlides: 0,\n        loopPreventsSliding: true,\n        // rewind\n        rewind: false,\n        // Swiping/no swiping\n        allowSlidePrev: true,\n        allowSlideNext: true,\n        swipeHandler: null,\n        // '.swipe-handler',\n        noSwiping: true,\n        noSwipingClass: 'swiper-no-swiping',\n        noSwipingSelector: null,\n        // Passive Listeners\n        passiveListeners: true,\n        maxBackfaceHiddenSlides: 10,\n        // NS\n        containerModifierClass: 'swiper-',\n        // NEW\n        slideClass: 'swiper-slide',\n        slideBlankClass: 'swiper-slide-blank',\n        slideActiveClass: 'swiper-slide-active',\n        slideVisibleClass: 'swiper-slide-visible',\n        slideFullyVisibleClass: 'swiper-slide-fully-visible',\n        slideNextClass: 'swiper-slide-next',\n        slidePrevClass: 'swiper-slide-prev',\n        wrapperClass: 'swiper-wrapper',\n        lazyPreloaderClass: 'swiper-lazy-preloader',\n        lazyPreloadPrevNext: 0,\n        // Callbacks\n        runCallbacksOnInit: true,\n        // Internals\n        _emitClasses: false\n    };\n\n    function moduleExtendParams(params, allModulesParams) {\n        return function extendParams(obj) {\n            if (obj === void 0) {\n                obj = {};\n            }\n            const moduleParamName = Object.keys(obj)[0];\n            const moduleParams = obj[moduleParamName];\n            if (typeof moduleParams !== 'object' || moduleParams === null) {\n                extend(allModulesParams, obj);\n                return;\n            }\n            if (params[moduleParamName] === true) {\n                params[moduleParamName] = {\n                    enabled: true\n                };\n            }\n            if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {\n                params[moduleParamName].auto = true;\n            }\n            if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {\n                params[moduleParamName].auto = true;\n            }\n            if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n                extend(allModulesParams, obj);\n                return;\n            }\n            if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n                params[moduleParamName].enabled = true;\n            }\n            if (!params[moduleParamName]) params[moduleParamName] = {\n                enabled: false\n            };\n            extend(allModulesParams, obj);\n        };\n    }\n\n    /* eslint no-param-reassign: \"off\" */\n    const prototypes = {\n        eventsEmitter,\n        update,\n        translate,\n        transition,\n        slide,\n        loop,\n        grabCursor,\n        events: events$1,\n        breakpoints,\n        checkOverflow: checkOverflow$1,\n        classes\n    };\n    const extendedDefaults = {};\n    class Swiper {\n        constructor() {\n            let el;\n            let params;\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n            if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\n                params = args[0];\n            } else {\n                [el, params] = args;\n            }\n            if (!params) params = {};\n            params = extend({}, params);\n            if (el && !params.el) params.el = el;\n            const document = getDocument();\n            if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {\n                const swipers = [];\n                document.querySelectorAll(params.el).forEach(containerEl => {\n                    const newParams = extend({}, params, {\n                        el: containerEl\n                    });\n                    swipers.push(new Swiper(newParams));\n                });\n                // eslint-disable-next-line no-constructor-return\n                return swipers;\n            }\n\n            // Swiper Instance\n            const swiper = this;\n            swiper.__swiper__ = true;\n            swiper.support = getSupport();\n            swiper.device = getDevice({\n                userAgent: params.userAgent\n            });\n            swiper.browser = getBrowser();\n            swiper.eventsListeners = {};\n            swiper.eventsAnyListeners = [];\n            swiper.modules = [...swiper.__modules__];\n            if (params.modules && Array.isArray(params.modules)) {\n                swiper.modules.push(...params.modules);\n            }\n            const allModulesParams = {};\n            swiper.modules.forEach(mod => {\n                mod({\n                    params,\n                    swiper,\n                    extendParams: moduleExtendParams(params, allModulesParams),\n                    on: swiper.on.bind(swiper),\n                    once: swiper.once.bind(swiper),\n                    off: swiper.off.bind(swiper),\n                    emit: swiper.emit.bind(swiper)\n                });\n            });\n\n            // Extend defaults with modules params\n            const swiperParams = extend({}, defaults, allModulesParams);\n\n            // Extend defaults with passed params\n            swiper.params = extend({}, swiperParams, extendedDefaults, params);\n            swiper.originalParams = extend({}, swiper.params);\n            swiper.passedParams = extend({}, params);\n\n            // add event listeners\n            if (swiper.params && swiper.params.on) {\n                Object.keys(swiper.params.on).forEach(eventName => {\n                    swiper.on(eventName, swiper.params.on[eventName]);\n                });\n            }\n            if (swiper.params && swiper.params.onAny) {\n                swiper.onAny(swiper.params.onAny);\n            }\n\n            // Extend Swiper\n            Object.assign(swiper, {\n                enabled: swiper.params.enabled,\n                el,\n                // Classes\n                classNames: [],\n                // Slides\n                slides: [],\n                slidesGrid: [],\n                snapGrid: [],\n                slidesSizesGrid: [],\n                // isDirection\n                isHorizontal() {\n                    return swiper.params.direction === 'horizontal';\n                },\n                isVertical() {\n                    return swiper.params.direction === 'vertical';\n                },\n                // Indexes\n                activeIndex: 0,\n                realIndex: 0,\n                //\n                isBeginning: true,\n                isEnd: false,\n                // Props\n                translate: 0,\n                previousTranslate: 0,\n                progress: 0,\n                velocity: 0,\n                animating: false,\n                cssOverflowAdjustment() {\n                    // Returns 0 unless `translate` is > 2**23\n                    // Should be subtracted from css values to prevent overflow\n                    return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n                },\n                // Locks\n                allowSlideNext: swiper.params.allowSlideNext,\n                allowSlidePrev: swiper.params.allowSlidePrev,\n                // Touch Events\n                touchEventsData: {\n                    isTouched: undefined,\n                    isMoved: undefined,\n                    allowTouchCallbacks: undefined,\n                    touchStartTime: undefined,\n                    isScrolling: undefined,\n                    currentTranslate: undefined,\n                    startTranslate: undefined,\n                    allowThresholdMove: undefined,\n                    // Form elements to match\n                    focusableElements: swiper.params.focusableElements,\n                    // Last click time\n                    lastClickTime: 0,\n                    clickTimeout: undefined,\n                    // Velocities\n                    velocities: [],\n                    allowMomentumBounce: undefined,\n                    startMoving: undefined,\n                    pointerId: null,\n                    touchId: null\n                },\n                // Clicks\n                allowClick: true,\n                // Touches\n                allowTouchMove: swiper.params.allowTouchMove,\n                touches: {\n                    startX: 0,\n                    startY: 0,\n                    currentX: 0,\n                    currentY: 0,\n                    diff: 0\n                },\n                // Images\n                imagesToLoad: [],\n                imagesLoaded: 0\n            });\n            swiper.emit('_swiper');\n\n            // Init\n            if (swiper.params.init) {\n                swiper.init();\n            }\n\n            // Return app instance\n            // eslint-disable-next-line no-constructor-return\n            return swiper;\n        }\n        getDirectionLabel(property) {\n            if (this.isHorizontal()) {\n                return property;\n            }\n            // prettier-ignore\n            return {\n                'width': 'height',\n                'margin-top': 'margin-left',\n                'margin-bottom ': 'margin-right',\n                'margin-left': 'margin-top',\n                'margin-right': 'margin-bottom',\n                'padding-left': 'padding-top',\n                'padding-right': 'padding-bottom',\n                'marginRight': 'marginBottom'\n            }[property];\n        }\n        getSlideIndex(slideEl) {\n            const {\n                slidesEl,\n                params\n            } = this;\n            const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n            const firstSlideIndex = elementIndex(slides[0]);\n            return elementIndex(slideEl) - firstSlideIndex;\n        }\n        getSlideIndexByData(index) {\n            return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);\n        }\n        recalcSlides() {\n            const swiper = this;\n            const {\n                slidesEl,\n                params\n            } = swiper;\n            swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n        }\n        enable() {\n            const swiper = this;\n            if (swiper.enabled) return;\n            swiper.enabled = true;\n            if (swiper.params.grabCursor) {\n                swiper.setGrabCursor();\n            }\n            swiper.emit('enable');\n        }\n        disable() {\n            const swiper = this;\n            if (!swiper.enabled) return;\n            swiper.enabled = false;\n            if (swiper.params.grabCursor) {\n                swiper.unsetGrabCursor();\n            }\n            swiper.emit('disable');\n        }\n        setProgress(progress, speed) {\n            const swiper = this;\n            progress = Math.min(Math.max(progress, 0), 1);\n            const min = swiper.minTranslate();\n            const max = swiper.maxTranslate();\n            const current = (max - min) * progress + min;\n            swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        emitContainerClasses() {\n            const swiper = this;\n            if (!swiper.params._emitClasses || !swiper.el) return;\n            const cls = swiper.el.className.split(' ').filter(className => {\n                return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n            });\n            swiper.emit('_containerClasses', cls.join(' '));\n        }\n        getSlideClasses(slideEl) {\n            const swiper = this;\n            if (swiper.destroyed) return '';\n            return slideEl.className.split(' ').filter(className => {\n                return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n            }).join(' ');\n        }\n        emitSlidesClasses() {\n            const swiper = this;\n            if (!swiper.params._emitClasses || !swiper.el) return;\n            const updates = [];\n            swiper.slides.forEach(slideEl => {\n                const classNames = swiper.getSlideClasses(slideEl);\n                updates.push({\n                    slideEl,\n                    classNames\n                });\n                swiper.emit('_slideClass', slideEl, classNames);\n            });\n            swiper.emit('_slideClasses', updates);\n        }\n        slidesPerViewDynamic(view, exact) {\n            if (view === void 0) {\n                view = 'current';\n            }\n            if (exact === void 0) {\n                exact = false;\n            }\n            const swiper = this;\n            const {\n                params,\n                slides,\n                slidesGrid,\n                slidesSizesGrid,\n                size: swiperSize,\n                activeIndex\n            } = swiper;\n            let spv = 1;\n            if (typeof params.slidesPerView === 'number') return params.slidesPerView;\n            if (params.centeredSlides) {\n                let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;\n                let breakLoop;\n                for (let i = activeIndex + 1; i < slides.length; i += 1) {\n                    if (slides[i] && !breakLoop) {\n                        slideSize += Math.ceil(slides[i].swiperSlideSize);\n                        spv += 1;\n                        if (slideSize > swiperSize) breakLoop = true;\n                    }\n                }\n                for (let i = activeIndex - 1; i >= 0; i -= 1) {\n                    if (slides[i] && !breakLoop) {\n                        slideSize += slides[i].swiperSlideSize;\n                        spv += 1;\n                        if (slideSize > swiperSize) breakLoop = true;\n                    }\n                }\n            } else {\n                // eslint-disable-next-line\n                if (view === 'current') {\n                    for (let i = activeIndex + 1; i < slides.length; i += 1) {\n                        const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n                        if (slideInView) {\n                            spv += 1;\n                        }\n                    }\n                } else {\n                    // previous\n                    for (let i = activeIndex - 1; i >= 0; i -= 1) {\n                        const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n                        if (slideInView) {\n                            spv += 1;\n                        }\n                    }\n                }\n            }\n            return spv;\n        }\n        update() {\n            const swiper = this;\n            if (!swiper || swiper.destroyed) return;\n            const {\n                snapGrid,\n                params\n            } = swiper;\n            // Breakpoints\n            if (params.breakpoints) {\n                swiper.setBreakpoint();\n            }\n            [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n                if (imageEl.complete) {\n                    processLazyPreloader(swiper, imageEl);\n                }\n            });\n            swiper.updateSize();\n            swiper.updateSlides();\n            swiper.updateProgress();\n            swiper.updateSlidesClasses();\n            function setTranslate() {\n                const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n                const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n                swiper.setTranslate(newTranslate);\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            }\n            let translated;\n            if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n                setTranslate();\n                if (params.autoHeight) {\n                    swiper.updateAutoHeight();\n                }\n            } else {\n                if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n                    const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n                    translated = swiper.slideTo(slides.length - 1, 0, false, true);\n                } else {\n                    translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n                }\n                if (!translated) {\n                    setTranslate();\n                }\n            }\n            if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n                swiper.checkOverflow();\n            }\n            swiper.emit('update');\n        }\n        changeDirection(newDirection, needUpdate) {\n            if (needUpdate === void 0) {\n                needUpdate = true;\n            }\n            const swiper = this;\n            const currentDirection = swiper.params.direction;\n            if (!newDirection) {\n                // eslint-disable-next-line\n                newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n            }\n            if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\n                return swiper;\n            }\n            swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n            swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n            swiper.emitContainerClasses();\n            swiper.params.direction = newDirection;\n            swiper.slides.forEach(slideEl => {\n                if (newDirection === 'vertical') {\n                    slideEl.style.width = '';\n                } else {\n                    slideEl.style.height = '';\n                }\n            });\n            swiper.emit('changeDirection');\n            if (needUpdate) swiper.update();\n            return swiper;\n        }\n        changeLanguageDirection(direction) {\n            const swiper = this;\n            if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;\n            swiper.rtl = direction === 'rtl';\n            swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n            if (swiper.rtl) {\n                swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n                swiper.el.dir = 'rtl';\n            } else {\n                swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n                swiper.el.dir = 'ltr';\n            }\n            swiper.update();\n        }\n        mount(element) {\n            const swiper = this;\n            if (swiper.mounted) return true;\n\n            // Find el\n            let el = element || swiper.params.el;\n            if (typeof el === 'string') {\n                el = document.querySelector(el);\n            }\n            if (!el) {\n                return false;\n            }\n            el.swiper = swiper;\n            if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {\n                swiper.isElement = true;\n            }\n            const getWrapperSelector = () => {\n                return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n            };\n            const getWrapper = () => {\n                if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n                    const res = el.shadowRoot.querySelector(getWrapperSelector());\n                    // Children needs to return slot items\n                    return res;\n                }\n                return elementChildren(el, getWrapperSelector())[0];\n            };\n            // Find Wrapper\n            let wrapperEl = getWrapper();\n            if (!wrapperEl && swiper.params.createElements) {\n                wrapperEl = createElement('div', swiper.params.wrapperClass);\n                el.append(wrapperEl);\n                elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {\n                    wrapperEl.append(slideEl);\n                });\n            }\n            Object.assign(swiper, {\n                el,\n                wrapperEl,\n                slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,\n                hostEl: swiper.isElement ? el.parentNode.host : el,\n                mounted: true,\n                // RTL\n                rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',\n                rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),\n                wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'\n            });\n            return true;\n        }\n        init(el) {\n            const swiper = this;\n            if (swiper.initialized) return swiper;\n            const mounted = swiper.mount(el);\n            if (mounted === false) return swiper;\n            swiper.emit('beforeInit');\n\n            // Set breakpoint\n            if (swiper.params.breakpoints) {\n                swiper.setBreakpoint();\n            }\n\n            // Add Classes\n            swiper.addClasses();\n\n            // Update size\n            swiper.updateSize();\n\n            // Update slides\n            swiper.updateSlides();\n            if (swiper.params.watchOverflow) {\n                swiper.checkOverflow();\n            }\n\n            // Set Grab Cursor\n            if (swiper.params.grabCursor && swiper.enabled) {\n                swiper.setGrabCursor();\n            }\n\n            // Slide To Initial Slide\n            if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n                swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n            } else {\n                swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n            }\n\n            // Create loop\n            if (swiper.params.loop) {\n                swiper.loopCreate();\n            }\n\n            // Attach events\n            swiper.attachEvents();\n            const lazyElements = [...swiper.el.querySelectorAll('[loading=\"lazy\"]')];\n            if (swiper.isElement) {\n                lazyElements.push(...swiper.hostEl.querySelectorAll('[loading=\"lazy\"]'));\n            }\n            lazyElements.forEach(imageEl => {\n                if (imageEl.complete) {\n                    processLazyPreloader(swiper, imageEl);\n                } else {\n                    imageEl.addEventListener('load', e => {\n                        processLazyPreloader(swiper, e.target);\n                    });\n                }\n            });\n            preload(swiper);\n\n            // Init Flag\n            swiper.initialized = true;\n            preload(swiper);\n\n            // Emit\n            swiper.emit('init');\n            swiper.emit('afterInit');\n            return swiper;\n        }\n        destroy(deleteInstance, cleanStyles) {\n            if (deleteInstance === void 0) {\n                deleteInstance = true;\n            }\n            if (cleanStyles === void 0) {\n                cleanStyles = true;\n            }\n            const swiper = this;\n            const {\n                params,\n                el,\n                wrapperEl,\n                slides\n            } = swiper;\n            if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n                return null;\n            }\n            swiper.emit('beforeDestroy');\n\n            // Init Flag\n            swiper.initialized = false;\n\n            // Detach events\n            swiper.detachEvents();\n\n            // Destroy loop\n            if (params.loop) {\n                swiper.loopDestroy();\n            }\n\n            // Cleanup styles\n            if (cleanStyles) {\n                swiper.removeClasses();\n                if (el && typeof el !== 'string') {\n                    el.removeAttribute('style');\n                }\n                if (wrapperEl) {\n                    wrapperEl.removeAttribute('style');\n                }\n                if (slides && slides.length) {\n                    slides.forEach(slideEl => {\n                        slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n                        slideEl.removeAttribute('style');\n                        slideEl.removeAttribute('data-swiper-slide-index');\n                    });\n                }\n            }\n            swiper.emit('destroy');\n\n            // Detach emitter events\n            Object.keys(swiper.eventsListeners).forEach(eventName => {\n                swiper.off(eventName);\n            });\n            if (deleteInstance !== false) {\n                if (swiper.el && typeof swiper.el !== 'string') {\n                    swiper.el.swiper = null;\n                }\n                deleteProps(swiper);\n            }\n            swiper.destroyed = true;\n            return null;\n        }\n        static extendDefaults(newDefaults) {\n            extend(extendedDefaults, newDefaults);\n        }\n        static get extendedDefaults() {\n            return extendedDefaults;\n        }\n        static get defaults() {\n            return defaults;\n        }\n        static installModule(mod) {\n            if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n            const modules = Swiper.prototype.__modules__;\n            if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n                modules.push(mod);\n            }\n        }\n        static use(module) {\n            if (Array.isArray(module)) {\n                module.forEach(m => Swiper.installModule(m));\n                return Swiper;\n            }\n            Swiper.installModule(module);\n            return Swiper;\n        }\n    }\n    Object.keys(prototypes).forEach(prototypeGroup => {\n        Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {\n            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n        });\n    });\n    Swiper.use([Resize, Observer]);\n\n    function Virtual(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on,\n            emit\n        } = _ref;\n        extendParams({\n            virtual: {\n                enabled: false,\n                slides: [],\n                cache: true,\n                renderSlide: null,\n                renderExternal: null,\n                renderExternalUpdate: true,\n                addSlidesBefore: 0,\n                addSlidesAfter: 0\n            }\n        });\n        let cssModeTimeout;\n        const document = getDocument();\n        swiper.virtual = {\n            cache: {},\n            from: undefined,\n            to: undefined,\n            slides: [],\n            offset: 0,\n            slidesGrid: []\n        };\n        const tempDOM = document.createElement('div');\n        function renderSlide(slide, index) {\n            const params = swiper.params.virtual;\n            if (params.cache && swiper.virtual.cache[index]) {\n                return swiper.virtual.cache[index];\n            }\n            // eslint-disable-next-line\n            let slideEl;\n            if (params.renderSlide) {\n                slideEl = params.renderSlide.call(swiper, slide, index);\n                if (typeof slideEl === 'string') {\n                    tempDOM.innerHTML = slideEl;\n                    slideEl = tempDOM.children[0];\n                }\n            } else if (swiper.isElement) {\n                slideEl = createElement('swiper-slide');\n            } else {\n                slideEl = createElement('div', swiper.params.slideClass);\n            }\n            slideEl.setAttribute('data-swiper-slide-index', index);\n            if (!params.renderSlide) {\n                slideEl.innerHTML = slide;\n            }\n            if (params.cache) {\n                swiper.virtual.cache[index] = slideEl;\n            }\n            return slideEl;\n        }\n        function update(force, beforeInit) {\n            const {\n                slidesPerView,\n                slidesPerGroup,\n                centeredSlides,\n                loop: isLoop,\n                initialSlide\n            } = swiper.params;\n            if (beforeInit && !isLoop && initialSlide > 0) {\n                return;\n            }\n            const {\n                addSlidesBefore,\n                addSlidesAfter\n            } = swiper.params.virtual;\n            const {\n                from: previousFrom,\n                to: previousTo,\n                slides,\n                slidesGrid: previousSlidesGrid,\n                offset: previousOffset\n            } = swiper.virtual;\n            if (!swiper.params.cssMode) {\n                swiper.updateActiveIndex();\n            }\n            const activeIndex = swiper.activeIndex || 0;\n            let offsetProp;\n            if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n            let slidesAfter;\n            let slidesBefore;\n            if (centeredSlides) {\n                slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n                slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n            } else {\n                slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n                slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n            }\n            let from = activeIndex - slidesBefore;\n            let to = activeIndex + slidesAfter;\n            if (!isLoop) {\n                from = Math.max(from, 0);\n                to = Math.min(to, slides.length - 1);\n            }\n            let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n            if (isLoop && activeIndex >= slidesBefore) {\n                from -= slidesBefore;\n                if (!centeredSlides) offset += swiper.slidesGrid[0];\n            } else if (isLoop && activeIndex < slidesBefore) {\n                from = -slidesBefore;\n                if (centeredSlides) offset += swiper.slidesGrid[0];\n            }\n            Object.assign(swiper.virtual, {\n                from,\n                to,\n                offset,\n                slidesGrid: swiper.slidesGrid,\n                slidesBefore,\n                slidesAfter\n            });\n            function onRendered() {\n                swiper.updateSlides();\n                swiper.updateProgress();\n                swiper.updateSlidesClasses();\n                emit('virtualUpdate');\n            }\n            if (previousFrom === from && previousTo === to && !force) {\n                if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n                    swiper.slides.forEach(slideEl => {\n                        slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n                    });\n                }\n                swiper.updateProgress();\n                emit('virtualUpdate');\n                return;\n            }\n            if (swiper.params.virtual.renderExternal) {\n                swiper.params.virtual.renderExternal.call(swiper, {\n                    offset,\n                    from,\n                    to,\n                    slides: function getSlides() {\n                        const slidesToRender = [];\n                        for (let i = from; i <= to; i += 1) {\n                            slidesToRender.push(slides[i]);\n                        }\n                        return slidesToRender;\n                    }()\n                });\n                if (swiper.params.virtual.renderExternalUpdate) {\n                    onRendered();\n                } else {\n                    emit('virtualUpdate');\n                }\n                return;\n            }\n            const prependIndexes = [];\n            const appendIndexes = [];\n            const getSlideIndex = index => {\n                let slideIndex = index;\n                if (index < 0) {\n                    slideIndex = slides.length + index;\n                } else if (slideIndex >= slides.length) {\n                    // eslint-disable-next-line\n                    slideIndex = slideIndex - slides.length;\n                }\n                return slideIndex;\n            };\n            if (force) {\n                swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach(slideEl => {\n                    slideEl.remove();\n                });\n            } else {\n                for (let i = previousFrom; i <= previousTo; i += 1) {\n                    if (i < from || i > to) {\n                        const slideIndex = getSlideIndex(i);\n                        swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`)).forEach(slideEl => {\n                            slideEl.remove();\n                        });\n                    }\n                }\n            }\n            const loopFrom = isLoop ? -slides.length : 0;\n            const loopTo = isLoop ? slides.length * 2 : slides.length;\n            for (let i = loopFrom; i < loopTo; i += 1) {\n                if (i >= from && i <= to) {\n                    const slideIndex = getSlideIndex(i);\n                    if (typeof previousTo === 'undefined' || force) {\n                        appendIndexes.push(slideIndex);\n                    } else {\n                        if (i > previousTo) appendIndexes.push(slideIndex);\n                        if (i < previousFrom) prependIndexes.push(slideIndex);\n                    }\n                }\n            }\n            appendIndexes.forEach(index => {\n                swiper.slidesEl.append(renderSlide(slides[index], index));\n            });\n            if (isLoop) {\n                for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n                    const index = prependIndexes[i];\n                    swiper.slidesEl.prepend(renderSlide(slides[index], index));\n                }\n            } else {\n                prependIndexes.sort((a, b) => b - a);\n                prependIndexes.forEach(index => {\n                    swiper.slidesEl.prepend(renderSlide(slides[index], index));\n                });\n            }\n            elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {\n                slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n            });\n            onRendered();\n        }\n        function appendSlide(slides) {\n            if (typeof slides === 'object' && 'length' in slides) {\n                for (let i = 0; i < slides.length; i += 1) {\n                    if (slides[i]) swiper.virtual.slides.push(slides[i]);\n                }\n            } else {\n                swiper.virtual.slides.push(slides);\n            }\n            update(true);\n        }\n        function prependSlide(slides) {\n            const activeIndex = swiper.activeIndex;\n            let newActiveIndex = activeIndex + 1;\n            let numberOfNewSlides = 1;\n            if (Array.isArray(slides)) {\n                for (let i = 0; i < slides.length; i += 1) {\n                    if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n                }\n                newActiveIndex = activeIndex + slides.length;\n                numberOfNewSlides = slides.length;\n            } else {\n                swiper.virtual.slides.unshift(slides);\n            }\n            if (swiper.params.virtual.cache) {\n                const cache = swiper.virtual.cache;\n                const newCache = {};\n                Object.keys(cache).forEach(cachedIndex => {\n                    const cachedEl = cache[cachedIndex];\n                    const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');\n                    if (cachedElIndex) {\n                        cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\n                    }\n                    newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n                });\n                swiper.virtual.cache = newCache;\n            }\n            update(true);\n            swiper.slideTo(newActiveIndex, 0);\n        }\n        function removeSlide(slidesIndexes) {\n            if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n            let activeIndex = swiper.activeIndex;\n            if (Array.isArray(slidesIndexes)) {\n                for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n                    if (swiper.params.virtual.cache) {\n                        delete swiper.virtual.cache[slidesIndexes[i]];\n                        // shift cache indexes\n                        Object.keys(swiper.virtual.cache).forEach(key => {\n                            if (key > slidesIndexes) {\n                                swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];\n                                swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);\n                                delete swiper.virtual.cache[key];\n                            }\n                        });\n                    }\n                    swiper.virtual.slides.splice(slidesIndexes[i], 1);\n                    if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n                    activeIndex = Math.max(activeIndex, 0);\n                }\n            } else {\n                if (swiper.params.virtual.cache) {\n                    delete swiper.virtual.cache[slidesIndexes];\n                    // shift cache indexes\n                    Object.keys(swiper.virtual.cache).forEach(key => {\n                        if (key > slidesIndexes) {\n                            swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];\n                            swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);\n                            delete swiper.virtual.cache[key];\n                        }\n                    });\n                }\n                swiper.virtual.slides.splice(slidesIndexes, 1);\n                if (slidesIndexes < activeIndex) activeIndex -= 1;\n                activeIndex = Math.max(activeIndex, 0);\n            }\n            update(true);\n            swiper.slideTo(activeIndex, 0);\n        }\n        function removeAllSlides() {\n            swiper.virtual.slides = [];\n            if (swiper.params.virtual.cache) {\n                swiper.virtual.cache = {};\n            }\n            update(true);\n            swiper.slideTo(0, 0);\n        }\n        on('beforeInit', () => {\n            if (!swiper.params.virtual.enabled) return;\n            let domSlidesAssigned;\n            if (typeof swiper.passedParams.virtual.slides === 'undefined') {\n                const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n                if (slides && slides.length) {\n                    swiper.virtual.slides = [...slides];\n                    domSlidesAssigned = true;\n                    slides.forEach((slideEl, slideIndex) => {\n                        slideEl.setAttribute('data-swiper-slide-index', slideIndex);\n                        swiper.virtual.cache[slideIndex] = slideEl;\n                        slideEl.remove();\n                    });\n                }\n            }\n            if (!domSlidesAssigned) {\n                swiper.virtual.slides = swiper.params.virtual.slides;\n            }\n            swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n            swiper.params.watchSlidesProgress = true;\n            swiper.originalParams.watchSlidesProgress = true;\n            update(false, true);\n        });\n        on('setTranslate', () => {\n            if (!swiper.params.virtual.enabled) return;\n            if (swiper.params.cssMode && !swiper._immediateVirtual) {\n                clearTimeout(cssModeTimeout);\n                cssModeTimeout = setTimeout(() => {\n                    update();\n                }, 100);\n            } else {\n                update();\n            }\n        });\n        on('init update resize', () => {\n            if (!swiper.params.virtual.enabled) return;\n            if (swiper.params.cssMode) {\n                setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n            }\n        });\n        Object.assign(swiper.virtual, {\n            appendSlide,\n            prependSlide,\n            removeSlide,\n            removeAllSlides,\n            update\n        });\n    }\n\n    /* eslint-disable consistent-return */\n    function Keyboard(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on,\n            emit\n        } = _ref;\n        const document = getDocument();\n        const window = getWindow();\n        swiper.keyboard = {\n            enabled: false\n        };\n        extendParams({\n            keyboard: {\n                enabled: false,\n                onlyInViewport: true,\n                pageUpDown: true\n            }\n        });\n        function handle(event) {\n            if (!swiper.enabled) return;\n            const {\n                rtlTranslate: rtl\n            } = swiper;\n            let e = event;\n            if (e.originalEvent) e = e.originalEvent; // jquery fix\n            const kc = e.keyCode || e.charCode;\n            const pageUpDown = swiper.params.keyboard.pageUpDown;\n            const isPageUp = pageUpDown && kc === 33;\n            const isPageDown = pageUpDown && kc === 34;\n            const isArrowLeft = kc === 37;\n            const isArrowRight = kc === 39;\n            const isArrowUp = kc === 38;\n            const isArrowDown = kc === 40;\n            // Directions locks\n            if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\n                return false;\n            }\n            if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\n                return false;\n            }\n            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n                return undefined;\n            }\n            if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {\n                return undefined;\n            }\n            if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n                let inView = false;\n                // Check that swiper should be inside of visible area of window\n                if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {\n                    return undefined;\n                }\n                const el = swiper.el;\n                const swiperWidth = el.clientWidth;\n                const swiperHeight = el.clientHeight;\n                const windowWidth = window.innerWidth;\n                const windowHeight = window.innerHeight;\n                const swiperOffset = elementOffset(el);\n                if (rtl) swiperOffset.left -= el.scrollLeft;\n                const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\n                for (let i = 0; i < swiperCoord.length; i += 1) {\n                    const point = swiperCoord[i];\n                    if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n                        if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n                        inView = true;\n                    }\n                }\n                if (!inView) return undefined;\n            }\n            if (swiper.isHorizontal()) {\n                if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n                    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n                }\n                if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();\n                if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();\n            } else {\n                if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n                    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n                }\n                if (isPageDown || isArrowDown) swiper.slideNext();\n                if (isPageUp || isArrowUp) swiper.slidePrev();\n            }\n            emit('keyPress', kc);\n            return undefined;\n        }\n        function enable() {\n            if (swiper.keyboard.enabled) return;\n            document.addEventListener('keydown', handle);\n            swiper.keyboard.enabled = true;\n        }\n        function disable() {\n            if (!swiper.keyboard.enabled) return;\n            document.removeEventListener('keydown', handle);\n            swiper.keyboard.enabled = false;\n        }\n        on('init', () => {\n            if (swiper.params.keyboard.enabled) {\n                enable();\n            }\n        });\n        on('destroy', () => {\n            if (swiper.keyboard.enabled) {\n                disable();\n            }\n        });\n        Object.assign(swiper.keyboard, {\n            enable,\n            disable\n        });\n    }\n\n    /* eslint-disable consistent-return */\n    function Mousewheel(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on,\n            emit\n        } = _ref;\n        const window = getWindow();\n        extendParams({\n            mousewheel: {\n                enabled: false,\n                releaseOnEdges: false,\n                invert: false,\n                forceToAxis: false,\n                sensitivity: 1,\n                eventsTarget: 'container',\n                thresholdDelta: null,\n                thresholdTime: null,\n                noMousewheelClass: 'swiper-no-mousewheel'\n            }\n        });\n        swiper.mousewheel = {\n            enabled: false\n        };\n        let timeout;\n        let lastScrollTime = now();\n        let lastEventBeforeSnap;\n        const recentWheelEvents = [];\n        function normalize(e) {\n            // Reasonable defaults\n            const PIXEL_STEP = 10;\n            const LINE_HEIGHT = 40;\n            const PAGE_HEIGHT = 800;\n            let sX = 0;\n            let sY = 0; // spinX, spinY\n            let pX = 0;\n            let pY = 0; // pixelX, pixelY\n\n            // Legacy\n            if ('detail' in e) {\n                sY = e.detail;\n            }\n            if ('wheelDelta' in e) {\n                sY = -e.wheelDelta / 120;\n            }\n            if ('wheelDeltaY' in e) {\n                sY = -e.wheelDeltaY / 120;\n            }\n            if ('wheelDeltaX' in e) {\n                sX = -e.wheelDeltaX / 120;\n            }\n\n            // side scrolling on FF with DOMMouseScroll\n            if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n                sX = sY;\n                sY = 0;\n            }\n            pX = sX * PIXEL_STEP;\n            pY = sY * PIXEL_STEP;\n            if ('deltaY' in e) {\n                pY = e.deltaY;\n            }\n            if ('deltaX' in e) {\n                pX = e.deltaX;\n            }\n            if (e.shiftKey && !pX) {\n                // if user scrolls with shift he wants horizontal scroll\n                pX = pY;\n                pY = 0;\n            }\n            if ((pX || pY) && e.deltaMode) {\n                if (e.deltaMode === 1) {\n                    // delta in LINE units\n                    pX *= LINE_HEIGHT;\n                    pY *= LINE_HEIGHT;\n                } else {\n                    // delta in PAGE units\n                    pX *= PAGE_HEIGHT;\n                    pY *= PAGE_HEIGHT;\n                }\n            }\n\n            // Fall-back if spin cannot be determined\n            if (pX && !sX) {\n                sX = pX < 1 ? -1 : 1;\n            }\n            if (pY && !sY) {\n                sY = pY < 1 ? -1 : 1;\n            }\n            return {\n                spinX: sX,\n                spinY: sY,\n                pixelX: pX,\n                pixelY: pY\n            };\n        }\n        function handleMouseEnter() {\n            if (!swiper.enabled) return;\n            swiper.mouseEntered = true;\n        }\n        function handleMouseLeave() {\n            if (!swiper.enabled) return;\n            swiper.mouseEntered = false;\n        }\n        function animateSlider(newEvent) {\n            if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n                // Prevent if delta of wheel scroll delta is below configured threshold\n                return false;\n            }\n            if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n                // Prevent if time between scrolls is below configured threshold\n                return false;\n            }\n\n            // If the movement is NOT big enough and\n            // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n            //   Don't go any further (avoid insignificant scroll movement).\n            if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n                // Return false as a default\n                return true;\n            }\n            // If user is scrolling towards the end:\n            //   If the slider hasn't hit the latest slide or\n            //   if the slider is a loop and\n            //   if the slider isn't moving right now:\n            //     Go to next slide and\n            //     emit a scroll event.\n            // Else (the user is scrolling towards the beginning) and\n            // if the slider hasn't hit the first slide or\n            // if the slider is a loop and\n            // if the slider isn't moving right now:\n            //   Go to prev slide and\n            //   emit a scroll event.\n            if (newEvent.direction < 0) {\n                if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n                    swiper.slideNext();\n                    emit('scroll', newEvent.raw);\n                }\n            } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n                swiper.slidePrev();\n                emit('scroll', newEvent.raw);\n            }\n            // If you got here is because an animation has been triggered so store the current time\n            lastScrollTime = new window.Date().getTime();\n            // Return false as a default\n            return false;\n        }\n        function releaseScroll(newEvent) {\n            const params = swiper.params.mousewheel;\n            if (newEvent.direction < 0) {\n                if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n                    // Return true to animate scroll on edges\n                    return true;\n                }\n            } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n                // Return true to animate scroll on edges\n                return true;\n            }\n            return false;\n        }\n        function handle(event) {\n            let e = event;\n            let disableParentSwiper = true;\n            if (!swiper.enabled) return;\n\n            // Ignore event if the target or its parents have the swiper-no-mousewheel class\n            if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n            const params = swiper.params.mousewheel;\n            if (swiper.params.cssMode) {\n                e.preventDefault();\n            }\n            let targetEl = swiper.el;\n            if (swiper.params.mousewheel.eventsTarget !== 'container') {\n                targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n            }\n            const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n            if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n            if (e.originalEvent) e = e.originalEvent; // jquery fix\n            let delta = 0;\n            const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n            const data = normalize(e);\n            if (params.forceToAxis) {\n                if (swiper.isHorizontal()) {\n                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n                } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n            } else {\n                delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n            }\n            if (delta === 0) return true;\n            if (params.invert) delta = -delta;\n\n            // Get the scroll positions\n            let positions = swiper.getTranslate() + delta * params.sensitivity;\n            if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n            if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n            // When loop is true:\n            //     the disableParentSwiper will be true.\n            // When loop is false:\n            //     if the scroll positions is not on edge,\n            //     then the disableParentSwiper will be true.\n            //     if the scroll on edge positions,\n            //     then the disableParentSwiper will be false.\n            disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n            if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n            if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n                // Register the new event in a variable which stores the relevant data\n                const newEvent = {\n                    time: now(),\n                    delta: Math.abs(delta),\n                    direction: Math.sign(delta),\n                    raw: event\n                };\n\n                // Keep the most recent events\n                if (recentWheelEvents.length >= 2) {\n                    recentWheelEvents.shift(); // only store the last N events\n                }\n\n                const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n                recentWheelEvents.push(newEvent);\n\n                // If there is at least one previous recorded event:\n                //   If direction has changed or\n                //   if the scroll is quicker than the previous one:\n                //     Animate the slider.\n                // Else (this is the first time the wheel is moved):\n                //     Animate the slider.\n                if (prevEvent) {\n                    if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n                        animateSlider(newEvent);\n                    }\n                } else {\n                    animateSlider(newEvent);\n                }\n\n                // If it's time to release the scroll:\n                //   Return now so you don't hit the preventDefault.\n                if (releaseScroll(newEvent)) {\n                    return true;\n                }\n            } else {\n                // Freemode or scrollContainer:\n\n                // If we recently snapped after a momentum scroll, then ignore wheel events\n                // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n                // or if it's a new scroll (larger delta or inverse sign as last event before\n                // an end-of-momentum snap).\n                const newEvent = {\n                    time: now(),\n                    delta: Math.abs(delta),\n                    direction: Math.sign(delta)\n                };\n                const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n                if (!ignoreWheelEvents) {\n                    lastEventBeforeSnap = undefined;\n                    let position = swiper.getTranslate() + delta * params.sensitivity;\n                    const wasBeginning = swiper.isBeginning;\n                    const wasEnd = swiper.isEnd;\n                    if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n                    if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n                    swiper.setTransition(0);\n                    swiper.setTranslate(position);\n                    swiper.updateProgress();\n                    swiper.updateActiveIndex();\n                    swiper.updateSlidesClasses();\n                    if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n                        swiper.updateSlidesClasses();\n                    }\n                    if (swiper.params.loop) {\n                        swiper.loopFix({\n                            direction: newEvent.direction < 0 ? 'next' : 'prev',\n                            byMousewheel: true\n                        });\n                    }\n                    if (swiper.params.freeMode.sticky) {\n                        // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n                        // the end of a momentum scroll by storing recent (N=15?) wheel events.\n                        // 1. do all N events have decreasing or same (absolute value) delta?\n                        // 2. did all N events arrive in the last M (M=500?) msecs?\n                        // 3. does the earliest event have an (absolute value) delta that's\n                        //    at least P (P=1?) larger than the most recent event's delta?\n                        // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n                        // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n                        // Snap immediately and ignore remaining wheel events in this scroll.\n                        // See comment above for \"remaining wheel events in this scroll\" determination.\n                        // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n                        clearTimeout(timeout);\n                        timeout = undefined;\n                        if (recentWheelEvents.length >= 15) {\n                            recentWheelEvents.shift(); // only store the last N events\n                        }\n\n                        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n                        const firstEvent = recentWheelEvents[0];\n                        recentWheelEvents.push(newEvent);\n                        if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n                            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n                            recentWheelEvents.splice(0);\n                        } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n                            // We're at the end of the deceleration of a momentum scroll, so there's no need\n                            // to wait for more events. Snap ASAP on the next tick.\n                            // Also, because there's some remaining momentum we'll bias the snap in the\n                            // direction of the ongoing scroll because it's better UX for the scroll to snap\n                            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n                            // if it's already scrolled more than 20% in the current direction, keep going.\n                            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n                            lastEventBeforeSnap = newEvent;\n                            recentWheelEvents.splice(0);\n                            timeout = nextTick(() => {\n                                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                            }, 0); // no delay; move on next tick\n                        }\n\n                        if (!timeout) {\n                            // if we get here, then we haven't detected the end of a momentum scroll, so\n                            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n                            // for 500ms.\n                            timeout = nextTick(() => {\n                                const snapToThreshold = 0.5;\n                                lastEventBeforeSnap = newEvent;\n                                recentWheelEvents.splice(0);\n                                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                            }, 500);\n                        }\n                    }\n\n                    // Emit event\n                    if (!ignoreWheelEvents) emit('scroll', e);\n\n                    // Stop autoplay\n                    if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n                    // Return page scroll on edge positions\n                    if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {\n                        return true;\n                    }\n                }\n            }\n            if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n            return false;\n        }\n        function events(method) {\n            let targetEl = swiper.el;\n            if (swiper.params.mousewheel.eventsTarget !== 'container') {\n                targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n            }\n            targetEl[method]('mouseenter', handleMouseEnter);\n            targetEl[method]('mouseleave', handleMouseLeave);\n            targetEl[method]('wheel', handle);\n        }\n        function enable() {\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.removeEventListener('wheel', handle);\n                return true;\n            }\n            if (swiper.mousewheel.enabled) return false;\n            events('addEventListener');\n            swiper.mousewheel.enabled = true;\n            return true;\n        }\n        function disable() {\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.addEventListener(event, handle);\n                return true;\n            }\n            if (!swiper.mousewheel.enabled) return false;\n            events('removeEventListener');\n            swiper.mousewheel.enabled = false;\n            return true;\n        }\n        on('init', () => {\n            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n                disable();\n            }\n            if (swiper.params.mousewheel.enabled) enable();\n        });\n        on('destroy', () => {\n            if (swiper.params.cssMode) {\n                enable();\n            }\n            if (swiper.mousewheel.enabled) disable();\n        });\n        Object.assign(swiper.mousewheel, {\n            enable,\n            disable\n        });\n    }\n\n    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n        if (swiper.params.createElements) {\n            Object.keys(checkProps).forEach(key => {\n                if (!params[key] && params.auto === true) {\n                    let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n                    if (!element) {\n                        element = createElement('div', checkProps[key]);\n                        element.className = checkProps[key];\n                        swiper.el.append(element);\n                    }\n                    params[key] = element;\n                    originalParams[key] = element;\n                }\n            });\n        }\n        return params;\n    }\n\n    function Navigation(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on,\n            emit\n        } = _ref;\n        extendParams({\n            navigation: {\n                nextEl: null,\n                prevEl: null,\n                hideOnClick: false,\n                disabledClass: 'swiper-button-disabled',\n                hiddenClass: 'swiper-button-hidden',\n                lockClass: 'swiper-button-lock',\n                navigationDisabledClass: 'swiper-navigation-disabled'\n            }\n        });\n        swiper.navigation = {\n            nextEl: null,\n            prevEl: null\n        };\n        function getEl(el) {\n            let res;\n            if (el && typeof el === 'string' && swiper.isElement) {\n                res = swiper.el.querySelector(el);\n                if (res) return res;\n            }\n            if (el) {\n                if (typeof el === 'string') res = [...document.querySelectorAll(el)];\n                if (swiper.params.uniqueNavElements && typeof el === 'string' && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n                    res = swiper.el.querySelector(el);\n                } else if (res && res.length === 1) {\n                    res = res[0];\n                }\n            }\n            if (el && !res) return el;\n            // if (Array.isArray(res) && res.length === 1) res = res[0];\n            return res;\n        }\n        function toggleEl(el, disabled) {\n            const params = swiper.params.navigation;\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                if (subEl) {\n                    subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));\n                    if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;\n                    if (swiper.params.watchOverflow && swiper.enabled) {\n                        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n                    }\n                }\n            });\n        }\n        function update() {\n            // Update Navigation Buttons\n            const {\n                nextEl,\n                prevEl\n            } = swiper.navigation;\n            if (swiper.params.loop) {\n                toggleEl(prevEl, false);\n                toggleEl(nextEl, false);\n                return;\n            }\n            toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n            toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n        }\n        function onPrevClick(e) {\n            e.preventDefault();\n            if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n            swiper.slidePrev();\n            emit('navigationPrev');\n        }\n        function onNextClick(e) {\n            e.preventDefault();\n            if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n            swiper.slideNext();\n            emit('navigationNext');\n        }\n        function init() {\n            const params = swiper.params.navigation;\n            swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n                nextEl: 'swiper-button-next',\n                prevEl: 'swiper-button-prev'\n            });\n            if (!(params.nextEl || params.prevEl)) return;\n            let nextEl = getEl(params.nextEl);\n            let prevEl = getEl(params.prevEl);\n            Object.assign(swiper.navigation, {\n                nextEl,\n                prevEl\n            });\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const initButton = (el, dir) => {\n                if (el) {\n                    el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n                }\n                if (!swiper.enabled && el) {\n                    el.classList.add(...params.lockClass.split(' '));\n                }\n            };\n            nextEl.forEach(el => initButton(el, 'next'));\n            prevEl.forEach(el => initButton(el, 'prev'));\n        }\n        function destroy() {\n            let {\n                nextEl,\n                prevEl\n            } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const destroyButton = (el, dir) => {\n                el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n                el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));\n            };\n            nextEl.forEach(el => destroyButton(el, 'next'));\n            prevEl.forEach(el => destroyButton(el, 'prev'));\n        }\n        on('init', () => {\n            if (swiper.params.navigation.enabled === false) {\n                // eslint-disable-next-line\n                disable();\n            } else {\n                init();\n                update();\n            }\n        });\n        on('toEdge fromEdge lock unlock', () => {\n            update();\n        });\n        on('destroy', () => {\n            destroy();\n        });\n        on('enable disable', () => {\n            let {\n                nextEl,\n                prevEl\n            } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            if (swiper.enabled) {\n                update();\n                return;\n            }\n            [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.add(swiper.params.navigation.lockClass));\n        });\n        on('click', (_s, e) => {\n            let {\n                nextEl,\n                prevEl\n            } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const targetEl = e.target;\n            let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);\n            if (swiper.isElement && !targetIsButton) {\n                const path = e.path || e.composedPath && e.composedPath();\n                if (path) {\n                    targetIsButton = path.find(pathEl => nextEl.includes(pathEl) || prevEl.includes(pathEl));\n                }\n            }\n            if (swiper.params.navigation.hideOnClick && !targetIsButton) {\n                if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n                let isHidden;\n                if (nextEl.length) {\n                    isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n                } else if (prevEl.length) {\n                    isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n                }\n                if (isHidden === true) {\n                    emit('navigationShow');\n                } else {\n                    emit('navigationHide');\n                }\n                [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));\n            }\n        });\n        const enable = () => {\n            swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));\n            init();\n            update();\n        };\n        const disable = () => {\n            swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));\n            destroy();\n        };\n        Object.assign(swiper.navigation, {\n            enable,\n            disable,\n            update,\n            init,\n            destroy\n        });\n    }\n\n    function classesToSelector(classes) {\n        if (classes === void 0) {\n            classes = '';\n        }\n        return `.${classes.trim().replace(/([\\.:!+\\/])/g, '\\\\$1') // eslint-disable-line\n            .replace(/ /g, '.')}`;\n    }\n\n    function Pagination(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on,\n            emit\n        } = _ref;\n        const pfx = 'swiper-pagination';\n        extendParams({\n            pagination: {\n                el: null,\n                bulletElement: 'span',\n                clickable: false,\n                hideOnClick: false,\n                renderBullet: null,\n                renderProgressbar: null,\n                renderFraction: null,\n                renderCustom: null,\n                progressbarOpposite: false,\n                type: 'bullets',\n                // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n                dynamicBullets: false,\n                dynamicMainBullets: 1,\n                formatFractionCurrent: number => number,\n                formatFractionTotal: number => number,\n                bulletClass: `${pfx}-bullet`,\n                bulletActiveClass: `${pfx}-bullet-active`,\n                modifierClass: `${pfx}-`,\n                currentClass: `${pfx}-current`,\n                totalClass: `${pfx}-total`,\n                hiddenClass: `${pfx}-hidden`,\n                progressbarFillClass: `${pfx}-progressbar-fill`,\n                progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n                clickableClass: `${pfx}-clickable`,\n                lockClass: `${pfx}-lock`,\n                horizontalClass: `${pfx}-horizontal`,\n                verticalClass: `${pfx}-vertical`,\n                paginationDisabledClass: `${pfx}-disabled`\n            }\n        });\n        swiper.pagination = {\n            el: null,\n            bullets: []\n        };\n        let bulletSize;\n        let dynamicBulletIndex = 0;\n        function isPaginationDisabled() {\n            return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n        }\n        function setSideBullets(bulletEl, position) {\n            const {\n                bulletActiveClass\n            } = swiper.params.pagination;\n            if (!bulletEl) return;\n            bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n            if (bulletEl) {\n                bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n                bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n                if (bulletEl) {\n                    bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n                }\n            }\n        }\n        function onBulletClick(e) {\n            const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n            if (!bulletEl) {\n                return;\n            }\n            e.preventDefault();\n            const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n            if (swiper.params.loop) {\n                if (swiper.realIndex === index) return;\n                swiper.slideToLoop(index);\n            } else {\n                swiper.slideTo(index);\n            }\n        }\n        function update() {\n            // Render || Update Pagination bullets/items\n            const rtl = swiper.rtl;\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            let el = swiper.pagination.el;\n            el = makeElementsArray(el);\n            // Current/Total\n            let current;\n            let previousIndex;\n            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n            const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n            if (swiper.params.loop) {\n                previousIndex = swiper.previousRealIndex || 0;\n                current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n            } else if (typeof swiper.snapIndex !== 'undefined') {\n                current = swiper.snapIndex;\n                previousIndex = swiper.previousSnapIndex;\n            } else {\n                previousIndex = swiper.previousIndex || 0;\n                current = swiper.activeIndex || 0;\n            }\n            // Types\n            if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n                const bullets = swiper.pagination.bullets;\n                let firstIndex;\n                let lastIndex;\n                let midIndex;\n                if (params.dynamicBullets) {\n                    bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);\n                    el.forEach(subEl => {\n                        subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n                    });\n                    if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n                        dynamicBulletIndex += current - (previousIndex || 0);\n                        if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n                            dynamicBulletIndex = params.dynamicMainBullets - 1;\n                        } else if (dynamicBulletIndex < 0) {\n                            dynamicBulletIndex = 0;\n                        }\n                    }\n                    firstIndex = Math.max(current - dynamicBulletIndex, 0);\n                    lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n                    midIndex = (lastIndex + firstIndex) / 2;\n                }\n                bullets.forEach(bulletEl => {\n                    const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();\n                    bulletEl.classList.remove(...classesToRemove);\n                });\n                if (el.length > 1) {\n                    bullets.forEach(bullet => {\n                        const bulletIndex = elementIndex(bullet);\n                        if (bulletIndex === current) {\n                            bullet.classList.add(...params.bulletActiveClass.split(' '));\n                        } else if (swiper.isElement) {\n                            bullet.setAttribute('part', 'bullet');\n                        }\n                        if (params.dynamicBullets) {\n                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n                                bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n                            }\n                            if (bulletIndex === firstIndex) {\n                                setSideBullets(bullet, 'prev');\n                            }\n                            if (bulletIndex === lastIndex) {\n                                setSideBullets(bullet, 'next');\n                            }\n                        }\n                    });\n                } else {\n                    const bullet = bullets[current];\n                    if (bullet) {\n                        bullet.classList.add(...params.bulletActiveClass.split(' '));\n                    }\n                    if (swiper.isElement) {\n                        bullets.forEach((bulletEl, bulletIndex) => {\n                            bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');\n                        });\n                    }\n                    if (params.dynamicBullets) {\n                        const firstDisplayedBullet = bullets[firstIndex];\n                        const lastDisplayedBullet = bullets[lastIndex];\n                        for (let i = firstIndex; i <= lastIndex; i += 1) {\n                            if (bullets[i]) {\n                                bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n                            }\n                        }\n                        setSideBullets(firstDisplayedBullet, 'prev');\n                        setSideBullets(lastDisplayedBullet, 'next');\n                    }\n                }\n                if (params.dynamicBullets) {\n                    const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n                    const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n                    const offsetProp = rtl ? 'right' : 'left';\n                    bullets.forEach(bullet => {\n                        bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;\n                    });\n                }\n            }\n            el.forEach((subEl, subElIndex) => {\n                if (params.type === 'fraction') {\n                    subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {\n                        fractionEl.textContent = params.formatFractionCurrent(current + 1);\n                    });\n                    subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {\n                        totalEl.textContent = params.formatFractionTotal(total);\n                    });\n                }\n                if (params.type === 'progressbar') {\n                    let progressbarDirection;\n                    if (params.progressbarOpposite) {\n                        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n                    } else {\n                        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n                    }\n                    const scale = (current + 1) / total;\n                    let scaleX = 1;\n                    let scaleY = 1;\n                    if (progressbarDirection === 'horizontal') {\n                        scaleX = scale;\n                    } else {\n                        scaleY = scale;\n                    }\n                    subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {\n                        progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n                        progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n                    });\n                }\n                if (params.type === 'custom' && params.renderCustom) {\n                    subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n                    if (subElIndex === 0) emit('paginationRender', subEl);\n                } else {\n                    if (subElIndex === 0) emit('paginationRender', subEl);\n                    emit('paginationUpdate', subEl);\n                }\n                if (swiper.params.watchOverflow && swiper.enabled) {\n                    subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n                }\n            });\n        }\n        function render() {\n            // Render Container\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;\n            let el = swiper.pagination.el;\n            el = makeElementsArray(el);\n            let paginationHTML = '';\n            if (params.type === 'bullets') {\n                let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n                if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n                    numberOfBullets = slidesLength;\n                }\n                for (let i = 0; i < numberOfBullets; i += 1) {\n                    if (params.renderBullet) {\n                        paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n                    } else {\n                        // prettier-ignore\n                        paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : ''} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n                    }\n                }\n            }\n            if (params.type === 'fraction') {\n                if (params.renderFraction) {\n                    paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n                } else {\n                    paginationHTML = `<span class=\"${params.currentClass}\"></span>` + ' / ' + `<span class=\"${params.totalClass}\"></span>`;\n                }\n            }\n            if (params.type === 'progressbar') {\n                if (params.renderProgressbar) {\n                    paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n                } else {\n                    paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n                }\n            }\n            swiper.pagination.bullets = [];\n            el.forEach(subEl => {\n                if (params.type !== 'custom') {\n                    subEl.innerHTML = paginationHTML || '';\n                }\n                if (params.type === 'bullets') {\n                    swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n                }\n            });\n            if (params.type !== 'custom') {\n                emit('paginationRender', el[0]);\n            }\n        }\n        function init() {\n            swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n                el: 'swiper-pagination'\n            });\n            const params = swiper.params.pagination;\n            if (!params.el) return;\n            let el;\n            if (typeof params.el === 'string' && swiper.isElement) {\n                el = swiper.el.querySelector(params.el);\n            }\n            if (!el && typeof params.el === 'string') {\n                el = [...document.querySelectorAll(params.el)];\n            }\n            if (!el) {\n                el = params.el;\n            }\n            if (!el || el.length === 0) return;\n            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {\n                el = [...swiper.el.querySelectorAll(params.el)];\n                // check if it belongs to another nested Swiper\n                if (el.length > 1) {\n                    el = el.filter(subEl => {\n                        if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;\n                        return true;\n                    })[0];\n                }\n            }\n            if (Array.isArray(el) && el.length === 1) el = el[0];\n            Object.assign(swiper.pagination, {\n                el\n            });\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                if (params.type === 'bullets' && params.clickable) {\n                    subEl.classList.add(...(params.clickableClass || '').split(' '));\n                }\n                subEl.classList.add(params.modifierClass + params.type);\n                subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n                if (params.type === 'bullets' && params.dynamicBullets) {\n                    subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n                    dynamicBulletIndex = 0;\n                    if (params.dynamicMainBullets < 1) {\n                        params.dynamicMainBullets = 1;\n                    }\n                }\n                if (params.type === 'progressbar' && params.progressbarOpposite) {\n                    subEl.classList.add(params.progressbarOppositeClass);\n                }\n                if (params.clickable) {\n                    subEl.addEventListener('click', onBulletClick);\n                }\n                if (!swiper.enabled) {\n                    subEl.classList.add(params.lockClass);\n                }\n            });\n        }\n        function destroy() {\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            let el = swiper.pagination.el;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach(subEl => {\n                    subEl.classList.remove(params.hiddenClass);\n                    subEl.classList.remove(params.modifierClass + params.type);\n                    subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n                    if (params.clickable) {\n                        subEl.classList.remove(...(params.clickableClass || '').split(' '));\n                        subEl.removeEventListener('click', onBulletClick);\n                    }\n                });\n            }\n            if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));\n        }\n        on('changeDirection', () => {\n            if (!swiper.pagination || !swiper.pagination.el) return;\n            const params = swiper.params.pagination;\n            let {\n                el\n            } = swiper.pagination;\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.classList.remove(params.horizontalClass, params.verticalClass);\n                subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            });\n        });\n        on('init', () => {\n            if (swiper.params.pagination.enabled === false) {\n                // eslint-disable-next-line\n                disable();\n            } else {\n                init();\n                render();\n                update();\n            }\n        });\n        on('activeIndexChange', () => {\n            if (typeof swiper.snapIndex === 'undefined') {\n                update();\n            }\n        });\n        on('snapIndexChange', () => {\n            update();\n        });\n        on('snapGridLengthChange', () => {\n            render();\n            update();\n        });\n        on('destroy', () => {\n            destroy();\n        });\n        on('enable disable', () => {\n            let {\n                el\n            } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));\n            }\n        });\n        on('lock unlock', () => {\n            update();\n        });\n        on('click', (_s, e) => {\n            const targetEl = e.target;\n            const el = makeElementsArray(swiper.pagination.el);\n            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n                if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n                const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n                if (isHidden === true) {\n                    emit('paginationShow');\n                } else {\n                    emit('paginationHide');\n                }\n                el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n            }\n        });\n        const enable = () => {\n            swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n            let {\n                el\n            } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n            }\n            init();\n            render();\n            update();\n        };\n        const disable = () => {\n            swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n            let {\n                el\n            } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n            }\n            destroy();\n        };\n        Object.assign(swiper.pagination, {\n            enable,\n            disable,\n            render,\n            update,\n            init,\n            destroy\n        });\n    }\n\n    function Scrollbar(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on,\n            emit\n        } = _ref;\n        const document = getDocument();\n        let isTouched = false;\n        let timeout = null;\n        let dragTimeout = null;\n        let dragStartPos;\n        let dragSize;\n        let trackSize;\n        let divider;\n        extendParams({\n            scrollbar: {\n                el: null,\n                dragSize: 'auto',\n                hide: false,\n                draggable: false,\n                snapOnRelease: true,\n                lockClass: 'swiper-scrollbar-lock',\n                dragClass: 'swiper-scrollbar-drag',\n                scrollbarDisabledClass: 'swiper-scrollbar-disabled',\n                horizontalClass: `swiper-scrollbar-horizontal`,\n                verticalClass: `swiper-scrollbar-vertical`\n            }\n        });\n        swiper.scrollbar = {\n            el: null,\n            dragEl: null\n        };\n        function setTranslate() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            const {\n                scrollbar,\n                rtlTranslate: rtl\n            } = swiper;\n            const {\n                dragEl,\n                el\n            } = scrollbar;\n            const params = swiper.params.scrollbar;\n            const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n            let newSize = dragSize;\n            let newPos = (trackSize - dragSize) * progress;\n            if (rtl) {\n                newPos = -newPos;\n                if (newPos > 0) {\n                    newSize = dragSize - newPos;\n                    newPos = 0;\n                } else if (-newPos + dragSize > trackSize) {\n                    newSize = trackSize + newPos;\n                }\n            } else if (newPos < 0) {\n                newSize = dragSize + newPos;\n                newPos = 0;\n            } else if (newPos + dragSize > trackSize) {\n                newSize = trackSize - newPos;\n            }\n            if (swiper.isHorizontal()) {\n                dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n                dragEl.style.width = `${newSize}px`;\n            } else {\n                dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n                dragEl.style.height = `${newSize}px`;\n            }\n            if (params.hide) {\n                clearTimeout(timeout);\n                el.style.opacity = 1;\n                timeout = setTimeout(() => {\n                    el.style.opacity = 0;\n                    el.style.transitionDuration = '400ms';\n                }, 1000);\n            }\n        }\n        function setTransition(duration) {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n        }\n        function updateSize() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            const {\n                scrollbar\n            } = swiper;\n            const {\n                dragEl,\n                el\n            } = scrollbar;\n            dragEl.style.width = '';\n            dragEl.style.height = '';\n            trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n            divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n            if (swiper.params.scrollbar.dragSize === 'auto') {\n                dragSize = trackSize * divider;\n            } else {\n                dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n            }\n            if (swiper.isHorizontal()) {\n                dragEl.style.width = `${dragSize}px`;\n            } else {\n                dragEl.style.height = `${dragSize}px`;\n            }\n            if (divider >= 1) {\n                el.style.display = 'none';\n            } else {\n                el.style.display = '';\n            }\n            if (swiper.params.scrollbar.hide) {\n                el.style.opacity = 0;\n            }\n            if (swiper.params.watchOverflow && swiper.enabled) {\n                scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);\n            }\n        }\n        function getPointerPosition(e) {\n            return swiper.isHorizontal() ? e.clientX : e.clientY;\n        }\n        function setDragPosition(e) {\n            const {\n                scrollbar,\n                rtlTranslate: rtl\n            } = swiper;\n            const {\n                el\n            } = scrollbar;\n            let positionRatio;\n            positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n            positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n            if (rtl) {\n                positionRatio = 1 - positionRatio;\n            }\n            const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n            swiper.updateProgress(position);\n            swiper.setTranslate(position);\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        function onDragStart(e) {\n            const params = swiper.params.scrollbar;\n            const {\n                scrollbar,\n                wrapperEl\n            } = swiper;\n            const {\n                el,\n                dragEl\n            } = scrollbar;\n            isTouched = true;\n            dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;\n            e.preventDefault();\n            e.stopPropagation();\n            wrapperEl.style.transitionDuration = '100ms';\n            dragEl.style.transitionDuration = '100ms';\n            setDragPosition(e);\n            clearTimeout(dragTimeout);\n            el.style.transitionDuration = '0ms';\n            if (params.hide) {\n                el.style.opacity = 1;\n            }\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style['scroll-snap-type'] = 'none';\n            }\n            emit('scrollbarDragStart', e);\n        }\n        function onDragMove(e) {\n            const {\n                scrollbar,\n                wrapperEl\n            } = swiper;\n            const {\n                el,\n                dragEl\n            } = scrollbar;\n            if (!isTouched) return;\n            if (e.preventDefault && e.cancelable) e.preventDefault();else e.returnValue = false;\n            setDragPosition(e);\n            wrapperEl.style.transitionDuration = '0ms';\n            el.style.transitionDuration = '0ms';\n            dragEl.style.transitionDuration = '0ms';\n            emit('scrollbarDragMove', e);\n        }\n        function onDragEnd(e) {\n            const params = swiper.params.scrollbar;\n            const {\n                scrollbar,\n                wrapperEl\n            } = swiper;\n            const {\n                el\n            } = scrollbar;\n            if (!isTouched) return;\n            isTouched = false;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style['scroll-snap-type'] = '';\n                wrapperEl.style.transitionDuration = '';\n            }\n            if (params.hide) {\n                clearTimeout(dragTimeout);\n                dragTimeout = nextTick(() => {\n                    el.style.opacity = 0;\n                    el.style.transitionDuration = '400ms';\n                }, 1000);\n            }\n            emit('scrollbarDragEnd', e);\n            if (params.snapOnRelease) {\n                swiper.slideToClosest();\n            }\n        }\n        function events(method) {\n            const {\n                scrollbar,\n                params\n            } = swiper;\n            const el = scrollbar.el;\n            if (!el) return;\n            const target = el;\n            const activeListener = params.passiveListeners ? {\n                passive: false,\n                capture: false\n            } : false;\n            const passiveListener = params.passiveListeners ? {\n                passive: true,\n                capture: false\n            } : false;\n            if (!target) return;\n            const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n            target[eventMethod]('pointerdown', onDragStart, activeListener);\n            document[eventMethod]('pointermove', onDragMove, activeListener);\n            document[eventMethod]('pointerup', onDragEnd, passiveListener);\n        }\n        function enableDraggable() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            events('on');\n        }\n        function disableDraggable() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            events('off');\n        }\n        function init() {\n            const {\n                scrollbar,\n                el: swiperEl\n            } = swiper;\n            swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n                el: 'swiper-scrollbar'\n            });\n            const params = swiper.params.scrollbar;\n            if (!params.el) return;\n            let el;\n            if (typeof params.el === 'string' && swiper.isElement) {\n                el = swiper.el.querySelector(params.el);\n            }\n            if (!el && typeof params.el === 'string') {\n                el = document.querySelectorAll(params.el);\n                if (!el.length) return;\n            } else if (!el) {\n                el = params.el;\n            }\n            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {\n                el = swiperEl.querySelector(params.el);\n            }\n            if (el.length > 0) el = el[0];\n            el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            let dragEl;\n            if (el) {\n                dragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));\n                if (!dragEl) {\n                    dragEl = createElement('div', swiper.params.scrollbar.dragClass);\n                    el.append(dragEl);\n                }\n            }\n            Object.assign(scrollbar, {\n                el,\n                dragEl\n            });\n            if (params.draggable) {\n                enableDraggable();\n            }\n            if (el) {\n                el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));\n            }\n        }\n        function destroy() {\n            const params = swiper.params.scrollbar;\n            const el = swiper.scrollbar.el;\n            if (el) {\n                el.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));\n            }\n            disableDraggable();\n        }\n        on('changeDirection', () => {\n            if (!swiper.scrollbar || !swiper.scrollbar.el) return;\n            const params = swiper.params.scrollbar;\n            let {\n                el\n            } = swiper.scrollbar;\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.classList.remove(params.horizontalClass, params.verticalClass);\n                subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            });\n        });\n        on('init', () => {\n            if (swiper.params.scrollbar.enabled === false) {\n                // eslint-disable-next-line\n                disable();\n            } else {\n                init();\n                updateSize();\n                setTranslate();\n            }\n        });\n        on('update resize observerUpdate lock unlock changeDirection', () => {\n            updateSize();\n        });\n        on('setTranslate', () => {\n            setTranslate();\n        });\n        on('setTransition', (_s, duration) => {\n            setTransition(duration);\n        });\n        on('enable disable', () => {\n            const {\n                el\n            } = swiper.scrollbar;\n            if (el) {\n                el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));\n            }\n        });\n        on('destroy', () => {\n            destroy();\n        });\n        const enable = () => {\n            swiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n            if (swiper.scrollbar.el) {\n                swiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n            }\n            init();\n            updateSize();\n            setTranslate();\n        };\n        const disable = () => {\n            swiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n            if (swiper.scrollbar.el) {\n                swiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n            }\n            destroy();\n        };\n        Object.assign(swiper.scrollbar, {\n            enable,\n            disable,\n            updateSize,\n            setTranslate,\n            init,\n            destroy\n        });\n    }\n\n    function Parallax(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            parallax: {\n                enabled: false\n            }\n        });\n        const elementsSelector = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]';\n        const setTransform = (el, progress) => {\n            const {\n                rtl\n            } = swiper;\n            const rtlFactor = rtl ? -1 : 1;\n            const p = el.getAttribute('data-swiper-parallax') || '0';\n            let x = el.getAttribute('data-swiper-parallax-x');\n            let y = el.getAttribute('data-swiper-parallax-y');\n            const scale = el.getAttribute('data-swiper-parallax-scale');\n            const opacity = el.getAttribute('data-swiper-parallax-opacity');\n            const rotate = el.getAttribute('data-swiper-parallax-rotate');\n            if (x || y) {\n                x = x || '0';\n                y = y || '0';\n            } else if (swiper.isHorizontal()) {\n                x = p;\n                y = '0';\n            } else {\n                y = p;\n                x = '0';\n            }\n            if (x.indexOf('%') >= 0) {\n                x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n            } else {\n                x = `${x * progress * rtlFactor}px`;\n            }\n            if (y.indexOf('%') >= 0) {\n                y = `${parseInt(y, 10) * progress}%`;\n            } else {\n                y = `${y * progress}px`;\n            }\n            if (typeof opacity !== 'undefined' && opacity !== null) {\n                const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n                el.style.opacity = currentOpacity;\n            }\n            let transform = `translate3d(${x}, ${y}, 0px)`;\n            if (typeof scale !== 'undefined' && scale !== null) {\n                const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n                transform += ` scale(${currentScale})`;\n            }\n            if (rotate && typeof rotate !== 'undefined' && rotate !== null) {\n                const currentRotate = rotate * progress * -1;\n                transform += ` rotate(${currentRotate}deg)`;\n            }\n            el.style.transform = transform;\n        };\n        const setTranslate = () => {\n            const {\n                el,\n                slides,\n                progress,\n                snapGrid,\n                isElement\n            } = swiper;\n            const elements = elementChildren(el, elementsSelector);\n            if (swiper.isElement) {\n                elements.push(...elementChildren(swiper.hostEl, elementsSelector));\n            }\n            elements.forEach(subEl => {\n                setTransform(subEl, progress);\n            });\n            slides.forEach((slideEl, slideIndex) => {\n                let slideProgress = slideEl.progress;\n                if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n                    slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n                }\n                slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n                slideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach(subEl => {\n                    setTransform(subEl, slideProgress);\n                });\n            });\n        };\n        const setTransition = function (duration) {\n            if (duration === void 0) {\n                duration = swiper.params.speed;\n            }\n            const {\n                el,\n                hostEl\n            } = swiper;\n            const elements = [...el.querySelectorAll(elementsSelector)];\n            if (swiper.isElement) {\n                elements.push(...hostEl.querySelectorAll(elementsSelector));\n            }\n            elements.forEach(parallaxEl => {\n                let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;\n                if (duration === 0) parallaxDuration = 0;\n                parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n            });\n        };\n        on('beforeInit', () => {\n            if (!swiper.params.parallax.enabled) return;\n            swiper.params.watchSlidesProgress = true;\n            swiper.originalParams.watchSlidesProgress = true;\n        });\n        on('init', () => {\n            if (!swiper.params.parallax.enabled) return;\n            setTranslate();\n        });\n        on('setTranslate', () => {\n            if (!swiper.params.parallax.enabled) return;\n            setTranslate();\n        });\n        on('setTransition', (_swiper, duration) => {\n            if (!swiper.params.parallax.enabled) return;\n            setTransition(duration);\n        });\n    }\n\n    function Zoom(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on,\n            emit\n        } = _ref;\n        const window = getWindow();\n        extendParams({\n            zoom: {\n                enabled: false,\n                limitToOriginalSize: false,\n                maxRatio: 3,\n                minRatio: 1,\n                toggle: true,\n                containerClass: 'swiper-zoom-container',\n                zoomedSlideClass: 'swiper-slide-zoomed'\n            }\n        });\n        swiper.zoom = {\n            enabled: false\n        };\n        let currentScale = 1;\n        let isScaling = false;\n        let fakeGestureTouched;\n        let fakeGestureMoved;\n        const evCache = [];\n        const gesture = {\n            originX: 0,\n            originY: 0,\n            slideEl: undefined,\n            slideWidth: undefined,\n            slideHeight: undefined,\n            imageEl: undefined,\n            imageWrapEl: undefined,\n            maxRatio: 3\n        };\n        const image = {\n            isTouched: undefined,\n            isMoved: undefined,\n            currentX: undefined,\n            currentY: undefined,\n            minX: undefined,\n            minY: undefined,\n            maxX: undefined,\n            maxY: undefined,\n            width: undefined,\n            height: undefined,\n            startX: undefined,\n            startY: undefined,\n            touchesStart: {},\n            touchesCurrent: {}\n        };\n        const velocity = {\n            x: undefined,\n            y: undefined,\n            prevPositionX: undefined,\n            prevPositionY: undefined,\n            prevTime: undefined\n        };\n        let scale = 1;\n        Object.defineProperty(swiper.zoom, 'scale', {\n            get() {\n                return scale;\n            },\n            set(value) {\n                if (scale !== value) {\n                    const imageEl = gesture.imageEl;\n                    const slideEl = gesture.slideEl;\n                    emit('zoomChange', value, imageEl, slideEl);\n                }\n                scale = value;\n            }\n        });\n        function getDistanceBetweenTouches() {\n            if (evCache.length < 2) return 1;\n            const x1 = evCache[0].pageX;\n            const y1 = evCache[0].pageY;\n            const x2 = evCache[1].pageX;\n            const y2 = evCache[1].pageY;\n            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n            return distance;\n        }\n        function getMaxRatio() {\n            const params = swiper.params.zoom;\n            const maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n            if (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {\n                const imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;\n                return Math.min(imageMaxRatio, maxRatio);\n            }\n            return maxRatio;\n        }\n        function getScaleOrigin() {\n            if (evCache.length < 2) return {\n                x: null,\n                y: null\n            };\n            const box = gesture.imageEl.getBoundingClientRect();\n            return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];\n        }\n        function getSlideSelector() {\n            return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n        }\n        function eventWithinSlide(e) {\n            const slideSelector = getSlideSelector();\n            if (e.target.matches(slideSelector)) return true;\n            if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;\n            return false;\n        }\n        function eventWithinZoomContainer(e) {\n            const selector = `.${swiper.params.zoom.containerClass}`;\n            if (e.target.matches(selector)) return true;\n            if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;\n            return false;\n        }\n\n        // Events\n        function onGestureStart(e) {\n            if (e.pointerType === 'mouse') {\n                evCache.splice(0, evCache.length);\n            }\n            if (!eventWithinSlide(e)) return;\n            const params = swiper.params.zoom;\n            fakeGestureTouched = false;\n            fakeGestureMoved = false;\n            evCache.push(e);\n            if (evCache.length < 2) {\n                return;\n            }\n            fakeGestureTouched = true;\n            gesture.scaleStart = getDistanceBetweenTouches();\n            if (!gesture.slideEl) {\n                gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n                if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) {\n                    imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n                }\n                gesture.imageEl = imageEl;\n                if (imageEl) {\n                    gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                } else {\n                    gesture.imageWrapEl = undefined;\n                }\n                if (!gesture.imageWrapEl) {\n                    gesture.imageEl = undefined;\n                    return;\n                }\n                gesture.maxRatio = getMaxRatio();\n            }\n            if (gesture.imageEl) {\n                const [originX, originY] = getScaleOrigin();\n                gesture.originX = originX;\n                gesture.originY = originY;\n                gesture.imageEl.style.transitionDuration = '0ms';\n            }\n            isScaling = true;\n        }\n        function onGestureChange(e) {\n            if (!eventWithinSlide(e)) return;\n            const params = swiper.params.zoom;\n            const zoom = swiper.zoom;\n            const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n            if (pointerIndex >= 0) evCache[pointerIndex] = e;\n            if (evCache.length < 2) {\n                return;\n            }\n            fakeGestureMoved = true;\n            gesture.scaleMove = getDistanceBetweenTouches();\n            if (!gesture.imageEl) {\n                return;\n            }\n            zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n            if (zoom.scale > gesture.maxRatio) {\n                zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n            }\n            if (zoom.scale < params.minRatio) {\n                zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n            }\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        }\n        function onGestureEnd(e) {\n            if (!eventWithinSlide(e)) return;\n            if (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n            const params = swiper.params.zoom;\n            const zoom = swiper.zoom;\n            const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n            if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n            if (!fakeGestureTouched || !fakeGestureMoved) {\n                return;\n            }\n            fakeGestureTouched = false;\n            fakeGestureMoved = false;\n            if (!gesture.imageEl) return;\n            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n            gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n            currentScale = zoom.scale;\n            isScaling = false;\n            if (zoom.scale > 1 && gesture.slideEl) {\n                gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n            } else if (zoom.scale <= 1 && gesture.slideEl) {\n                gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n            }\n            if (zoom.scale === 1) {\n                gesture.originX = 0;\n                gesture.originY = 0;\n                gesture.slideEl = undefined;\n            }\n        }\n        let allowTouchMoveTimeout;\n        function allowTouchMove() {\n            swiper.touchEventsData.preventTouchMoveFromPointerMove = false;\n        }\n        function preventTouchMove() {\n            clearTimeout(allowTouchMoveTimeout);\n            swiper.touchEventsData.preventTouchMoveFromPointerMove = true;\n            allowTouchMoveTimeout = setTimeout(() => {\n                allowTouchMove();\n            });\n        }\n        function onTouchStart(e) {\n            const device = swiper.device;\n            if (!gesture.imageEl) return;\n            if (image.isTouched) return;\n            if (device.android && e.cancelable) e.preventDefault();\n            image.isTouched = true;\n            const event = evCache.length > 0 ? evCache[0] : e;\n            image.touchesStart.x = event.pageX;\n            image.touchesStart.y = event.pageY;\n        }\n        function onTouchMove(e) {\n            if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) {\n                return;\n            }\n            const zoom = swiper.zoom;\n            if (!gesture.imageEl) {\n                return;\n            }\n            if (!image.isTouched || !gesture.slideEl) {\n                return;\n            }\n            if (!image.isMoved) {\n                image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;\n                image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;\n                image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n                image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n                gesture.slideWidth = gesture.slideEl.offsetWidth;\n                gesture.slideHeight = gesture.slideEl.offsetHeight;\n                gesture.imageWrapEl.style.transitionDuration = '0ms';\n            }\n            // Define if we need image drag\n            const scaledWidth = image.width * zoom.scale;\n            const scaledHeight = image.height * zoom.scale;\n            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n            image.maxX = -image.minX;\n            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n            image.maxY = -image.minY;\n            image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n            image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n            const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n            if (touchesDiff > 5) {\n                swiper.allowClick = false;\n            }\n            if (!image.isMoved && !isScaling) {\n                if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n                    image.isTouched = false;\n                    allowTouchMove();\n                    return;\n                }\n                if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n                    image.isTouched = false;\n                    allowTouchMove();\n                    return;\n                }\n            }\n            if (e.cancelable) {\n                e.preventDefault();\n            }\n            e.stopPropagation();\n            preventTouchMove();\n            image.isMoved = true;\n            const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n            const {\n                originX,\n                originY\n            } = gesture;\n            image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n            image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n            if (image.currentX < image.minX) {\n                image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n            }\n            if (image.currentX > image.maxX) {\n                image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n            }\n            if (image.currentY < image.minY) {\n                image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n            }\n            if (image.currentY > image.maxY) {\n                image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n            }\n\n            // Velocity\n            if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n            if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n            if (!velocity.prevTime) velocity.prevTime = Date.now();\n            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n            velocity.prevPositionX = image.touchesCurrent.x;\n            velocity.prevPositionY = image.touchesCurrent.y;\n            velocity.prevTime = Date.now();\n            gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n        }\n        function onTouchEnd() {\n            const zoom = swiper.zoom;\n            if (!gesture.imageEl) return;\n            if (!image.isTouched || !image.isMoved) {\n                image.isTouched = false;\n                image.isMoved = false;\n                return;\n            }\n            image.isTouched = false;\n            image.isMoved = false;\n            let momentumDurationX = 300;\n            let momentumDurationY = 300;\n            const momentumDistanceX = velocity.x * momentumDurationX;\n            const newPositionX = image.currentX + momentumDistanceX;\n            const momentumDistanceY = velocity.y * momentumDurationY;\n            const newPositionY = image.currentY + momentumDistanceY;\n\n            // Fix duration\n            if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n            if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n            const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n            image.currentX = newPositionX;\n            image.currentY = newPositionY;\n            // Define if we need image drag\n            const scaledWidth = image.width * zoom.scale;\n            const scaledHeight = image.height * zoom.scale;\n            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n            image.maxX = -image.minX;\n            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n            image.maxY = -image.minY;\n            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n            gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n            gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n        }\n        function onTransitionEnd() {\n            const zoom = swiper.zoom;\n            if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n                if (gesture.imageEl) {\n                    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n                }\n                if (gesture.imageWrapEl) {\n                    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n                }\n                gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n                zoom.scale = 1;\n                currentScale = 1;\n                gesture.slideEl = undefined;\n                gesture.imageEl = undefined;\n                gesture.imageWrapEl = undefined;\n                gesture.originX = 0;\n                gesture.originY = 0;\n            }\n        }\n        function zoomIn(e) {\n            const zoom = swiper.zoom;\n            const params = swiper.params.zoom;\n            if (!gesture.slideEl) {\n                if (e && e.target) {\n                    gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n                }\n                if (!gesture.slideEl) {\n                    if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n                        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n                    } else {\n                        gesture.slideEl = swiper.slides[swiper.activeIndex];\n                    }\n                }\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) {\n                    imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n                }\n                gesture.imageEl = imageEl;\n                if (imageEl) {\n                    gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                } else {\n                    gesture.imageWrapEl = undefined;\n                }\n            }\n            if (!gesture.imageEl || !gesture.imageWrapEl) return;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style.overflow = 'hidden';\n                swiper.wrapperEl.style.touchAction = 'none';\n            }\n            gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n            let touchX;\n            let touchY;\n            let offsetX;\n            let offsetY;\n            let diffX;\n            let diffY;\n            let translateX;\n            let translateY;\n            let imageWidth;\n            let imageHeight;\n            let scaledWidth;\n            let scaledHeight;\n            let translateMinX;\n            let translateMinY;\n            let translateMaxX;\n            let translateMaxY;\n            let slideWidth;\n            let slideHeight;\n            if (typeof image.touchesStart.x === 'undefined' && e) {\n                touchX = e.pageX;\n                touchY = e.pageY;\n            } else {\n                touchX = image.touchesStart.x;\n                touchY = image.touchesStart.y;\n            }\n            const forceZoomRatio = typeof e === 'number' ? e : null;\n            if (currentScale === 1 && forceZoomRatio) {\n                touchX = undefined;\n                touchY = undefined;\n            }\n            const maxRatio = getMaxRatio();\n            zoom.scale = forceZoomRatio || maxRatio;\n            currentScale = forceZoomRatio || maxRatio;\n            if (e && !(currentScale === 1 && forceZoomRatio)) {\n                slideWidth = gesture.slideEl.offsetWidth;\n                slideHeight = gesture.slideEl.offsetHeight;\n                offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n                offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n                diffX = offsetX + slideWidth / 2 - touchX;\n                diffY = offsetY + slideHeight / 2 - touchY;\n                imageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;\n                imageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;\n                scaledWidth = imageWidth * zoom.scale;\n                scaledHeight = imageHeight * zoom.scale;\n                translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n                translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n                translateMaxX = -translateMinX;\n                translateMaxY = -translateMinY;\n                translateX = diffX * zoom.scale;\n                translateY = diffY * zoom.scale;\n                if (translateX < translateMinX) {\n                    translateX = translateMinX;\n                }\n                if (translateX > translateMaxX) {\n                    translateX = translateMaxX;\n                }\n                if (translateY < translateMinY) {\n                    translateY = translateMinY;\n                }\n                if (translateY > translateMaxY) {\n                    translateY = translateMaxY;\n                }\n            } else {\n                translateX = 0;\n                translateY = 0;\n            }\n            if (forceZoomRatio && zoom.scale === 1) {\n                gesture.originX = 0;\n                gesture.originY = 0;\n            }\n            gesture.imageWrapEl.style.transitionDuration = '300ms';\n            gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n            gesture.imageEl.style.transitionDuration = '300ms';\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        }\n        function zoomOut() {\n            const zoom = swiper.zoom;\n            const params = swiper.params.zoom;\n            if (!gesture.slideEl) {\n                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n                    gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n                } else {\n                    gesture.slideEl = swiper.slides[swiper.activeIndex];\n                }\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) {\n                    imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n                }\n                gesture.imageEl = imageEl;\n                if (imageEl) {\n                    gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                } else {\n                    gesture.imageWrapEl = undefined;\n                }\n            }\n            if (!gesture.imageEl || !gesture.imageWrapEl) return;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style.overflow = '';\n                swiper.wrapperEl.style.touchAction = '';\n            }\n            zoom.scale = 1;\n            currentScale = 1;\n            gesture.imageWrapEl.style.transitionDuration = '300ms';\n            gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n            gesture.imageEl.style.transitionDuration = '300ms';\n            gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n            gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n            gesture.slideEl = undefined;\n            gesture.originX = 0;\n            gesture.originY = 0;\n        }\n\n        // Toggle Zoom\n        function zoomToggle(e) {\n            const zoom = swiper.zoom;\n            if (zoom.scale && zoom.scale !== 1) {\n                // Zoom Out\n                zoomOut();\n            } else {\n                // Zoom In\n                zoomIn(e);\n            }\n        }\n        function getListeners() {\n            const passiveListener = swiper.params.passiveListeners ? {\n                passive: true,\n                capture: false\n            } : false;\n            const activeListenerWithCapture = swiper.params.passiveListeners ? {\n                passive: false,\n                capture: true\n            } : true;\n            return {\n                passiveListener,\n                activeListenerWithCapture\n            };\n        }\n\n        // Attach/Detach Events\n        function enable() {\n            const zoom = swiper.zoom;\n            if (zoom.enabled) return;\n            zoom.enabled = true;\n            const {\n                passiveListener,\n                activeListenerWithCapture\n            } = getListeners();\n\n            // Scale image\n            swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n            swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n            ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n                swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n            });\n\n            // Move image\n            swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n        }\n        function disable() {\n            const zoom = swiper.zoom;\n            if (!zoom.enabled) return;\n            zoom.enabled = false;\n            const {\n                passiveListener,\n                activeListenerWithCapture\n            } = getListeners();\n\n            // Scale image\n            swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n            swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n            ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n                swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n            });\n\n            // Move image\n            swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n        }\n        on('init', () => {\n            if (swiper.params.zoom.enabled) {\n                enable();\n            }\n        });\n        on('destroy', () => {\n            disable();\n        });\n        on('touchStart', (_s, e) => {\n            if (!swiper.zoom.enabled) return;\n            onTouchStart(e);\n        });\n        on('touchEnd', (_s, e) => {\n            if (!swiper.zoom.enabled) return;\n            onTouchEnd();\n        });\n        on('doubleTap', (_s, e) => {\n            if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n                zoomToggle(e);\n            }\n        });\n        on('transitionEnd', () => {\n            if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n                onTransitionEnd();\n            }\n        });\n        on('slideChange', () => {\n            if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n                onTransitionEnd();\n            }\n        });\n        Object.assign(swiper.zoom, {\n            enable,\n            disable,\n            in: zoomIn,\n            out: zoomOut,\n            toggle: zoomToggle\n        });\n    }\n\n    /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n    function Controller(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            controller: {\n                control: undefined,\n                inverse: false,\n                by: 'slide' // or 'container'\n            }\n        });\n\n        swiper.controller = {\n            control: undefined\n        };\n        function LinearSpline(x, y) {\n            const binarySearch = function search() {\n                let maxIndex;\n                let minIndex;\n                let guess;\n                return (array, val) => {\n                    minIndex = -1;\n                    maxIndex = array.length;\n                    while (maxIndex - minIndex > 1) {\n                        guess = maxIndex + minIndex >> 1;\n                        if (array[guess] <= val) {\n                            minIndex = guess;\n                        } else {\n                            maxIndex = guess;\n                        }\n                    }\n                    return maxIndex;\n                };\n            }();\n            this.x = x;\n            this.y = y;\n            this.lastIndex = x.length - 1;\n            // Given an x value (x2), return the expected y2 value:\n            // (x1,y1) is the known point before given value,\n            // (x3,y3) is the known point after given value.\n            let i1;\n            let i3;\n            this.interpolate = function interpolate(x2) {\n                if (!x2) return 0;\n\n                // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n                i3 = binarySearch(this.x, x2);\n                i1 = i3 - 1;\n\n                // We have our indexes i1 & i3, so we can calculate already:\n                // y2 := ((x2?x1) ? (y3?y1)) ? (x3?x1) + y1\n                return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n            };\n            return this;\n        }\n        function getInterpolateFunction(c) {\n            swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n        }\n        function setTranslate(_t, byController) {\n            const controlled = swiper.controller.control;\n            let multiplier;\n            let controlledTranslate;\n            const Swiper = swiper.constructor;\n            function setControlledTranslate(c) {\n                if (c.destroyed) return;\n\n                // this will create an Interpolate function based on the snapGrids\n                // x is the Grid of the scrolled scroller and y will be the controlled scroller\n                // it makes sense to create this only once and recall it for the interpolation\n                // the function does a lot of value caching for performance\n                const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n                if (swiper.params.controller.by === 'slide') {\n                    getInterpolateFunction(c);\n                    // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n                    // but it did not work out\n                    controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n                }\n                if (!controlledTranslate || swiper.params.controller.by === 'container') {\n                    multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n                    if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n                        multiplier = 1;\n                    }\n                    controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n                }\n                if (swiper.params.controller.inverse) {\n                    controlledTranslate = c.maxTranslate() - controlledTranslate;\n                }\n                c.updateProgress(controlledTranslate);\n                c.setTranslate(controlledTranslate, swiper);\n                c.updateActiveIndex();\n                c.updateSlidesClasses();\n            }\n            if (Array.isArray(controlled)) {\n                for (let i = 0; i < controlled.length; i += 1) {\n                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n                        setControlledTranslate(controlled[i]);\n                    }\n                }\n            } else if (controlled instanceof Swiper && byController !== controlled) {\n                setControlledTranslate(controlled);\n            }\n        }\n        function setTransition(duration, byController) {\n            const Swiper = swiper.constructor;\n            const controlled = swiper.controller.control;\n            let i;\n            function setControlledTransition(c) {\n                if (c.destroyed) return;\n                c.setTransition(duration, swiper);\n                if (duration !== 0) {\n                    c.transitionStart();\n                    if (c.params.autoHeight) {\n                        nextTick(() => {\n                            c.updateAutoHeight();\n                        });\n                    }\n                    elementTransitionEnd(c.wrapperEl, () => {\n                        if (!controlled) return;\n                        c.transitionEnd();\n                    });\n                }\n            }\n            if (Array.isArray(controlled)) {\n                for (i = 0; i < controlled.length; i += 1) {\n                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n                        setControlledTransition(controlled[i]);\n                    }\n                }\n            } else if (controlled instanceof Swiper && byController !== controlled) {\n                setControlledTransition(controlled);\n            }\n        }\n        function removeSpline() {\n            if (!swiper.controller.control) return;\n            if (swiper.controller.spline) {\n                swiper.controller.spline = undefined;\n                delete swiper.controller.spline;\n            }\n        }\n        on('beforeInit', () => {\n            if (typeof window !== 'undefined' && (\n                // eslint-disable-line\n                typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {\n                const controlElement = document.querySelector(swiper.params.controller.control);\n                if (controlElement && controlElement.swiper) {\n                    swiper.controller.control = controlElement.swiper;\n                } else if (controlElement) {\n                    const onControllerSwiper = e => {\n                        swiper.controller.control = e.detail[0];\n                        swiper.update();\n                        controlElement.removeEventListener('init', onControllerSwiper);\n                    };\n                    controlElement.addEventListener('init', onControllerSwiper);\n                }\n                return;\n            }\n            swiper.controller.control = swiper.params.controller.control;\n        });\n        on('update', () => {\n            removeSpline();\n        });\n        on('resize', () => {\n            removeSpline();\n        });\n        on('observerUpdate', () => {\n            removeSpline();\n        });\n        on('setTranslate', (_s, translate, byController) => {\n            if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n            swiper.controller.setTranslate(translate, byController);\n        });\n        on('setTransition', (_s, duration, byController) => {\n            if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n            swiper.controller.setTransition(duration, byController);\n        });\n        Object.assign(swiper.controller, {\n            setTranslate,\n            setTransition\n        });\n    }\n\n    function A11y(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            a11y: {\n                enabled: true,\n                notificationClass: 'swiper-notification',\n                prevSlideMessage: BX.message('SWIPER_PREV_SLIDE_MESSAGE'),\n                nextSlideMessage: BX.message('SWIPER_NEXT_SLIDE_MESSAGE'),\n                firstSlideMessage: BX.message('SWIPER_FIRST_SLIDE_MESSAGE'),\n                lastSlideMessage: BX.message('SWIPER_LAST_SLIDE_MESSAGE'),\n                paginationBulletMessage: BX.message('SWIPER_PAGINATION_BULLET_MESSAGE'),\n                slideLabelMessage: '{{index}} / {{slidesLength}}',\n                containerMessage: null,\n                containerRoleDescriptionMessage: null,\n                itemRoleDescriptionMessage: null,\n                slideRole: 'group',\n                id: null\n            }\n        });\n        swiper.a11y = {\n            clicked: false\n        };\n        let liveRegion = null;\n        let preventFocusHandler;\n        let focusTargetSlideEl;\n        let visibilityChangedTimestamp = new Date().getTime();\n        function notify(message) {\n            const notification = liveRegion;\n            if (notification.length === 0) return;\n            notification.innerHTML = '';\n            notification.innerHTML = message;\n        }\n        function getRandomNumber(size) {\n            if (size === void 0) {\n                size = 16;\n            }\n            const randomChar = () => Math.round(16 * Math.random()).toString(16);\n            return 'x'.repeat(size).replace(/x/g, randomChar);\n        }\n        function makeElFocusable(el) {\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.setAttribute('tabIndex', '0');\n            });\n        }\n        function makeElNotFocusable(el) {\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.setAttribute('tabIndex', '-1');\n            });\n        }\n        function addElRole(el, role) {\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.setAttribute('role', role);\n            });\n        }\n        function addElRoleDescription(el, description) {\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.setAttribute('aria-roledescription', description);\n            });\n        }\n        function addElControls(el, controls) {\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.setAttribute('aria-controls', controls);\n            });\n        }\n        function addElLabel(el, label) {\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.setAttribute('aria-label', label);\n            });\n        }\n        function addElId(el, id) {\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.setAttribute('id', id);\n            });\n        }\n        function addElLive(el, live) {\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.setAttribute('aria-live', live);\n            });\n        }\n        function disableEl(el) {\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.setAttribute('aria-disabled', true);\n            });\n        }\n        function enableEl(el) {\n            el = makeElementsArray(el);\n            el.forEach(subEl => {\n                subEl.setAttribute('aria-disabled', false);\n            });\n        }\n        function onEnterOrSpaceKey(e) {\n            if (e.keyCode !== 13 && e.keyCode !== 32) return;\n            const params = swiper.params.a11y;\n            const targetEl = e.target;\n            if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n                if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n            }\n            if (swiper.navigation && swiper.navigation.prevEl && swiper.navigation.nextEl) {\n                const prevEls = makeElementsArray(swiper.navigation.prevEl);\n                const nextEls = makeElementsArray(swiper.navigation.nextEl);\n                if (nextEls.includes(targetEl)) {\n                    if (!(swiper.isEnd && !swiper.params.loop)) {\n                        swiper.slideNext();\n                    }\n                    if (swiper.isEnd) {\n                        notify(params.lastSlideMessage);\n                    } else {\n                        notify(params.nextSlideMessage);\n                    }\n                }\n                if (prevEls.includes(targetEl)) {\n                    if (!(swiper.isBeginning && !swiper.params.loop)) {\n                        swiper.slidePrev();\n                    }\n                    if (swiper.isBeginning) {\n                        notify(params.firstSlideMessage);\n                    } else {\n                        notify(params.prevSlideMessage);\n                    }\n                }\n            }\n            if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {\n                targetEl.click();\n            }\n        }\n        function updateNavigation() {\n            if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n            const {\n                nextEl,\n                prevEl\n            } = swiper.navigation;\n            if (prevEl) {\n                if (swiper.isBeginning) {\n                    disableEl(prevEl);\n                    makeElNotFocusable(prevEl);\n                } else {\n                    enableEl(prevEl);\n                    makeElFocusable(prevEl);\n                }\n            }\n            if (nextEl) {\n                if (swiper.isEnd) {\n                    disableEl(nextEl);\n                    makeElNotFocusable(nextEl);\n                } else {\n                    enableEl(nextEl);\n                    makeElFocusable(nextEl);\n                }\n            }\n        }\n        function hasPagination() {\n            return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n        }\n        function hasClickablePagination() {\n            return hasPagination() && swiper.params.pagination.clickable;\n        }\n        function updatePagination() {\n            const params = swiper.params.a11y;\n            if (!hasPagination()) return;\n            swiper.pagination.bullets.forEach(bulletEl => {\n                if (swiper.params.pagination.clickable) {\n                    makeElFocusable(bulletEl);\n                    if (!swiper.params.pagination.renderBullet) {\n                        addElRole(bulletEl, 'button');\n                        addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n                    }\n                }\n                if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n                    bulletEl.setAttribute('aria-current', 'true');\n                } else {\n                    bulletEl.removeAttribute('aria-current');\n                }\n            });\n        }\n        const initNavEl = (el, wrapperId, message) => {\n            makeElFocusable(el);\n            if (el.tagName !== 'BUTTON') {\n                addElRole(el, 'button');\n                el.addEventListener('keydown', onEnterOrSpaceKey);\n            }\n            addElLabel(el, message);\n            addElControls(el, wrapperId);\n        };\n        const handlePointerDown = e => {\n            if (focusTargetSlideEl && focusTargetSlideEl !== e.target && !focusTargetSlideEl.contains(e.target)) {\n                preventFocusHandler = true;\n            }\n            swiper.a11y.clicked = true;\n        };\n        const handlePointerUp = () => {\n            preventFocusHandler = false;\n            requestAnimationFrame(() => {\n                requestAnimationFrame(() => {\n                    if (!swiper.destroyed) {\n                        swiper.a11y.clicked = false;\n                    }\n                });\n            });\n        };\n        const onVisibilityChange = e => {\n            visibilityChangedTimestamp = new Date().getTime();\n        };\n        const handleFocus = e => {\n            if (swiper.a11y.clicked) return;\n            if (new Date().getTime() - visibilityChangedTimestamp < 100) return;\n            const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n            if (!slideEl || !swiper.slides.includes(slideEl)) return;\n            focusTargetSlideEl = slideEl;\n            const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n            const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n            if (isActive || isVisible) return;\n            if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n            if (swiper.isHorizontal()) {\n                swiper.el.scrollLeft = 0;\n            } else {\n                swiper.el.scrollTop = 0;\n            }\n            requestAnimationFrame(() => {\n                if (preventFocusHandler) return;\n                if (swiper.params.loop) {\n                    swiper.slideToLoop(parseInt(slideEl.getAttribute('data-swiper-slide-index')), 0);\n                } else {\n                    swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n                }\n                preventFocusHandler = false;\n            });\n        };\n        const initSlides = () => {\n            const params = swiper.params.a11y;\n            if (params.itemRoleDescriptionMessage) {\n                addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n            }\n            if (params.slideRole) {\n                addElRole(swiper.slides, params.slideRole);\n            }\n            const slidesLength = swiper.slides.length;\n            if (params.slideLabelMessage) {\n                swiper.slides.forEach((slideEl, index) => {\n                    const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;\n                    const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n                    addElLabel(slideEl, ariaLabelMessage);\n                });\n            }\n        };\n        const init = () => {\n            const params = swiper.params.a11y;\n            swiper.el.append(liveRegion);\n\n            // Container\n            const containerEl = swiper.el;\n            if (params.containerRoleDescriptionMessage) {\n                addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n            }\n            if (params.containerMessage) {\n                addElLabel(containerEl, params.containerMessage);\n            }\n\n            // Wrapper\n            const wrapperEl = swiper.wrapperEl;\n            const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n            const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n            addElId(wrapperEl, wrapperId);\n            addElLive(wrapperEl, live);\n\n            // Slide\n            initSlides();\n\n            // Navigation\n            let {\n                nextEl,\n                prevEl\n            } = swiper.navigation ? swiper.navigation : {};\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            if (nextEl) {\n                nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));\n            }\n            if (prevEl) {\n                prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));\n            }\n\n            // Pagination\n            if (hasClickablePagination()) {\n                const paginationEl = makeElementsArray(swiper.pagination.el);\n                paginationEl.forEach(el => {\n                    el.addEventListener('keydown', onEnterOrSpaceKey);\n                });\n            }\n\n            // Tab focus\n            const document = getDocument();\n            document.addEventListener('visibilitychange', onVisibilityChange);\n            swiper.el.addEventListener('focus', handleFocus, true);\n            swiper.el.addEventListener('focus', handleFocus, true);\n            swiper.el.addEventListener('pointerdown', handlePointerDown, true);\n            swiper.el.addEventListener('pointerup', handlePointerUp, true);\n        };\n        function destroy() {\n            if (liveRegion) liveRegion.remove();\n            let {\n                nextEl,\n                prevEl\n            } = swiper.navigation ? swiper.navigation : {};\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            if (nextEl) {\n                nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n            }\n            if (prevEl) {\n                prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n            }\n\n            // Pagination\n            if (hasClickablePagination()) {\n                const paginationEl = makeElementsArray(swiper.pagination.el);\n                paginationEl.forEach(el => {\n                    el.removeEventListener('keydown', onEnterOrSpaceKey);\n                });\n            }\n            const document = getDocument();\n            document.removeEventListener('visibilitychange', onVisibilityChange);\n            // Tab focus\n            if (swiper.el && typeof swiper.el !== 'string') {\n                swiper.el.removeEventListener('focus', handleFocus, true);\n                swiper.el.removeEventListener('pointerdown', handlePointerDown, true);\n                swiper.el.removeEventListener('pointerup', handlePointerUp, true);\n            }\n        }\n        on('beforeInit', () => {\n            liveRegion = createElement('span', swiper.params.a11y.notificationClass);\n            liveRegion.setAttribute('aria-live', 'assertive');\n            liveRegion.setAttribute('aria-atomic', 'true');\n        });\n        on('afterInit', () => {\n            if (!swiper.params.a11y.enabled) return;\n            init();\n        });\n        on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n            if (!swiper.params.a11y.enabled) return;\n            initSlides();\n        });\n        on('fromEdge toEdge afterInit lock unlock', () => {\n            if (!swiper.params.a11y.enabled) return;\n            updateNavigation();\n        });\n        on('paginationUpdate', () => {\n            if (!swiper.params.a11y.enabled) return;\n            updatePagination();\n        });\n        on('destroy', () => {\n            if (!swiper.params.a11y.enabled) return;\n            destroy();\n        });\n    }\n\n    function History(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            history: {\n                enabled: false,\n                root: '',\n                replaceState: false,\n                key: 'slides',\n                keepQuery: false\n            }\n        });\n        let initialized = false;\n        let paths = {};\n        const slugify = text => {\n            return text.toString().replace(/\\s+/g, '-').replace(/[^\\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');\n        };\n        const getPathValues = urlOverride => {\n            const window = getWindow();\n            let location;\n            if (urlOverride) {\n                location = new URL(urlOverride);\n            } else {\n                location = window.location;\n            }\n            const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');\n            const total = pathArray.length;\n            const key = pathArray[total - 2];\n            const value = pathArray[total - 1];\n            return {\n                key,\n                value\n            };\n        };\n        const setHistory = (key, index) => {\n            const window = getWindow();\n            if (!initialized || !swiper.params.history.enabled) return;\n            let location;\n            if (swiper.params.url) {\n                location = new URL(swiper.params.url);\n            } else {\n                location = window.location;\n            }\n            const slide = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${index}\"]`) : swiper.slides[index];\n            let value = slugify(slide.getAttribute('data-history'));\n            if (swiper.params.history.root.length > 0) {\n                let root = swiper.params.history.root;\n                if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n                value = `${root}/${key ? `${key}/` : ''}${value}`;\n            } else if (!location.pathname.includes(key)) {\n                value = `${key ? `${key}/` : ''}${value}`;\n            }\n            if (swiper.params.history.keepQuery) {\n                value += location.search;\n            }\n            const currentState = window.history.state;\n            if (currentState && currentState.value === value) {\n                return;\n            }\n            if (swiper.params.history.replaceState) {\n                window.history.replaceState({\n                    value\n                }, null, value);\n            } else {\n                window.history.pushState({\n                    value\n                }, null, value);\n            }\n        };\n        const scrollToSlide = (speed, value, runCallbacks) => {\n            if (value) {\n                for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n                    const slide = swiper.slides[i];\n                    const slideHistory = slugify(slide.getAttribute('data-history'));\n                    if (slideHistory === value) {\n                        const index = swiper.getSlideIndex(slide);\n                        swiper.slideTo(index, speed, runCallbacks);\n                    }\n                }\n            } else {\n                swiper.slideTo(0, speed, runCallbacks);\n            }\n        };\n        const setHistoryPopState = () => {\n            paths = getPathValues(swiper.params.url);\n            scrollToSlide(swiper.params.speed, paths.value, false);\n        };\n        const init = () => {\n            const window = getWindow();\n            if (!swiper.params.history) return;\n            if (!window.history || !window.history.pushState) {\n                swiper.params.history.enabled = false;\n                swiper.params.hashNavigation.enabled = true;\n                return;\n            }\n            initialized = true;\n            paths = getPathValues(swiper.params.url);\n            if (!paths.key && !paths.value) {\n                if (!swiper.params.history.replaceState) {\n                    window.addEventListener('popstate', setHistoryPopState);\n                }\n                return;\n            }\n            scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n            if (!swiper.params.history.replaceState) {\n                window.addEventListener('popstate', setHistoryPopState);\n            }\n        };\n        const destroy = () => {\n            const window = getWindow();\n            if (!swiper.params.history.replaceState) {\n                window.removeEventListener('popstate', setHistoryPopState);\n            }\n        };\n        on('init', () => {\n            if (swiper.params.history.enabled) {\n                init();\n            }\n        });\n        on('destroy', () => {\n            if (swiper.params.history.enabled) {\n                destroy();\n            }\n        });\n        on('transitionEnd _freeModeNoMomentumRelease', () => {\n            if (initialized) {\n                setHistory(swiper.params.history.key, swiper.activeIndex);\n            }\n        });\n        on('slideChange', () => {\n            if (initialized && swiper.params.cssMode) {\n                setHistory(swiper.params.history.key, swiper.activeIndex);\n            }\n        });\n    }\n\n    function HashNavigation(_ref) {\n        let {\n            swiper,\n            extendParams,\n            emit,\n            on\n        } = _ref;\n        let initialized = false;\n        const document = getDocument();\n        const window = getWindow();\n        extendParams({\n            hashNavigation: {\n                enabled: false,\n                replaceState: false,\n                watchState: false,\n                getSlideIndex(_s, hash) {\n                    if (swiper.virtual && swiper.params.virtual.enabled) {\n                        const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];\n                        if (!slideWithHash) return 0;\n                        const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);\n                        return index;\n                    }\n                    return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n                }\n            }\n        });\n        const onHashChange = () => {\n            emit('hashChange');\n            const newHash = document.location.hash.replace('#', '');\n            const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n            const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';\n            if (newHash !== activeSlideHash) {\n                const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n                if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;\n                swiper.slideTo(newIndex);\n            }\n        };\n        const setHash = () => {\n            if (!initialized || !swiper.params.hashNavigation.enabled) return;\n            const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n            const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';\n            if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n                window.history.replaceState(null, null, `#${activeSlideHash}` || '');\n                emit('hashSet');\n            } else {\n                document.location.hash = activeSlideHash || '';\n                emit('hashSet');\n            }\n        };\n        const init = () => {\n            if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n            initialized = true;\n            const hash = document.location.hash.replace('#', '');\n            if (hash) {\n                const speed = 0;\n                const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n                swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n            }\n            if (swiper.params.hashNavigation.watchState) {\n                window.addEventListener('hashchange', onHashChange);\n            }\n        };\n        const destroy = () => {\n            if (swiper.params.hashNavigation.watchState) {\n                window.removeEventListener('hashchange', onHashChange);\n            }\n        };\n        on('init', () => {\n            if (swiper.params.hashNavigation.enabled) {\n                init();\n            }\n        });\n        on('destroy', () => {\n            if (swiper.params.hashNavigation.enabled) {\n                destroy();\n            }\n        });\n        on('transitionEnd _freeModeNoMomentumRelease', () => {\n            if (initialized) {\n                setHash();\n            }\n        });\n        on('slideChange', () => {\n            if (initialized && swiper.params.cssMode) {\n                setHash();\n            }\n        });\n    }\n\n    /* eslint no-underscore-dangle: \"off\" */\n    /* eslint no-use-before-define: \"off\" */\n    function Autoplay(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on,\n            emit,\n            params\n        } = _ref;\n        swiper.autoplay = {\n            running: false,\n            paused: false,\n            timeLeft: 0\n        };\n        extendParams({\n            autoplay: {\n                enabled: false,\n                delay: 3000,\n                waitForTransition: true,\n                disableOnInteraction: false,\n                stopOnLastSlide: false,\n                reverseDirection: false,\n                pauseOnMouseEnter: false\n            }\n        });\n        let timeout;\n        let raf;\n        let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n        let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n        let autoplayTimeLeft;\n        let autoplayStartTime = new Date().getTime();\n        let wasPaused;\n        let isTouched;\n        let pausedByTouch;\n        let touchStartTimeout;\n        let slideChanged;\n        let pausedByInteraction;\n        let pausedByPointerEnter;\n        function onTransitionEnd(e) {\n            if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n            if (e.target !== swiper.wrapperEl) return;\n            swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n            if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) {\n                return;\n            }\n            resume();\n        }\n        const calcTimeLeft = () => {\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (swiper.autoplay.paused) {\n                wasPaused = true;\n            } else if (wasPaused) {\n                autoplayDelayCurrent = autoplayTimeLeft;\n                wasPaused = false;\n            }\n            const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n            swiper.autoplay.timeLeft = timeLeft;\n            emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n            raf = requestAnimationFrame(() => {\n                calcTimeLeft();\n            });\n        };\n        const getSlideDelay = () => {\n            let activeSlideEl;\n            if (swiper.virtual && swiper.params.virtual.enabled) {\n                activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];\n            } else {\n                activeSlideEl = swiper.slides[swiper.activeIndex];\n            }\n            if (!activeSlideEl) return undefined;\n            const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n            return currentSlideDelay;\n        };\n        const run = delayForce => {\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            cancelAnimationFrame(raf);\n            calcTimeLeft();\n            let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n            autoplayDelayTotal = swiper.params.autoplay.delay;\n            autoplayDelayCurrent = swiper.params.autoplay.delay;\n            const currentSlideDelay = getSlideDelay();\n            if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {\n                delay = currentSlideDelay;\n                autoplayDelayTotal = currentSlideDelay;\n                autoplayDelayCurrent = currentSlideDelay;\n            }\n            autoplayTimeLeft = delay;\n            const speed = swiper.params.speed;\n            const proceed = () => {\n                if (!swiper || swiper.destroyed) return;\n                if (swiper.params.autoplay.reverseDirection) {\n                    if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n                        swiper.slidePrev(speed, true, true);\n                        emit('autoplay');\n                    } else if (!swiper.params.autoplay.stopOnLastSlide) {\n                        swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n                        emit('autoplay');\n                    }\n                } else {\n                    if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n                        swiper.slideNext(speed, true, true);\n                        emit('autoplay');\n                    } else if (!swiper.params.autoplay.stopOnLastSlide) {\n                        swiper.slideTo(0, speed, true, true);\n                        emit('autoplay');\n                    }\n                }\n                if (swiper.params.cssMode) {\n                    autoplayStartTime = new Date().getTime();\n                    requestAnimationFrame(() => {\n                        run();\n                    });\n                }\n            };\n            if (delay > 0) {\n                clearTimeout(timeout);\n                timeout = setTimeout(() => {\n                    proceed();\n                }, delay);\n            } else {\n                requestAnimationFrame(() => {\n                    proceed();\n                });\n            }\n\n            // eslint-disable-next-line\n            return delay;\n        };\n        const start = () => {\n            autoplayStartTime = new Date().getTime();\n            swiper.autoplay.running = true;\n            run();\n            emit('autoplayStart');\n        };\n        const stop = () => {\n            swiper.autoplay.running = false;\n            clearTimeout(timeout);\n            cancelAnimationFrame(raf);\n            emit('autoplayStop');\n        };\n        const pause = (internal, reset) => {\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            clearTimeout(timeout);\n            if (!internal) {\n                pausedByInteraction = true;\n            }\n            const proceed = () => {\n                emit('autoplayPause');\n                if (swiper.params.autoplay.waitForTransition) {\n                    swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n                } else {\n                    resume();\n                }\n            };\n            swiper.autoplay.paused = true;\n            if (reset) {\n                if (slideChanged) {\n                    autoplayTimeLeft = swiper.params.autoplay.delay;\n                }\n                slideChanged = false;\n                proceed();\n                return;\n            }\n            const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n            autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n            if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n            if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n            proceed();\n        };\n        const resume = () => {\n            if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n            autoplayStartTime = new Date().getTime();\n            if (pausedByInteraction) {\n                pausedByInteraction = false;\n                run(autoplayTimeLeft);\n            } else {\n                run();\n            }\n            swiper.autoplay.paused = false;\n            emit('autoplayResume');\n        };\n        const onVisibilityChange = () => {\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            const document = getDocument();\n            if (document.visibilityState === 'hidden') {\n                pausedByInteraction = true;\n                pause(true);\n            }\n            if (document.visibilityState === 'visible') {\n                resume();\n            }\n        };\n        const onPointerEnter = e => {\n            if (e.pointerType !== 'mouse') return;\n            pausedByInteraction = true;\n            pausedByPointerEnter = true;\n            if (swiper.animating || swiper.autoplay.paused) return;\n            pause(true);\n        };\n        const onPointerLeave = e => {\n            if (e.pointerType !== 'mouse') return;\n            pausedByPointerEnter = false;\n            if (swiper.autoplay.paused) {\n                resume();\n            }\n        };\n        const attachMouseEvents = () => {\n            if (swiper.params.autoplay.pauseOnMouseEnter) {\n                swiper.el.addEventListener('pointerenter', onPointerEnter);\n                swiper.el.addEventListener('pointerleave', onPointerLeave);\n            }\n        };\n        const detachMouseEvents = () => {\n            if (swiper.el && typeof swiper.el !== 'string') {\n                swiper.el.removeEventListener('pointerenter', onPointerEnter);\n                swiper.el.removeEventListener('pointerleave', onPointerLeave);\n            }\n        };\n        const attachDocumentEvents = () => {\n            const document = getDocument();\n            document.addEventListener('visibilitychange', onVisibilityChange);\n        };\n        const detachDocumentEvents = () => {\n            const document = getDocument();\n            document.removeEventListener('visibilitychange', onVisibilityChange);\n        };\n        on('init', () => {\n            if (swiper.params.autoplay.enabled) {\n                attachMouseEvents();\n                attachDocumentEvents();\n                start();\n            }\n        });\n        on('destroy', () => {\n            detachMouseEvents();\n            detachDocumentEvents();\n            if (swiper.autoplay.running) {\n                stop();\n            }\n        });\n        on('_freeModeStaticRelease', () => {\n            if (pausedByTouch || pausedByInteraction) {\n                resume();\n            }\n        });\n        on('_freeModeNoMomentumRelease', () => {\n            if (!swiper.params.autoplay.disableOnInteraction) {\n                pause(true, true);\n            } else {\n                stop();\n            }\n        });\n        on('beforeTransitionStart', (_s, speed, internal) => {\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (internal || !swiper.params.autoplay.disableOnInteraction) {\n                pause(true, true);\n            } else {\n                stop();\n            }\n        });\n        on('sliderFirstMove', () => {\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (swiper.params.autoplay.disableOnInteraction) {\n                stop();\n                return;\n            }\n            isTouched = true;\n            pausedByTouch = false;\n            pausedByInteraction = false;\n            touchStartTimeout = setTimeout(() => {\n                pausedByInteraction = true;\n                pausedByTouch = true;\n                pause(true);\n            }, 200);\n        });\n        on('touchEnd', () => {\n            if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n            clearTimeout(touchStartTimeout);\n            clearTimeout(timeout);\n            if (swiper.params.autoplay.disableOnInteraction) {\n                pausedByTouch = false;\n                isTouched = false;\n                return;\n            }\n            if (pausedByTouch && swiper.params.cssMode) resume();\n            pausedByTouch = false;\n            isTouched = false;\n        });\n        on('slideChange', () => {\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            slideChanged = true;\n        });\n        Object.assign(swiper.autoplay, {\n            start,\n            stop,\n            pause,\n            resume\n        });\n    }\n\n    function Thumb(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            thumbs: {\n                swiper: null,\n                multipleActiveThumbs: true,\n                autoScrollOffset: 0,\n                slideThumbActiveClass: 'swiper-slide-thumb-active',\n                thumbsContainerClass: 'swiper-thumbs'\n            }\n        });\n        let initialized = false;\n        let swiperCreated = false;\n        swiper.thumbs = {\n            swiper: null\n        };\n        function onThumbClick() {\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            const clickedIndex = thumbsSwiper.clickedIndex;\n            const clickedSlide = thumbsSwiper.clickedSlide;\n            if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n            if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n            let slideToIndex;\n            if (thumbsSwiper.params.loop) {\n                slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n            } else {\n                slideToIndex = clickedIndex;\n            }\n            if (swiper.params.loop) {\n                swiper.slideToLoop(slideToIndex);\n            } else {\n                swiper.slideTo(slideToIndex);\n            }\n        }\n        function init() {\n            const {\n                thumbs: thumbsParams\n            } = swiper.params;\n            if (initialized) return false;\n            initialized = true;\n            const SwiperClass = swiper.constructor;\n            if (thumbsParams.swiper instanceof SwiperClass) {\n                swiper.thumbs.swiper = thumbsParams.swiper;\n                Object.assign(swiper.thumbs.swiper.originalParams, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                Object.assign(swiper.thumbs.swiper.params, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                swiper.thumbs.swiper.update();\n            } else if (isObject(thumbsParams.swiper)) {\n                const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n                Object.assign(thumbsSwiperParams, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n                swiperCreated = true;\n            }\n            swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n            swiper.thumbs.swiper.on('tap', onThumbClick);\n            return true;\n        }\n        function update(initial) {\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n\n            // Activate thumbs\n            let thumbsToActivate = 1;\n            const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n            if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n                thumbsToActivate = swiper.params.slidesPerView;\n            }\n            if (!swiper.params.thumbs.multipleActiveThumbs) {\n                thumbsToActivate = 1;\n            }\n            thumbsToActivate = Math.floor(thumbsToActivate);\n            thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));\n            if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\n                for (let i = 0; i < thumbsToActivate; i += 1) {\n                    elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach(slideEl => {\n                        slideEl.classList.add(thumbActiveClass);\n                    });\n                }\n            } else {\n                for (let i = 0; i < thumbsToActivate; i += 1) {\n                    if (thumbsSwiper.slides[swiper.realIndex + i]) {\n                        thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n                    }\n                }\n            }\n            const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n            const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n            if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n                const currentThumbsIndex = thumbsSwiper.activeIndex;\n                let newThumbsIndex;\n                let direction;\n                if (thumbsSwiper.params.loop) {\n                    const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];\n                    newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n                    direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n                } else {\n                    newThumbsIndex = swiper.realIndex;\n                    direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n                }\n                if (useOffset) {\n                    newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n                }\n                if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n                    if (thumbsSwiper.params.centeredSlides) {\n                        if (newThumbsIndex > currentThumbsIndex) {\n                            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n                        } else {\n                            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n                        }\n                    } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;\n                    thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n                }\n            }\n        }\n        on('beforeInit', () => {\n            const {\n                thumbs\n            } = swiper.params;\n            if (!thumbs || !thumbs.swiper) return;\n            if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {\n                const document = getDocument();\n                const getThumbsElementAndInit = () => {\n                    const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;\n                    if (thumbsElement && thumbsElement.swiper) {\n                        thumbs.swiper = thumbsElement.swiper;\n                        init();\n                        update(true);\n                    } else if (thumbsElement) {\n                        const onThumbsSwiper = e => {\n                            thumbs.swiper = e.detail[0];\n                            thumbsElement.removeEventListener('init', onThumbsSwiper);\n                            init();\n                            update(true);\n                            thumbs.swiper.update();\n                            swiper.update();\n                        };\n                        thumbsElement.addEventListener('init', onThumbsSwiper);\n                    }\n                    return thumbsElement;\n                };\n                const watchForThumbsToAppear = () => {\n                    if (swiper.destroyed) return;\n                    const thumbsElement = getThumbsElementAndInit();\n                    if (!thumbsElement) {\n                        requestAnimationFrame(watchForThumbsToAppear);\n                    }\n                };\n                requestAnimationFrame(watchForThumbsToAppear);\n            } else {\n                init();\n                update(true);\n            }\n        });\n        on('slideChange update resize observerUpdate', () => {\n            update();\n        });\n        on('setTransition', (_s, duration) => {\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            thumbsSwiper.setTransition(duration);\n        });\n        on('beforeDestroy', () => {\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            if (swiperCreated) {\n                thumbsSwiper.destroy();\n            }\n        });\n        Object.assign(swiper.thumbs, {\n            init,\n            update\n        });\n    }\n\n    function freeMode(_ref) {\n        let {\n            swiper,\n            extendParams,\n            emit,\n            once\n        } = _ref;\n        extendParams({\n            freeMode: {\n                enabled: false,\n                momentum: true,\n                momentumRatio: 1,\n                momentumBounce: true,\n                momentumBounceRatio: 1,\n                momentumVelocityRatio: 1,\n                sticky: false,\n                minimumVelocity: 0.02\n            }\n        });\n        function onTouchStart() {\n            if (swiper.params.cssMode) return;\n            const translate = swiper.getTranslate();\n            swiper.setTranslate(translate);\n            swiper.setTransition(0);\n            swiper.touchEventsData.velocities.length = 0;\n            swiper.freeMode.onTouchEnd({\n                currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n            });\n        }\n        function onTouchMove() {\n            if (swiper.params.cssMode) return;\n            const {\n                touchEventsData: data,\n                touches\n            } = swiper;\n            // Velocity\n            if (data.velocities.length === 0) {\n                data.velocities.push({\n                    position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n                    time: data.touchStartTime\n                });\n            }\n            data.velocities.push({\n                position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n                time: now()\n            });\n        }\n        function onTouchEnd(_ref2) {\n            let {\n                currentPos\n            } = _ref2;\n            if (swiper.params.cssMode) return;\n            const {\n                params,\n                wrapperEl,\n                rtlTranslate: rtl,\n                snapGrid,\n                touchEventsData: data\n            } = swiper;\n            // Time diff\n            const touchEndTime = now();\n            const timeDiff = touchEndTime - data.touchStartTime;\n            if (currentPos < -swiper.minTranslate()) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            if (currentPos > -swiper.maxTranslate()) {\n                if (swiper.slides.length < snapGrid.length) {\n                    swiper.slideTo(snapGrid.length - 1);\n                } else {\n                    swiper.slideTo(swiper.slides.length - 1);\n                }\n                return;\n            }\n            if (params.freeMode.momentum) {\n                if (data.velocities.length > 1) {\n                    const lastMoveEvent = data.velocities.pop();\n                    const velocityEvent = data.velocities.pop();\n                    const distance = lastMoveEvent.position - velocityEvent.position;\n                    const time = lastMoveEvent.time - velocityEvent.time;\n                    swiper.velocity = distance / time;\n                    swiper.velocity /= 2;\n                    if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n                        swiper.velocity = 0;\n                    }\n                    // this implies that the user stopped moving a finger then released.\n                    // There would be no events with distance zero, so the last event is stale.\n                    if (time > 150 || now() - lastMoveEvent.time > 300) {\n                        swiper.velocity = 0;\n                    }\n                } else {\n                    swiper.velocity = 0;\n                }\n                swiper.velocity *= params.freeMode.momentumVelocityRatio;\n                data.velocities.length = 0;\n                let momentumDuration = 1000 * params.freeMode.momentumRatio;\n                const momentumDistance = swiper.velocity * momentumDuration;\n                let newPosition = swiper.translate + momentumDistance;\n                if (rtl) newPosition = -newPosition;\n                let doBounce = false;\n                let afterBouncePosition;\n                const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n                let needsLoopFix;\n                if (newPosition < swiper.maxTranslate()) {\n                    if (params.freeMode.momentumBounce) {\n                        if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n                            newPosition = swiper.maxTranslate() - bounceAmount;\n                        }\n                        afterBouncePosition = swiper.maxTranslate();\n                        doBounce = true;\n                        data.allowMomentumBounce = true;\n                    } else {\n                        newPosition = swiper.maxTranslate();\n                    }\n                    if (params.loop && params.centeredSlides) needsLoopFix = true;\n                } else if (newPosition > swiper.minTranslate()) {\n                    if (params.freeMode.momentumBounce) {\n                        if (newPosition - swiper.minTranslate() > bounceAmount) {\n                            newPosition = swiper.minTranslate() + bounceAmount;\n                        }\n                        afterBouncePosition = swiper.minTranslate();\n                        doBounce = true;\n                        data.allowMomentumBounce = true;\n                    } else {\n                        newPosition = swiper.minTranslate();\n                    }\n                    if (params.loop && params.centeredSlides) needsLoopFix = true;\n                } else if (params.freeMode.sticky) {\n                    let nextSlide;\n                    for (let j = 0; j < snapGrid.length; j += 1) {\n                        if (snapGrid[j] > -newPosition) {\n                            nextSlide = j;\n                            break;\n                        }\n                    }\n                    if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n                        newPosition = snapGrid[nextSlide];\n                    } else {\n                        newPosition = snapGrid[nextSlide - 1];\n                    }\n                    newPosition = -newPosition;\n                }\n                if (needsLoopFix) {\n                    once('transitionEnd', () => {\n                        swiper.loopFix();\n                    });\n                }\n                // Fix duration\n                if (swiper.velocity !== 0) {\n                    if (rtl) {\n                        momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n                    } else {\n                        momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n                    }\n                    if (params.freeMode.sticky) {\n                        // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n                        // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n                        // It's easy to see this when simulating touch with mouse events. To fix this,\n                        // limit single-slide swipes to the default slide duration. This also has the\n                        // nice side effect of matching slide speed if the user stopped moving before\n                        // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n                        // For faster swipes, also apply limits (albeit higher ones).\n                        const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n                        const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n                        if (moveDistance < currentSlideSize) {\n                            momentumDuration = params.speed;\n                        } else if (moveDistance < 2 * currentSlideSize) {\n                            momentumDuration = params.speed * 1.5;\n                        } else {\n                            momentumDuration = params.speed * 2.5;\n                        }\n                    }\n                } else if (params.freeMode.sticky) {\n                    swiper.slideToClosest();\n                    return;\n                }\n                if (params.freeMode.momentumBounce && doBounce) {\n                    swiper.updateProgress(afterBouncePosition);\n                    swiper.setTransition(momentumDuration);\n                    swiper.setTranslate(newPosition);\n                    swiper.transitionStart(true, swiper.swipeDirection);\n                    swiper.animating = true;\n                    elementTransitionEnd(wrapperEl, () => {\n                        if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n                        emit('momentumBounce');\n                        swiper.setTransition(params.speed);\n                        setTimeout(() => {\n                            swiper.setTranslate(afterBouncePosition);\n                            elementTransitionEnd(wrapperEl, () => {\n                                if (!swiper || swiper.destroyed) return;\n                                swiper.transitionEnd();\n                            });\n                        }, 0);\n                    });\n                } else if (swiper.velocity) {\n                    emit('_freeModeNoMomentumRelease');\n                    swiper.updateProgress(newPosition);\n                    swiper.setTransition(momentumDuration);\n                    swiper.setTranslate(newPosition);\n                    swiper.transitionStart(true, swiper.swipeDirection);\n                    if (!swiper.animating) {\n                        swiper.animating = true;\n                        elementTransitionEnd(wrapperEl, () => {\n                            if (!swiper || swiper.destroyed) return;\n                            swiper.transitionEnd();\n                        });\n                    }\n                } else {\n                    swiper.updateProgress(newPosition);\n                }\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            } else if (params.freeMode.sticky) {\n                swiper.slideToClosest();\n                return;\n            } else if (params.freeMode) {\n                emit('_freeModeNoMomentumRelease');\n            }\n            if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n                emit('_freeModeStaticRelease');\n                swiper.updateProgress();\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            }\n        }\n        Object.assign(swiper, {\n            freeMode: {\n                onTouchStart,\n                onTouchMove,\n                onTouchEnd\n            }\n        });\n    }\n\n    function Grid(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            grid: {\n                rows: 1,\n                fill: 'column'\n            }\n        });\n        let slidesNumberEvenToRows;\n        let slidesPerRow;\n        let numFullColumns;\n        let wasMultiRow;\n        const getSpaceBetween = () => {\n            let spaceBetween = swiper.params.spaceBetween;\n            if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n                spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n            } else if (typeof spaceBetween === 'string') {\n                spaceBetween = parseFloat(spaceBetween);\n            }\n            return spaceBetween;\n        };\n        const initSlides = slides => {\n            const {\n                slidesPerView\n            } = swiper.params;\n            const {\n                rows,\n                fill\n            } = swiper.params.grid;\n            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;\n            numFullColumns = Math.floor(slidesLength / rows);\n            if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n                slidesNumberEvenToRows = slidesLength;\n            } else {\n                slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n            }\n            if (slidesPerView !== 'auto' && fill === 'row') {\n                slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n            }\n            slidesPerRow = slidesNumberEvenToRows / rows;\n        };\n        const unsetSlides = () => {\n            if (swiper.slides) {\n                swiper.slides.forEach(slide => {\n                    if (slide.swiperSlideGridSet) {\n                        slide.style.height = '';\n                        slide.style[swiper.getDirectionLabel('margin-top')] = '';\n                    }\n                });\n            }\n        };\n        const updateSlide = (i, slide, slides) => {\n            const {\n                slidesPerGroup\n            } = swiper.params;\n            const spaceBetween = getSpaceBetween();\n            const {\n                rows,\n                fill\n            } = swiper.params.grid;\n            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;\n            // Set slides order\n            let newSlideOrderIndex;\n            let column;\n            let row;\n            if (fill === 'row' && slidesPerGroup > 1) {\n                const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n                const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n                const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n                row = Math.floor(slideIndexInGroup / columnsInGroup);\n                column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n                newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n                slide.style.order = newSlideOrderIndex;\n            } else if (fill === 'column') {\n                column = Math.floor(i / rows);\n                row = i - column * rows;\n                if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n                    row += 1;\n                    if (row >= rows) {\n                        row = 0;\n                        column += 1;\n                    }\n                }\n            } else {\n                row = Math.floor(i / slidesPerRow);\n                column = i - row * slidesPerRow;\n            }\n            slide.row = row;\n            slide.column = column;\n            slide.style.height = `calc((100% - ${(rows - 1) * spaceBetween}px) / ${rows})`;\n            slide.style[swiper.getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';\n            slide.swiperSlideGridSet = true;\n        };\n        const updateWrapperSize = (slideSize, snapGrid) => {\n            const {\n                centeredSlides,\n                roundLengths\n            } = swiper.params;\n            const spaceBetween = getSpaceBetween();\n            const {\n                rows\n            } = swiper.params.grid;\n            swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n            swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n            if (!swiper.params.cssMode) {\n                swiper.wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n            }\n            if (centeredSlides) {\n                const newSlidesGrid = [];\n                for (let i = 0; i < snapGrid.length; i += 1) {\n                    let slidesGridItem = snapGrid[i];\n                    if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n                    if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n                }\n                snapGrid.splice(0, snapGrid.length);\n                snapGrid.push(...newSlidesGrid);\n            }\n        };\n        const onInit = () => {\n            wasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1;\n        };\n        const onUpdate = () => {\n            const {\n                params,\n                el\n            } = swiper;\n            const isMultiRow = params.grid && params.grid.rows > 1;\n            if (wasMultiRow && !isMultiRow) {\n                el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n                numFullColumns = 1;\n                swiper.emitContainerClasses();\n            } else if (!wasMultiRow && isMultiRow) {\n                el.classList.add(`${params.containerModifierClass}grid`);\n                if (params.grid.fill === 'column') {\n                    el.classList.add(`${params.containerModifierClass}grid-column`);\n                }\n                swiper.emitContainerClasses();\n            }\n            wasMultiRow = isMultiRow;\n        };\n        on('init', onInit);\n        on('update', onUpdate);\n        swiper.grid = {\n            initSlides,\n            unsetSlides,\n            updateSlide,\n            updateWrapperSize\n        };\n    }\n\n    function appendSlide(slides) {\n        const swiper = this;\n        const {\n            params,\n            slidesEl\n        } = swiper;\n        if (params.loop) {\n            swiper.loopDestroy();\n        }\n        const appendElement = slideEl => {\n            if (typeof slideEl === 'string') {\n                const tempDOM = document.createElement('div');\n                tempDOM.innerHTML = slideEl;\n                slidesEl.append(tempDOM.children[0]);\n                tempDOM.innerHTML = '';\n            } else {\n                slidesEl.append(slideEl);\n            }\n        };\n        if (typeof slides === 'object' && 'length' in slides) {\n            for (let i = 0; i < slides.length; i += 1) {\n                if (slides[i]) appendElement(slides[i]);\n            }\n        } else {\n            appendElement(slides);\n        }\n        swiper.recalcSlides();\n        if (params.loop) {\n            swiper.loopCreate();\n        }\n        if (!params.observer || swiper.isElement) {\n            swiper.update();\n        }\n    }\n\n    function prependSlide(slides) {\n        const swiper = this;\n        const {\n            params,\n            activeIndex,\n            slidesEl\n        } = swiper;\n        if (params.loop) {\n            swiper.loopDestroy();\n        }\n        let newActiveIndex = activeIndex + 1;\n        const prependElement = slideEl => {\n            if (typeof slideEl === 'string') {\n                const tempDOM = document.createElement('div');\n                tempDOM.innerHTML = slideEl;\n                slidesEl.prepend(tempDOM.children[0]);\n                tempDOM.innerHTML = '';\n            } else {\n                slidesEl.prepend(slideEl);\n            }\n        };\n        if (typeof slides === 'object' && 'length' in slides) {\n            for (let i = 0; i < slides.length; i += 1) {\n                if (slides[i]) prependElement(slides[i]);\n            }\n            newActiveIndex = activeIndex + slides.length;\n        } else {\n            prependElement(slides);\n        }\n        swiper.recalcSlides();\n        if (params.loop) {\n            swiper.loopCreate();\n        }\n        if (!params.observer || swiper.isElement) {\n            swiper.update();\n        }\n        swiper.slideTo(newActiveIndex, 0, false);\n    }\n\n    function addSlide(index, slides) {\n        const swiper = this;\n        const {\n            params,\n            activeIndex,\n            slidesEl\n        } = swiper;\n        let activeIndexBuffer = activeIndex;\n        if (params.loop) {\n            activeIndexBuffer -= swiper.loopedSlides;\n            swiper.loopDestroy();\n            swiper.recalcSlides();\n        }\n        const baseLength = swiper.slides.length;\n        if (index <= 0) {\n            swiper.prependSlide(slides);\n            return;\n        }\n        if (index >= baseLength) {\n            swiper.appendSlide(slides);\n            return;\n        }\n        let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n        const slidesBuffer = [];\n        for (let i = baseLength - 1; i >= index; i -= 1) {\n            const currentSlide = swiper.slides[i];\n            currentSlide.remove();\n            slidesBuffer.unshift(currentSlide);\n        }\n        if (typeof slides === 'object' && 'length' in slides) {\n            for (let i = 0; i < slides.length; i += 1) {\n                if (slides[i]) slidesEl.append(slides[i]);\n            }\n            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n        } else {\n            slidesEl.append(slides);\n        }\n        for (let i = 0; i < slidesBuffer.length; i += 1) {\n            slidesEl.append(slidesBuffer[i]);\n        }\n        swiper.recalcSlides();\n        if (params.loop) {\n            swiper.loopCreate();\n        }\n        if (!params.observer || swiper.isElement) {\n            swiper.update();\n        }\n        if (params.loop) {\n            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n        } else {\n            swiper.slideTo(newActiveIndex, 0, false);\n        }\n    }\n\n    function removeSlide(slidesIndexes) {\n        const swiper = this;\n        const {\n            params,\n            activeIndex\n        } = swiper;\n        let activeIndexBuffer = activeIndex;\n        if (params.loop) {\n            activeIndexBuffer -= swiper.loopedSlides;\n            swiper.loopDestroy();\n        }\n        let newActiveIndex = activeIndexBuffer;\n        let indexToRemove;\n        if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n            for (let i = 0; i < slidesIndexes.length; i += 1) {\n                indexToRemove = slidesIndexes[i];\n                if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n                if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n            }\n            newActiveIndex = Math.max(newActiveIndex, 0);\n        } else {\n            indexToRemove = slidesIndexes;\n            if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n            newActiveIndex = Math.max(newActiveIndex, 0);\n        }\n        swiper.recalcSlides();\n        if (params.loop) {\n            swiper.loopCreate();\n        }\n        if (!params.observer || swiper.isElement) {\n            swiper.update();\n        }\n        if (params.loop) {\n            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n        } else {\n            swiper.slideTo(newActiveIndex, 0, false);\n        }\n    }\n\n    function removeAllSlides() {\n        const swiper = this;\n        const slidesIndexes = [];\n        for (let i = 0; i < swiper.slides.length; i += 1) {\n            slidesIndexes.push(i);\n        }\n        swiper.removeSlide(slidesIndexes);\n    }\n\n    function Manipulation(_ref) {\n        let {\n            swiper\n        } = _ref;\n        Object.assign(swiper, {\n            appendSlide: appendSlide.bind(swiper),\n            prependSlide: prependSlide.bind(swiper),\n            addSlide: addSlide.bind(swiper),\n            removeSlide: removeSlide.bind(swiper),\n            removeAllSlides: removeAllSlides.bind(swiper)\n        });\n    }\n\n    function effectInit(params) {\n        const {\n            effect,\n            swiper,\n            on,\n            setTranslate,\n            setTransition,\n            overwriteParams,\n            perspective,\n            recreateShadows,\n            getEffectParams\n        } = params;\n        on('beforeInit', () => {\n            if (swiper.params.effect !== effect) return;\n            swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n            if (perspective && perspective()) {\n                swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n            }\n            const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n            Object.assign(swiper.params, overwriteParamsResult);\n            Object.assign(swiper.originalParams, overwriteParamsResult);\n        });\n        on('setTranslate', () => {\n            if (swiper.params.effect !== effect) return;\n            setTranslate();\n        });\n        on('setTransition', (_s, duration) => {\n            if (swiper.params.effect !== effect) return;\n            setTransition(duration);\n        });\n        on('transitionEnd', () => {\n            if (swiper.params.effect !== effect) return;\n            if (recreateShadows) {\n                if (!getEffectParams || !getEffectParams().slideShadows) return;\n                // remove shadows\n                swiper.slides.forEach(slideEl => {\n                    slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());\n                });\n                // create new one\n                recreateShadows();\n            }\n        });\n        let requireUpdateOnVirtual;\n        on('virtualUpdate', () => {\n            if (swiper.params.effect !== effect) return;\n            if (!swiper.slides.length) {\n                requireUpdateOnVirtual = true;\n            }\n            requestAnimationFrame(() => {\n                if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n                    setTranslate();\n                    requireUpdateOnVirtual = false;\n                }\n            });\n        });\n    }\n\n    function effectTarget(effectParams, slideEl) {\n        const transformEl = getSlideTransformEl(slideEl);\n        if (transformEl !== slideEl) {\n            transformEl.style.backfaceVisibility = 'hidden';\n            transformEl.style['-webkit-backface-visibility'] = 'hidden';\n        }\n        return transformEl;\n    }\n\n    function effectVirtualTransitionEnd(_ref) {\n        let {\n            swiper,\n            duration,\n            transformElements,\n            allSlides\n        } = _ref;\n        const {\n            activeIndex\n        } = swiper;\n        const getSlide = el => {\n            if (!el.parentElement) {\n                // assume shadow root\n                const slide = swiper.slides.filter(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];\n                return slide;\n            }\n            return el.parentElement;\n        };\n        if (swiper.params.virtualTranslate && duration !== 0) {\n            let eventTriggered = false;\n            let transitionEndTarget;\n            if (allSlides) {\n                transitionEndTarget = transformElements;\n            } else {\n                transitionEndTarget = transformElements.filter(transformEl => {\n                    const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;\n                    return swiper.getSlideIndex(el) === activeIndex;\n                });\n            }\n            transitionEndTarget.forEach(el => {\n                elementTransitionEnd(el, () => {\n                    if (eventTriggered) return;\n                    if (!swiper || swiper.destroyed) return;\n                    eventTriggered = true;\n                    swiper.animating = false;\n                    const evt = new window.CustomEvent('transitionend', {\n                        bubbles: true,\n                        cancelable: true\n                    });\n                    swiper.wrapperEl.dispatchEvent(evt);\n                });\n            });\n        }\n    }\n\n    function EffectFade(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            fadeEffect: {\n                crossFade: false\n            }\n        });\n        const setTranslate = () => {\n            const {\n                slides\n            } = swiper;\n            const params = swiper.params.fadeEffect;\n            for (let i = 0; i < slides.length; i += 1) {\n                const slideEl = swiper.slides[i];\n                const offset = slideEl.swiperSlideOffset;\n                let tx = -offset;\n                if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n                let ty = 0;\n                if (!swiper.isHorizontal()) {\n                    ty = tx;\n                    tx = 0;\n                }\n                const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.opacity = slideOpacity;\n                targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n            }\n        };\n        const setTransition = duration => {\n            const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n            transformElements.forEach(el => {\n                el.style.transitionDuration = `${duration}ms`;\n            });\n            effectVirtualTransitionEnd({\n                swiper,\n                duration,\n                transformElements,\n                allSlides: true\n            });\n        };\n        effectInit({\n            effect: 'fade',\n            swiper,\n            on,\n            setTranslate,\n            setTransition,\n            overwriteParams: () => ({\n                slidesPerView: 1,\n                slidesPerGroup: 1,\n                watchSlidesProgress: true,\n                spaceBetween: 0,\n                virtualTranslate: !swiper.params.cssMode\n            })\n        });\n    }\n\n    function EffectCube(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            cubeEffect: {\n                slideShadows: true,\n                shadow: true,\n                shadowOffset: 20,\n                shadowScale: 0.94\n            }\n        });\n        const createSlideShadows = (slideEl, progress, isHorizontal) => {\n            let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n            let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n            if (!shadowBefore) {\n                shadowBefore = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));\n                slideEl.append(shadowBefore);\n            }\n            if (!shadowAfter) {\n                shadowAfter = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));\n                slideEl.append(shadowAfter);\n            }\n            if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n            if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n        };\n        const recreateShadows = () => {\n            // create new ones\n            const isHorizontal = swiper.isHorizontal();\n            swiper.slides.forEach(slideEl => {\n                const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                createSlideShadows(slideEl, progress, isHorizontal);\n            });\n        };\n        const setTranslate = () => {\n            const {\n                el,\n                wrapperEl,\n                slides,\n                width: swiperWidth,\n                height: swiperHeight,\n                rtlTranslate: rtl,\n                size: swiperSize,\n                browser\n            } = swiper;\n            const params = swiper.params.cubeEffect;\n            const isHorizontal = swiper.isHorizontal();\n            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n            let wrapperRotate = 0;\n            let cubeShadowEl;\n            if (params.shadow) {\n                if (isHorizontal) {\n                    cubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');\n                    if (!cubeShadowEl) {\n                        cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n                        swiper.wrapperEl.append(cubeShadowEl);\n                    }\n                    cubeShadowEl.style.height = `${swiperWidth}px`;\n                } else {\n                    cubeShadowEl = el.querySelector('.swiper-cube-shadow');\n                    if (!cubeShadowEl) {\n                        cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n                        el.append(cubeShadowEl);\n                    }\n                }\n            }\n            for (let i = 0; i < slides.length; i += 1) {\n                const slideEl = slides[i];\n                let slideIndex = i;\n                if (isVirtual) {\n                    slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n                }\n                let slideAngle = slideIndex * 90;\n                let round = Math.floor(slideAngle / 360);\n                if (rtl) {\n                    slideAngle = -slideAngle;\n                    round = Math.floor(-slideAngle / 360);\n                }\n                const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                let tx = 0;\n                let ty = 0;\n                let tz = 0;\n                if (slideIndex % 4 === 0) {\n                    tx = -round * 4 * swiperSize;\n                    tz = 0;\n                } else if ((slideIndex - 1) % 4 === 0) {\n                    tx = 0;\n                    tz = -round * 4 * swiperSize;\n                } else if ((slideIndex - 2) % 4 === 0) {\n                    tx = swiperSize + round * 4 * swiperSize;\n                    tz = swiperSize;\n                } else if ((slideIndex - 3) % 4 === 0) {\n                    tx = -swiperSize;\n                    tz = 3 * swiperSize + swiperSize * 4 * round;\n                }\n                if (rtl) {\n                    tx = -tx;\n                }\n                if (!isHorizontal) {\n                    ty = tx;\n                    tx = 0;\n                }\n                const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n                if (progress <= 1 && progress > -1) {\n                    wrapperRotate = slideIndex * 90 + progress * 90;\n                    if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n                    if (swiper.browser && swiper.browser.need3dFix && Math.abs(wrapperRotate) / 90 % 2 === 1) {\n                        wrapperRotate += 0.001;\n                    }\n                }\n                slideEl.style.transform = transform;\n                if (params.slideShadows) {\n                    createSlideShadows(slideEl, progress, isHorizontal);\n                }\n            }\n            wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n            wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;\n            if (params.shadow) {\n                if (isHorizontal) {\n                    cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`;\n                } else {\n                    const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n                    const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n                    const scale1 = params.shadowScale;\n                    const scale2 = params.shadowScale / multiplier;\n                    const offset = params.shadowOffset;\n                    cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-89.99deg)`;\n                }\n            }\n            const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n            wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n            wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n        };\n        const setTransition = duration => {\n            const {\n                el,\n                slides\n            } = swiper;\n            slides.forEach(slideEl => {\n                slideEl.style.transitionDuration = `${duration}ms`;\n                slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {\n                    subEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n                const shadowEl = el.querySelector('.swiper-cube-shadow');\n                if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n            }\n        };\n        effectInit({\n            effect: 'cube',\n            swiper,\n            on,\n            setTranslate,\n            setTransition,\n            recreateShadows,\n            getEffectParams: () => swiper.params.cubeEffect,\n            perspective: () => true,\n            overwriteParams: () => ({\n                slidesPerView: 1,\n                slidesPerGroup: 1,\n                watchSlidesProgress: true,\n                resistanceRatio: 0,\n                spaceBetween: 0,\n                centeredSlides: false,\n                virtualTranslate: true\n            })\n        });\n    }\n\n    function createShadow(suffix, slideEl, side) {\n        const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;\n        const shadowContainer = getSlideTransformEl(slideEl);\n        let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);\n        if (!shadowEl) {\n            shadowEl = createElement('div', shadowClass.split(' '));\n            shadowContainer.append(shadowEl);\n        }\n        return shadowEl;\n    }\n\n    function EffectFlip(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            flipEffect: {\n                slideShadows: true,\n                limitRotation: true\n            }\n        });\n        const createSlideShadows = (slideEl, progress) => {\n            let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n            let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n            if (!shadowBefore) {\n                shadowBefore = createShadow('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');\n            }\n            if (!shadowAfter) {\n                shadowAfter = createShadow('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n            }\n            if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n            if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n        };\n        const recreateShadows = () => {\n            // Set shadows\n            swiper.params.flipEffect;\n            swiper.slides.forEach(slideEl => {\n                let progress = slideEl.progress;\n                if (swiper.params.flipEffect.limitRotation) {\n                    progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                }\n                createSlideShadows(slideEl, progress);\n            });\n        };\n        const setTranslate = () => {\n            const {\n                slides,\n                rtlTranslate: rtl\n            } = swiper;\n            const params = swiper.params.flipEffect;\n            for (let i = 0; i < slides.length; i += 1) {\n                const slideEl = slides[i];\n                let progress = slideEl.progress;\n                if (swiper.params.flipEffect.limitRotation) {\n                    progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                }\n                const offset = slideEl.swiperSlideOffset;\n                const rotate = -180 * progress;\n                let rotateY = rotate;\n                let rotateX = 0;\n                let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n                let ty = 0;\n                if (!swiper.isHorizontal()) {\n                    ty = tx;\n                    tx = 0;\n                    rotateX = -rotateY;\n                    rotateY = 0;\n                } else if (rtl) {\n                    rotateY = -rotateY;\n                }\n                if (swiper.browser && swiper.browser.need3dFix) {\n                    if (Math.abs(rotateY) / 90 % 2 === 1) {\n                        rotateY += 0.001;\n                    }\n                    if (Math.abs(rotateX) / 90 % 2 === 1) {\n                        rotateX += 0.001;\n                    }\n                }\n                slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n                if (params.slideShadows) {\n                    createSlideShadows(slideEl, progress);\n                }\n                const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n            }\n        };\n        const setTransition = duration => {\n            const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n            transformElements.forEach(el => {\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper,\n                duration,\n                transformElements\n            });\n        };\n        effectInit({\n            effect: 'flip',\n            swiper,\n            on,\n            setTranslate,\n            setTransition,\n            recreateShadows,\n            getEffectParams: () => swiper.params.flipEffect,\n            perspective: () => true,\n            overwriteParams: () => ({\n                slidesPerView: 1,\n                slidesPerGroup: 1,\n                watchSlidesProgress: true,\n                spaceBetween: 0,\n                virtualTranslate: !swiper.params.cssMode\n            })\n        });\n    }\n\n    function EffectCoverflow(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            coverflowEffect: {\n                rotate: 50,\n                stretch: 0,\n                depth: 100,\n                scale: 1,\n                modifier: 1,\n                slideShadows: true\n            }\n        });\n        const setTranslate = () => {\n            const {\n                width: swiperWidth,\n                height: swiperHeight,\n                slides,\n                slidesSizesGrid\n            } = swiper;\n            const params = swiper.params.coverflowEffect;\n            const isHorizontal = swiper.isHorizontal();\n            const transform = swiper.translate;\n            const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n            const rotate = isHorizontal ? params.rotate : -params.rotate;\n            const translate = params.depth;\n            // Each slide offset from center\n            for (let i = 0, length = slides.length; i < length; i += 1) {\n                const slideEl = slides[i];\n                const slideSize = slidesSizesGrid[i];\n                const slideOffset = slideEl.swiperSlideOffset;\n                const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n                const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;\n                let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n                let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n                // var rotateZ = 0\n                let translateZ = -translate * Math.abs(offsetMultiplier);\n                let stretch = params.stretch;\n                // Allow percentage to make a relative stretch for responsive sliders\n                if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n                    stretch = parseFloat(params.stretch) / 100 * slideSize;\n                }\n                let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n                let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n                let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n                // Fix for ultra small values\n                if (Math.abs(translateX) < 0.001) translateX = 0;\n                if (Math.abs(translateY) < 0.001) translateY = 0;\n                if (Math.abs(translateZ) < 0.001) translateZ = 0;\n                if (Math.abs(rotateY) < 0.001) rotateY = 0;\n                if (Math.abs(rotateX) < 0.001) rotateX = 0;\n                if (Math.abs(scale) < 0.001) scale = 0;\n                if (swiper.browser && swiper.browser.need3dFix) {\n                    if (Math.abs(rotateY) / 90 % 2 === 1) {\n                        rotateY += 0.001;\n                    }\n                    if (Math.abs(rotateX) / 90 % 2 === 1) {\n                        rotateX += 0.001;\n                    }\n                }\n                const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = slideTransform;\n                slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n                if (params.slideShadows) {\n                    // Set shadows\n                    let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n                    let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n                    if (!shadowBeforeEl) {\n                        shadowBeforeEl = createShadow('coverflow', slideEl, isHorizontal ? 'left' : 'top');\n                    }\n                    if (!shadowAfterEl) {\n                        shadowAfterEl = createShadow('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');\n                    }\n                    if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n                    if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n                }\n            }\n        };\n        const setTransition = duration => {\n            const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n            transformElements.forEach(el => {\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n        };\n        effectInit({\n            effect: 'coverflow',\n            swiper,\n            on,\n            setTranslate,\n            setTransition,\n            perspective: () => true,\n            overwriteParams: () => ({\n                watchSlidesProgress: true\n            })\n        });\n    }\n\n    function EffectCreative(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            creativeEffect: {\n                limitProgress: 1,\n                shadowPerProgress: false,\n                progressMultiplier: 1,\n                perspective: true,\n                prev: {\n                    translate: [0, 0, 0],\n                    rotate: [0, 0, 0],\n                    opacity: 1,\n                    scale: 1\n                },\n                next: {\n                    translate: [0, 0, 0],\n                    rotate: [0, 0, 0],\n                    opacity: 1,\n                    scale: 1\n                }\n            }\n        });\n        const getTranslateValue = value => {\n            if (typeof value === 'string') return value;\n            return `${value}px`;\n        };\n        const setTranslate = () => {\n            const {\n                slides,\n                wrapperEl,\n                slidesSizesGrid\n            } = swiper;\n            const params = swiper.params.creativeEffect;\n            const {\n                progressMultiplier: multiplier\n            } = params;\n            const isCenteredSlides = swiper.params.centeredSlides;\n            if (isCenteredSlides) {\n                const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n                wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n            }\n            for (let i = 0; i < slides.length; i += 1) {\n                const slideEl = slides[i];\n                const slideProgress = slideEl.progress;\n                const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n                let originalProgress = progress;\n                if (!isCenteredSlides) {\n                    originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n                }\n                const offset = slideEl.swiperSlideOffset;\n                const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n                const r = [0, 0, 0];\n                let custom = false;\n                if (!swiper.isHorizontal()) {\n                    t[1] = t[0];\n                    t[0] = 0;\n                }\n                let data = {\n                    translate: [0, 0, 0],\n                    rotate: [0, 0, 0],\n                    scale: 1,\n                    opacity: 1\n                };\n                if (progress < 0) {\n                    data = params.next;\n                    custom = true;\n                } else if (progress > 0) {\n                    data = params.prev;\n                    custom = true;\n                }\n                // set translate\n                t.forEach((value, index) => {\n                    t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n                });\n                // set rotates\n                r.forEach((value, index) => {\n                    let val = data.rotate[index] * Math.abs(progress * multiplier);\n                    if (swiper.browser && swiper.browser.need3dFix && Math.abs(val) / 90 % 2 === 1) {\n                        val += 0.001;\n                    }\n                    r[index] = val;\n                });\n                slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n                const translateString = t.join(', ');\n                const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n                const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n                const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n                const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n                // Set shadows\n                if (custom && data.shadow || !custom) {\n                    let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n                    if (!shadowEl && data.shadow) {\n                        shadowEl = createShadow('creative', slideEl);\n                    }\n                    if (shadowEl) {\n                        const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n                        shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n                    }\n                }\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n                targetEl.style.opacity = opacityString;\n                if (data.origin) {\n                    targetEl.style.transformOrigin = data.origin;\n                }\n            }\n        };\n        const setTransition = duration => {\n            const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n            transformElements.forEach(el => {\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper,\n                duration,\n                transformElements,\n                allSlides: true\n            });\n        };\n        effectInit({\n            effect: 'creative',\n            swiper,\n            on,\n            setTranslate,\n            setTransition,\n            perspective: () => swiper.params.creativeEffect.perspective,\n            overwriteParams: () => ({\n                watchSlidesProgress: true,\n                virtualTranslate: !swiper.params.cssMode\n            })\n        });\n    }\n\n    function EffectCards(_ref) {\n        let {\n            swiper,\n            extendParams,\n            on\n        } = _ref;\n        extendParams({\n            cardsEffect: {\n                slideShadows: true,\n                rotate: true,\n                perSlideRotate: 2,\n                perSlideOffset: 8\n            }\n        });\n        const setTranslate = () => {\n            const {\n                slides,\n                activeIndex,\n                rtlTranslate: rtl\n            } = swiper;\n            const params = swiper.params.cardsEffect;\n            const {\n                startTranslate,\n                isTouched\n            } = swiper.touchEventsData;\n            const currentTranslate = rtl ? -swiper.translate : swiper.translate;\n            for (let i = 0; i < slides.length; i += 1) {\n                const slideEl = slides[i];\n                const slideProgress = slideEl.progress;\n                const progress = Math.min(Math.max(slideProgress, -4), 4);\n                let offset = slideEl.swiperSlideOffset;\n                if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n                    swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n                }\n                if (swiper.params.centeredSlides && swiper.params.cssMode) {\n                    offset -= slides[0].swiperSlideOffset;\n                }\n                let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n                let tY = 0;\n                const tZ = -100 * Math.abs(progress);\n                let scale = 1;\n                let rotate = -params.perSlideRotate * progress;\n                let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n                const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n                const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n                const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n                if (isSwipeToNext || isSwipeToPrev) {\n                    const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n                    rotate += -28 * progress * subProgress;\n                    scale += -0.5 * subProgress;\n                    tXAdd += 96 * subProgress;\n                    tY = `${-25 * subProgress * Math.abs(progress)}%`;\n                }\n                if (progress < 0) {\n                    // next\n                    tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;\n                } else if (progress > 0) {\n                    // prev\n                    tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;\n                } else {\n                    tX = `${tX}px`;\n                }\n                if (!swiper.isHorizontal()) {\n                    const prevY = tY;\n                    tY = tX;\n                    tX = prevY;\n                }\n                const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n\n                /* eslint-disable */\n                const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;\n                /* eslint-enable */\n\n                if (params.slideShadows) {\n                    // Set shadows\n                    let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n                    if (!shadowEl) {\n                        shadowEl = createShadow('cards', slideEl);\n                    }\n                    if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n                }\n                slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n            }\n        };\n        const setTransition = duration => {\n            const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n            transformElements.forEach(el => {\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper,\n                duration,\n                transformElements\n            });\n        };\n        effectInit({\n            effect: 'cards',\n            swiper,\n            on,\n            setTranslate,\n            setTransition,\n            perspective: () => true,\n            overwriteParams: () => ({\n                watchSlidesProgress: true,\n                virtualTranslate: !swiper.params.cssMode\n            })\n        });\n    }\n\n    /**\n     * Swiper 11.1.4\n     * Most modern mobile touch slider and framework with hardware accelerated transitions\n     * https://swiperjs.com\n     *\n     * Copyright 2014-2024 Vladimir Kharlampidi\n     *\n     * Released under the MIT License\n     *\n     * Released on: May 30, 2024\n     */\n\n\n        // Swiper Class\n    const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];\n    Swiper.use(modules);\n\n    return Swiper;\n\n})();"]}